From b6d7b36bf29d213b7c6c5b41988447d6b725707f Mon Sep 17 00:00:00 2001
From: Dan Williams <dcbw@redhat.com>
Date: Tue, 3 Mar 2015 11:28:07 -0600
Subject: [PATCH 1/1] ibft: port iBFT standalone plugin to EL6 (rh #1198325)

Anaconda bug is (rh #831002)
---
 configure.ac                                       |    2 +
 src/system-settings/nm-sysconfig-settings.c        |    9 +-
 system-settings/plugins/Makefile.am                |    2 +-
 system-settings/plugins/ibft/Makefile.am           |   36 ++
 system-settings/plugins/ibft/common.h              |   43 ++
 system-settings/plugins/ibft/errors.c              |   35 ++
 system-settings/plugins/ibft/nm-ibft-connection.c  |   63 +++
 system-settings/plugins/ibft/nm-ibft-connection.h  |   50 ++
 system-settings/plugins/ibft/plugin.c              |  207 +++++++
 system-settings/plugins/ibft/plugin.h              |   47 ++
 system-settings/plugins/ibft/reader.c              |  577 ++++++++++++++++++++
 system-settings/plugins/ibft/reader.h              |   36 ++
 system-settings/plugins/ibft/tests/Makefile.am     |   43 ++
 .../plugins/ibft/tests/iscsiadm-test-bad-dns1      |   21 +
 .../plugins/ibft/tests/iscsiadm-test-bad-dns2      |   21 +
 .../plugins/ibft/tests/iscsiadm-test-bad-entry     |   20 +
 .../plugins/ibft/tests/iscsiadm-test-bad-gateway   |   21 +
 .../plugins/ibft/tests/iscsiadm-test-bad-ipaddr    |   21 +
 .../plugins/ibft/tests/iscsiadm-test-bad-record    |   18 +
 .../plugins/ibft/tests/iscsiadm-test-dhcp          |   33 ++
 .../plugins/ibft/tests/iscsiadm-test-static        |   35 ++
 .../plugins/ibft/tests/iscsiadm-test-vlan          |   19 +
 system-settings/plugins/ibft/tests/test-ibft.c     |  326 +++++++++++
 system-settings/plugins/ifcfg-rh/reader.c          |  284 +---------
 .../plugins/ifcfg-rh/tests/iscsiadm-test-bad-dns1  |   21 -
 .../plugins/ifcfg-rh/tests/iscsiadm-test-bad-dns2  |   21 -
 .../ifcfg-rh/tests/iscsiadm-test-bad-gateway       |   21 -
 .../ifcfg-rh/tests/iscsiadm-test-bad-ipaddr        |   21 -
 .../plugins/ifcfg-rh/tests/iscsiadm-test-dhcp      |   33 --
 .../plugins/ifcfg-rh/tests/iscsiadm-test-static    |   35 --
 .../ifcfg-rh/tests/network-scripts/ifcfg-test-ibft |   10 +
 .../tests/network-scripts/ifcfg-test-ibft-dhcp     |    4 -
 .../tests/network-scripts/ifcfg-test-ibft-static   |    4 -
 .../plugins/ifcfg-rh/tests/test-ifcfg-rh.c         |  368 +------------
 34 files changed, 1710 insertions(+), 797 deletions(-)
 create mode 100644 system-settings/plugins/ibft/Makefile.am
 create mode 100644 system-settings/plugins/ibft/common.h
 create mode 100644 system-settings/plugins/ibft/errors.c
 create mode 100644 system-settings/plugins/ibft/nm-ibft-connection.c
 create mode 100644 system-settings/plugins/ibft/nm-ibft-connection.h
 create mode 100644 system-settings/plugins/ibft/plugin.c
 create mode 100644 system-settings/plugins/ibft/plugin.h
 create mode 100644 system-settings/plugins/ibft/reader.c
 create mode 100644 system-settings/plugins/ibft/reader.h
 create mode 100644 system-settings/plugins/ibft/tests/Makefile.am
 create mode 100755 system-settings/plugins/ibft/tests/iscsiadm-test-bad-dns1
 create mode 100755 system-settings/plugins/ibft/tests/iscsiadm-test-bad-dns2
 create mode 100755 system-settings/plugins/ibft/tests/iscsiadm-test-bad-entry
 create mode 100755 system-settings/plugins/ibft/tests/iscsiadm-test-bad-gateway
 create mode 100755 system-settings/plugins/ibft/tests/iscsiadm-test-bad-ipaddr
 create mode 100755 system-settings/plugins/ibft/tests/iscsiadm-test-bad-record
 create mode 100755 system-settings/plugins/ibft/tests/iscsiadm-test-dhcp
 create mode 100755 system-settings/plugins/ibft/tests/iscsiadm-test-static
 create mode 100755 system-settings/plugins/ibft/tests/iscsiadm-test-vlan
 create mode 100644 system-settings/plugins/ibft/tests/test-ibft.c
 delete mode 100755 system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-bad-dns1
 delete mode 100755 system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-bad-dns2
 delete mode 100755 system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-bad-gateway
 delete mode 100755 system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-bad-ipaddr
 delete mode 100755 system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-dhcp
 delete mode 100755 system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-static
 create mode 100644 system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-ibft
 delete mode 100644 system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-ibft-dhcp
 delete mode 100644 system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-ibft-static

diff --git a/configure.ac b/configure.ac
index 9adafb5..6f6c4e1 100644
--- a/configure.ac
+++ b/configure.ac
@@ -499,6 +499,8 @@ system-settings/plugins/keyfile/Makefile
 system-settings/plugins/keyfile/io/Makefile
 system-settings/plugins/keyfile/tests/Makefile
 system-settings/plugins/keyfile/tests/keyfiles/Makefile
+system-settings/plugins/ibft/Makefile
+system-settings/plugins/ibft/tests/Makefile
 cli/Makefile
 cli/src/Makefile
 test/Makefile
diff --git a/src/system-settings/nm-sysconfig-settings.c b/src/system-settings/nm-sysconfig-settings.c
index 6074c9f..1c22fcb 100644
--- a/src/system-settings/nm-sysconfig-settings.c
+++ b/src/system-settings/nm-sysconfig-settings.c
@@ -401,20 +401,20 @@ find_plugin (GSList *list, const char *pname)
 }
 
 static char **
-add_keyfile_plugin (char **plugins)
+add_default_plugin (const char *plugin, char **plugins)
 {
 	char **new_plugins;
 	int i;
 
 	for (i = 0; plugins[i]; i++) {
-		if (!strcmp (plugins[i], "keyfile"))
+		if (!strcmp (plugins[i], plugin))
 			return plugins;
 	}
 
 	new_plugins = g_new (char *, i + 2);
 	for (i = 0; plugins[i]; i++)
 		new_plugins[i] = plugins[i];
-	new_plugins[i] = g_strdup ("keyfile");
+	new_plugins[i] = g_strdup (plugin);
 	new_plugins[i + 1] = NULL;
 
 	g_free (plugins);
@@ -432,7 +432,8 @@ load_plugins (NMSysconfigSettings *self, const char *plugins, GError **error)
 	plist = g_strsplit (plugins, ",", 0);
 	if (!plist)
 		return FALSE;
-	plist = add_keyfile_plugin (plist);
+	plist = add_default_plugin ("keyfile", plist);
+	plist = add_default_plugin ("ibft", plist);
 
 	for (iter = plist; *iter; iter++) {
 		GModule *plugin;
diff --git a/system-settings/plugins/Makefile.am b/system-settings/plugins/Makefile.am
index 94f7560..8e8cf38 100644
--- a/system-settings/plugins/Makefile.am
+++ b/system-settings/plugins/Makefile.am
@@ -1,4 +1,4 @@
-SUBDIRS=keyfile
+SUBDIRS=keyfile ibft
 
 if TARGET_REDHAT
 SUBDIRS+=ifcfg-rh
diff --git a/system-settings/plugins/ibft/Makefile.am b/system-settings/plugins/ibft/Makefile.am
new file mode 100644
index 0000000..26f2032
--- /dev/null
+++ b/system-settings/plugins/ibft/Makefile.am
@@ -0,0 +1,36 @@
+SUBDIRS = . tests
+
+pkglib_LTLIBRARIES = libnm-settings-plugin-ibft.la
+
+noinst_LTLIBRARIES = libibft-io.la
+
+libibft_io_la_SOURCES = \
+	reader.c \
+	reader.h \
+	errors.c \
+	common.h
+
+AM_CPPFLAGS = \
+	-I$(top_srcdir)/src/system-settings \
+	-I$(top_srcdir)/include \
+	-I$(top_srcdir)/libnm-glib \
+	-I$(top_srcdir)/libnm-util \
+	-I$(top_builddir)/marshallers \
+	$(GLIB_CFLAGS) \
+	$(DBUS_CFLAGS) \
+	$(GMODULE_CFLAGS) \
+	-DG_DISABLE_DEPRECATED \
+	-DSYSCONFDIR=\"$(sysconfdir)\" \
+	-DSBINDIR=\"$(sbindir)\"
+
+libnm_settings_plugin_ibft_la_SOURCES = \
+	plugin.c \
+	plugin.h \
+	nm-ibft-connection.c \
+	nm-ibft-connection.h
+
+libnm_settings_plugin_ibft_la_LDFLAGS = -module -avoid-version
+libnm_settings_plugin_ibft_la_LIBADD = libibft-io.la
+
+CLEANFILES = $(BUILT_SOURCES)
+
diff --git a/system-settings/plugins/ibft/common.h b/system-settings/plugins/ibft/common.h
new file mode 100644
index 0000000..129c4df
--- /dev/null
+++ b/system-settings/plugins/ibft/common.h
@@ -0,0 +1,43 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager system settings service
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2008 - 2009 Red Hat, Inc.
+ */
+
+#ifndef __COMMON_H__
+#define __COMMON_H__
+
+#include <glib.h>
+#include <stdlib.h>
+
+#define IBFT_PLUGIN_NAME "ibft"
+#define IBFT_PLUGIN_INFO "(c) 2015 Red Hat, Inc.  To report bugs please use the NetworkManager mailing list."
+
+#define IBFT_PRINT(fmt, args...) \
+	{ g_message ("   " IBFT_PLUGIN_NAME ": " fmt, ##args); }
+
+#define IBFT_DEBUG(fmt, args...) \
+	{ if (getenv ("IBFT_DEBUG")) g_debug ("   " IBFT_PLUGIN_NAME ": " fmt, ##args); }
+
+#define IBFT_WARN(fmt, args...) \
+	{ g_warning ("   " IBFT_PLUGIN_NAME ": " fmt, ##args); }
+
+#define IBFT_PLUGIN_ERROR (ibft_plugin_error_quark ())
+GQuark ibft_plugin_error_quark (void);
+
+#endif  /* __COMMON_H__ */
+
diff --git a/system-settings/plugins/ibft/errors.c b/system-settings/plugins/ibft/errors.c
new file mode 100644
index 0000000..4a64b8f
--- /dev/null
+++ b/system-settings/plugins/ibft/errors.c
@@ -0,0 +1,35 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager system settings service
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2008 - 2009 Red Hat, Inc.
+ */
+
+#include <glib.h>
+#include "common.h"
+
+GQuark
+ibft_plugin_error_quark (void)
+{
+	static GQuark error_quark = 0;
+
+	if (G_UNLIKELY (error_quark == 0))
+		error_quark = g_quark_from_static_string ("ibft-plugin-error-quark");
+
+	return error_quark;
+}
+
+
diff --git a/system-settings/plugins/ibft/nm-ibft-connection.c b/system-settings/plugins/ibft/nm-ibft-connection.c
new file mode 100644
index 0000000..b7f58e0
--- /dev/null
+++ b/system-settings/plugins/ibft/nm-ibft-connection.c
@@ -0,0 +1,63 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager system settings service
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2014 Red Hat, Inc.
+ */
+
+#include "config.h"
+
+#include <string.h>
+#include <net/ethernet.h>
+#include <netinet/ether.h>
+
+#include <glib/gstdio.h>
+
+#include "nm-ibft-connection.h"
+#include "reader.h"
+
+G_DEFINE_TYPE (NMIbftConnection, nm_ibft_connection, NM_TYPE_SYSCONFIG_CONNECTION)
+
+NMIbftConnection *
+nm_ibft_connection_new (const GPtrArray *block, GError **error)
+{
+	NMConnection *source;
+	GObject *object;
+
+	source = connection_from_block (block, error);
+	if (!source)
+		return NULL;
+
+	object = g_object_new (NM_TYPE_IBFT_CONNECTION, NULL);
+	/* Update settings with what was read from iscsiadm */
+	if (!nm_sysconfig_connection_update (NM_SYSCONFIG_CONNECTION (object), source, FALSE, error))
+		g_clear_object (&object);
+
+	return (NMIbftConnection *) object;
+}
+
+/* GObject */
+
+static void
+nm_ibft_connection_init (NMIbftConnection *connection)
+{
+}
+
+static void
+nm_ibft_connection_class_init (NMIbftConnectionClass *ibft_connection_class)
+{
+}
+
diff --git a/system-settings/plugins/ibft/nm-ibft-connection.h b/system-settings/plugins/ibft/nm-ibft-connection.h
new file mode 100644
index 0000000..95ac39f
--- /dev/null
+++ b/system-settings/plugins/ibft/nm-ibft-connection.h
@@ -0,0 +1,50 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager system settings service
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2014 Red Hat, Inc.
+ */
+
+#ifndef NM_IBFT_CONNECTION_H
+#define NM_IBFT_CONNECTION_H
+
+G_BEGIN_DECLS
+
+#include <nm-sysconfig-connection.h>
+
+#define NM_TYPE_IBFT_CONNECTION            (nm_ibft_connection_get_type ())
+#define NM_IBFT_CONNECTION(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_IBFT_CONNECTION, NMIbftConnection))
+#define NM_IBFT_CONNECTION_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_IBFT_CONNECTION, NMIbftConnectionClass))
+#define NM_IS_IBFT_CONNECTION(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_IBFT_CONNECTION))
+#define NM_IS_IBFT_CONNECTION_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), NM_TYPE_IBFT_CONNECTION))
+#define NM_IBFT_CONNECTION_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_IBFT_CONNECTION, NMIbftConnectionClass))
+
+typedef struct {
+	NMSysconfigConnection parent;
+} NMIbftConnection;
+
+typedef struct {
+	NMSysconfigConnectionClass parent;
+} NMIbftConnectionClass;
+
+GType nm_ibft_connection_get_type (void);
+
+NMIbftConnection *nm_ibft_connection_new (const GPtrArray *block,
+                                          GError **error);
+
+G_END_DECLS
+
+#endif /* NM_IBFT_CONNECTION_H */
diff --git a/system-settings/plugins/ibft/plugin.c b/system-settings/plugins/ibft/plugin.c
new file mode 100644
index 0000000..b655cfb
--- /dev/null
+++ b/system-settings/plugins/ibft/plugin.c
@@ -0,0 +1,207 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager system settings service
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2014 Red Hat, Inc.
+ */
+
+#include "config.h"
+
+#include <string.h>
+#include <unistd.h>
+#include <errno.h>
+
+#include <gmodule.h>
+#include <glib-object.h>
+#include <glib/gi18n.h>
+#include <gio/gio.h>
+
+#include "nm-dbus-glib-types.h"
+#include "nm-system-config-interface.h"
+
+#include "common.h"
+#include "plugin.h"
+#include "reader.h"
+#include "nm-ibft-connection.h"
+
+static void system_config_interface_init (NMSystemConfigInterface *system_config_interface_class);
+
+G_DEFINE_TYPE_EXTENDED (SCPluginIbft, sc_plugin_ibft, G_TYPE_OBJECT, 0,
+                        G_IMPLEMENT_INTERFACE (NM_TYPE_SYSTEM_CONFIG_INTERFACE,
+                                               system_config_interface_init))
+
+#define SC_PLUGIN_IBFT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), SC_TYPE_PLUGIN_IBFT, SCPluginIbftPrivate))
+
+
+typedef struct {
+	GHashTable *connections;  /* uuid::connection */
+	gboolean initialized;
+} SCPluginIbftPrivate;
+
+static void
+read_connections (SCPluginIbft *self)
+{
+	SCPluginIbftPrivate *priv = SC_PLUGIN_IBFT_GET_PRIVATE (self);
+	GSList *blocks = NULL, *iter;
+	GError *error = NULL;
+	NMIbftConnection *connection;
+
+	if (!read_ibft_blocks ("/sbin/iscsiadm", &blocks, &error)) {
+		IBFT_DEBUG ("failed to read iscsiadm records: %s", error->message);
+		g_error_free (error);
+		return;
+	}
+
+	for (iter = blocks; iter; iter = iter->next) {
+		connection = nm_ibft_connection_new (iter->data, &error);
+		if (connection) {
+			IBFT_PRINT ("read connection '%s'",
+			             nm_connection_get_id (NM_CONNECTION (connection)));
+			g_hash_table_insert (priv->connections,
+			                     g_strdup (nm_connection_get_uuid (NM_CONNECTION (connection))),
+			                     connection);
+		} else {
+			IBFT_WARN ("failed to read iscsiadm record: %s", error->message);
+			g_clear_error (&error);
+		}
+	}
+
+	g_slist_free_full (blocks, (GDestroyNotify) g_ptr_array_unref);
+}
+
+static GSList *
+get_connections (NMSystemConfigInterface *config)
+{
+	SCPluginIbft *self = SC_PLUGIN_IBFT (config);
+	SCPluginIbftPrivate *priv = SC_PLUGIN_IBFT_GET_PRIVATE (self);
+	GSList *list = NULL;
+	GHashTableIter iter;
+	NMIbftConnection *connection;
+
+	if (!priv->initialized) {
+		read_connections (self);
+		priv->initialized = TRUE;
+	}
+
+	g_hash_table_iter_init (&iter, priv->connections);
+	while (g_hash_table_iter_next (&iter, NULL, (gpointer) &connection))
+		list = g_slist_prepend (list, connection);
+
+	return list;
+}
+
+static void
+init (NMSystemConfigInterface *config)
+{
+}
+
+static void
+sc_plugin_ibft_init (SCPluginIbft *self)
+{
+	SCPluginIbftPrivate *priv = SC_PLUGIN_IBFT_GET_PRIVATE (self);
+
+	priv->connections = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_object_unref);
+}
+
+static void
+dispose (GObject *object)
+{
+	SCPluginIbft *self = SC_PLUGIN_IBFT (object);
+	SCPluginIbftPrivate *priv = SC_PLUGIN_IBFT_GET_PRIVATE (self);
+
+	if (priv->connections) {
+		g_hash_table_destroy (priv->connections);
+		priv->connections = NULL;
+	}
+
+	G_OBJECT_CLASS (sc_plugin_ibft_parent_class)->dispose (object);
+}
+
+static void
+get_property (GObject *object, guint prop_id,
+              GValue *value, GParamSpec *pspec)
+{
+	switch (prop_id) {
+	case NM_SYSTEM_CONFIG_INTERFACE_PROP_NAME:
+		g_value_set_string (value, IBFT_PLUGIN_NAME);
+		break;
+	case NM_SYSTEM_CONFIG_INTERFACE_PROP_INFO:
+		g_value_set_string (value, IBFT_PLUGIN_INFO);
+		break;
+	case NM_SYSTEM_CONFIG_INTERFACE_PROP_CAPABILITIES:
+		g_value_set_uint (value, NM_SYSTEM_CONFIG_INTERFACE_CAP_NONE);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+set_property (GObject *object, guint prop_id,
+              const GValue *value, GParamSpec *pspec)
+{
+	G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+}
+
+static void
+sc_plugin_ibft_class_init (SCPluginIbftClass *req_class)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (req_class);
+
+	g_type_class_add_private (req_class, sizeof (SCPluginIbftPrivate));
+
+	object_class->dispose = dispose;
+	object_class->get_property = get_property;
+	object_class->set_property = set_property;
+
+	g_object_class_override_property (object_class,
+	                                  NM_SYSTEM_CONFIG_INTERFACE_PROP_NAME,
+	                                  NM_SYSTEM_CONFIG_INTERFACE_NAME);
+
+	g_object_class_override_property (object_class,
+	                                  NM_SYSTEM_CONFIG_INTERFACE_PROP_INFO,
+	                                  NM_SYSTEM_CONFIG_INTERFACE_INFO);
+
+	g_object_class_override_property (object_class,
+	                                  NM_SYSTEM_CONFIG_INTERFACE_PROP_CAPABILITIES,
+	                                  NM_SYSTEM_CONFIG_INTERFACE_CAPABILITIES);
+
+	g_object_class_override_property (object_class,
+	                                  NM_SYSTEM_CONFIG_INTERFACE_PROP_HOSTNAME,
+	                                  NM_SYSTEM_CONFIG_INTERFACE_HOSTNAME);
+}
+
+static void
+system_config_interface_init (NMSystemConfigInterface *system_config_interface_class)
+{
+	/* interface implementation */
+	system_config_interface_class->get_connections = get_connections;
+	system_config_interface_class->init = init;
+}
+
+G_MODULE_EXPORT GObject *
+nm_system_config_factory (void)
+{
+	static SCPluginIbft *singleton = NULL;
+
+	if (!singleton)
+		singleton = SC_PLUGIN_IBFT (g_object_new (SC_TYPE_PLUGIN_IBFT, NULL));
+	else
+		g_object_ref (singleton);
+
+	return G_OBJECT (singleton);
+}
diff --git a/system-settings/plugins/ibft/plugin.h b/system-settings/plugins/ibft/plugin.h
new file mode 100644
index 0000000..2c81135
--- /dev/null
+++ b/system-settings/plugins/ibft/plugin.h
@@ -0,0 +1,47 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager system settings service
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2014 Red Hat, Inc.
+ */
+
+#ifndef _PLUGIN_H_
+#define _PLUGIN_H_
+
+#include <glib-object.h>
+
+#define SC_TYPE_PLUGIN_IBFT            (sc_plugin_ibft_get_type ())
+#define SC_PLUGIN_IBFT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), SC_TYPE_PLUGIN_IBFT, SCPluginIbft))
+#define SC_PLUGIN_IBFT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), SC_TYPE_PLUGIN_IBFT, SCPluginIbftClass))
+#define SC_IS_PLUGIN_IBFT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), SC_TYPE_PLUGIN_IBFT))
+#define SC_IS_PLUGIN_IBFT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), SC_TYPE_PLUGIN_IBFT))
+#define SC_PLUGIN_IBFT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), SC_TYPE_PLUGIN_IBFT, SCPluginIbftClass))
+
+typedef struct _SCPluginIbft SCPluginIbft;
+typedef struct _SCPluginIbftClass SCPluginIbftClass;
+
+struct _SCPluginIbft {
+	GObject parent;
+};
+
+struct _SCPluginIbftClass {
+	GObjectClass parent;
+};
+
+GType sc_plugin_ibft_get_type (void);
+
+#endif	/* _PLUGIN_H_ */
+
diff --git a/system-settings/plugins/ibft/reader.c b/system-settings/plugins/ibft/reader.c
new file mode 100644
index 0000000..2267267
--- /dev/null
+++ b/system-settings/plugins/ibft/reader.c
@@ -0,0 +1,577 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager system settings service
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2014 Red Hat, Inc.
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <string.h>
+#include <sys/types.h>
+#include <sys/socket.h>
+#include <arpa/inet.h>
+#include <sys/wait.h>
+#include <sys/inotify.h>
+#include <errno.h>
+#include <sys/ioctl.h>
+#include <unistd.h>
+
+#include <net/ethernet.h>
+#include <netinet/ether.h>
+
+#include <glib.h>
+#include <glib/gi18n.h>
+
+#include <nm-connection.h>
+#include <NetworkManager.h>
+#include <nm-setting-bond.h>
+#include <nm-setting-bridge.h>
+#include <nm-setting-bridge-port.h>
+#include <nm-setting-connection.h>
+#include <nm-setting-ip4-config.h>
+#include <nm-setting-vlan.h>
+#include <nm-setting-ip6-config.h>
+#include <nm-setting-wired.h>
+#include <nm-setting-wireless.h>
+#include <nm-setting-infiniband.h>
+#include <nm-setting-8021x.h>
+#include <nm-utils.h>
+
+#include "common.h"
+#include "reader.h"
+
+/* Removes trailing whitespace and whitespace before and immediately after the '=' */
+static char *
+remove_most_whitespace (const char *src)
+{
+	char *s_new, *s2;
+	const char *svalue;
+
+	while (*src && g_ascii_isspace (*src))
+		src++;
+
+	svalue = strchr (src, '=');
+	if (!svalue || svalue == src)
+		return NULL;
+
+	s_new = g_new (char, strlen (src) + 1);
+
+	memcpy (s_new, src, svalue - src);
+	s_new[svalue - src] = '\0';
+	g_strchomp (s_new);
+
+	svalue++;
+	while (*svalue && g_ascii_isspace (*svalue))
+		svalue++;
+
+	s2 = strchr (s_new, '\0');
+	s2[0] = '=';
+	strcpy (++s2, svalue);
+	g_strchomp (s2);
+
+	return s_new;
+}
+
+#define TAG_BEGIN "# BEGIN RECORD"
+#define TAG_END   "# END RECORD"
+
+/**
+ * read_ibft_blocks:
+ * @iscsiadm_path: path to iscsiadm program
+ * @out_blocks: on return if successful, a #GSList of #GPtrArray, or %NULL on
+ * failure
+ * @error: location for an error on failure
+ *
+ * Parses iscsiadm output and returns a #GSList of #GPtrArray in the @out_blocks
+ * argument on success, otherwise @out_blocks is set to %NULL.  Each #GPtrArray
+ * in @out_blocks contains the lines from an iscsiadm interface block.
+ *
+ * Returns: %TRUE on success, %FALSE on errors
+ */
+gboolean
+read_ibft_blocks (const char *iscsiadm_path,
+                  GSList **out_blocks,
+                  GError **error)
+{
+	const char *argv[4] = { iscsiadm_path, "-m", "fw", NULL };
+	const char *envp[1] = { NULL };
+	GSList *blocks = NULL;
+	char *out = NULL, *err = NULL;
+	gint status = 0;
+	char **lines = NULL, **iter;
+	GPtrArray *block_lines = NULL;
+	gboolean success = FALSE;
+
+	g_return_val_if_fail (iscsiadm_path != NULL, FALSE);
+	g_return_val_if_fail (out_blocks != NULL && *out_blocks == NULL, FALSE);
+
+	if (!g_spawn_sync ("/", (char **) argv, (char **) envp, 0,
+	                   NULL, NULL, &out, &err, &status, error))
+		goto done;
+
+	if (!WIFEXITED (status)) {
+		g_set_error (error, IBFT_PLUGIN_ERROR, 0,
+		             "iBFT: %s exited abnormally.", iscsiadm_path);
+		goto done;
+	}
+
+	if (WEXITSTATUS (status) != 0) {
+		if (err) {
+			char *nl;
+
+			/* the error message contains newlines. concatenate the lines with whitespace */
+			for (nl = err; *nl; nl++) {
+				if (*nl == '\n')
+					*nl = ' ';
+			}
+		}
+		g_set_error (error, IBFT_PLUGIN_ERROR, 0,
+		             "iBFT: %s exited with error %d.  Message: '%s'",
+		             iscsiadm_path, WEXITSTATUS (status), err ? err : "(none)");
+		goto done;
+	}
+
+	IBFT_DEBUG ("iBFT records:\n%s", out);
+
+	lines = g_strsplit_set (out, "\n\r", -1);
+	for (iter = lines; iter && *iter; iter++) {
+		if (!*iter[0])
+			continue;
+
+		if (!g_ascii_strncasecmp (*iter, TAG_BEGIN, strlen (TAG_BEGIN))) {
+			if (block_lines) {
+				IBFT_WARN ("malformed iscsiadm record: missing END RECORD.");
+				g_ptr_array_unref (block_lines);
+			}
+			/* Start new record */
+			block_lines = g_ptr_array_new_with_free_func (g_free);
+		} else if (!g_ascii_strncasecmp (*iter, TAG_END, strlen (TAG_END))) {
+			if (block_lines) {
+				if (block_lines->len)
+					blocks = g_slist_prepend (blocks, block_lines);
+				else
+					g_ptr_array_unref (block_lines);
+				block_lines = NULL;
+			}
+		} else if (block_lines) {
+			char *s = remove_most_whitespace (*iter);
+
+			if (s)
+				g_ptr_array_add (block_lines, s);
+			else {
+				IBFT_WARN ("malformed iscsiadm record: no = in '%s'.", *iter);
+				if (block_lines) {
+					g_ptr_array_unref (block_lines);
+					block_lines = NULL;
+				}
+			}
+		}
+	}
+
+	if (block_lines) {
+		IBFT_WARN ("malformed iscsiadm record: missing # END RECORD.");
+		g_ptr_array_unref (block_lines);
+		block_lines = NULL;
+	}
+	success = TRUE;
+
+done:
+	if (lines)
+		g_strfreev (lines);
+	g_free (out);
+	g_free (err);
+	if (success)
+		*out_blocks = blocks;
+	else
+		g_slist_free_full (blocks, (GDestroyNotify) g_ptr_array_unref);
+	return success;
+}
+
+#define ISCSI_HWADDR_TAG     "iface.hwaddress"
+#define ISCSI_BOOTPROTO_TAG  "iface.bootproto"
+#define ISCSI_IPADDR_TAG     "iface.ipaddress"
+#define ISCSI_SUBNET_TAG     "iface.subnet_mask"
+#define ISCSI_GATEWAY_TAG    "iface.gateway"
+#define ISCSI_DNS1_TAG       "iface.primary_dns"
+#define ISCSI_DNS2_TAG       "iface.secondary_dns"
+#define ISCSI_VLAN_ID_TAG    "iface.vlan_id"
+#define ISCSI_IFACE_TAG      "iface.net_ifacename"
+
+static const char *
+match_iscsiadm_tag (const char *line, const char *tag)
+{
+	gsize taglen = strlen (tag);
+
+	if (g_ascii_strncasecmp (line, tag, taglen) != 0)
+		return NULL;
+	if (line[taglen] != '=')
+		return NULL;
+	return line + taglen + 1;
+}
+
+/**
+ * parse_ibft_config:
+ * @data: an array of iscsiadm interface block lines
+ * @error: return location for errors
+ * @...: pairs of key (const char *) : location (const char **) indicating the
+ * key to look for and the location to store the retrieved value in
+ *
+ * Parses an iscsiadm interface block into variables requested by the caller.
+ * Callers should verify the returned data is complete and valid.  Returned
+ * strings are owned by @data and should not be used after @data is freed.
+ *
+ * Returns: %TRUE if at least , %FALSE on failure
+ */
+gboolean
+parse_ibft_config (const GPtrArray *data, GError **error, ...)
+{
+	gboolean success = FALSE;
+	const char **out_value, *p;
+	va_list ap;
+	const char *key;
+	guint i;
+
+	g_return_val_if_fail (data != NULL, FALSE);
+	g_return_val_if_fail (data->len > 0, FALSE);
+
+	/* Find requested keys and populate return values */
+	va_start (ap, error);
+	while ((key = va_arg (ap, const char *))) {
+		out_value = va_arg (ap, const char **);
+		*out_value = NULL;
+		for (i = 0; i < data->len; i++) {
+			p = match_iscsiadm_tag (g_ptr_array_index (data, i), key);
+			if (p) {
+				*out_value = p;
+				success = TRUE;
+				break;
+			}
+		}
+	}
+	va_end (ap);
+
+	if (!success) {
+		g_set_error_literal (error, IBFT_PLUGIN_ERROR, 0,
+		                     "iBFT: failed to match at least one iscsiadm block field");
+	}
+	return success;
+}
+
+static gboolean
+ip4_setting_add_from_block (const GPtrArray *block,
+                            NMConnection *connection,
+                            GError **error)
+{
+	NMSettingIP4Config *s_ip4 = NULL;
+	NMIP4Address *addr;
+	const char *s_method = NULL;
+	const char *s_ipaddr = NULL;
+	const char *s_gateway = NULL;
+	const char *s_dns1 = NULL;
+	const char *s_dns2 = NULL;
+	const char *s_netmask = NULL;
+	guint32 ipaddr = 0;
+	guint32 gateway = 0;
+	guint32 dns1 = 0;
+	guint32 dns2 = 0;
+	guint32 netmask = 0;
+	guint32 prefix;
+
+	g_assert (block);
+
+	if (!parse_ibft_config (block, error,
+	                        ISCSI_BOOTPROTO_TAG, &s_method,
+	                        ISCSI_IPADDR_TAG,    &s_ipaddr,
+	                        ISCSI_SUBNET_TAG,    &s_netmask,
+	                        ISCSI_GATEWAY_TAG,   &s_gateway,
+	                        ISCSI_DNS1_TAG,      &s_dns1,
+	                        ISCSI_DNS2_TAG,      &s_dns2,
+	                        NULL))
+		goto error;
+
+	if (!s_method) {
+		g_set_error_literal (error, IBFT_PLUGIN_ERROR, 0,
+		                     "iBFT: malformed iscsiadm record: missing " ISCSI_BOOTPROTO_TAG);
+		goto error;
+	}
+
+	s_ip4 = (NMSettingIP4Config *) nm_setting_ip4_config_new ();
+
+	if (!g_ascii_strcasecmp (s_method, "dhcp")) {
+		g_object_set (s_ip4, NM_SETTING_IP4_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
+		goto success;
+	} else if (g_ascii_strcasecmp (s_method, "static") != 0) {
+		g_set_error (error, IBFT_PLUGIN_ERROR, 0,
+		             "iBFT: malformed iscsiadm record: unknown " ISCSI_BOOTPROTO_TAG " '%s'.",
+		             s_method);
+		goto error;
+	}
+
+	/* Static configuration stuff */
+	g_object_set (s_ip4, NM_SETTING_IP4_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL, NULL);
+
+	/* IP address */
+	if (!s_ipaddr || inet_pton (AF_INET, s_ipaddr, &ipaddr) != 1) {
+		g_set_error (error, IBFT_PLUGIN_ERROR, 0,
+		             "iBFT: malformed iscsiadm record: invalid IP address '%s'.",
+		             s_ipaddr);
+		goto error;
+	}
+
+	/* Subnet/prefix */
+	if (!s_netmask || inet_pton (AF_INET, s_netmask, &netmask) != 1) {
+		g_set_error (error, IBFT_PLUGIN_ERROR, 0,
+		             "iBFT: malformed iscsiadm record: invalid subnet mask '%s'.",
+		             s_netmask);
+		goto error;
+	}
+	prefix = nm_utils_ip4_netmask_to_prefix (netmask);
+
+	if (s_gateway && inet_pton (AF_INET, s_gateway, &gateway) != 1) {
+		g_set_error (error, IBFT_PLUGIN_ERROR, 0,
+		             "iBFT: malformed iscsiadm record: invalid IP gateway '%s'.",
+		             s_gateway);
+		goto error;
+	}
+
+	if (s_dns1 && inet_pton (AF_INET, s_dns1, &dns1) != 1) {
+		g_set_error (error, IBFT_PLUGIN_ERROR, 0,
+		             "iBFT: malformed iscsiadm record: invalid DNS1 address '%s'.",
+		             s_dns1);
+		goto error;
+	}
+
+	if (s_dns2 && inet_pton (AF_INET, s_dns2, &dns2) != 1) {
+		g_set_error (error, IBFT_PLUGIN_ERROR, 0,
+		             "iBFT: malformed iscsiadm record: invalid DNS2 address '%s'.",
+		             s_dns2);
+		goto error;
+	}
+
+	addr = nm_ip4_address_new ();
+	g_assert (addr);
+	nm_ip4_address_set_address (addr, ipaddr);
+	nm_ip4_address_set_prefix (addr, prefix);
+	nm_ip4_address_set_gateway (addr, gateway);
+	nm_setting_ip4_config_add_address (s_ip4, addr);
+	nm_ip4_address_unref (addr);
+
+	if (dns1)
+		nm_setting_ip4_config_add_dns (s_ip4, dns1);
+	if (dns2)
+		nm_setting_ip4_config_add_dns (s_ip4, dns2);
+
+success:
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+	return TRUE;
+
+error:
+	g_clear_object (&s_ip4);
+	return FALSE;
+}
+
+static gboolean
+connection_setting_add (const GPtrArray *block,
+                        NMConnection *connection,
+                        const char *type,
+                        const char *prefix,
+                        const char *iface,
+                        GError **error)
+{
+	NMSetting *s_con;
+	char *id, *uuid, *tmp;
+	const char *s_hwaddr = NULL, *s_ip4addr = NULL, *s_vlanid;
+
+	if (!parse_ibft_config (block, error,
+	                        ISCSI_VLAN_ID_TAG, &s_vlanid,
+	                        ISCSI_HWADDR_TAG,  &s_hwaddr,
+	                        ISCSI_IPADDR_TAG,  &s_ip4addr,
+	                        NULL))
+		return FALSE;
+	if (!s_hwaddr) {
+		g_set_error_literal (error, IBFT_PLUGIN_ERROR, 0,
+		                     "iBFT: malformed iscsiadm record: missing " ISCSI_HWADDR_TAG);
+		return FALSE;
+	}
+
+	id = g_strdup_printf ("iBFT%s%s %s",
+	                      prefix ? " " : "",
+	                      prefix ? prefix : "",
+	                      iface);
+
+	tmp = g_strdup_printf ("ibft%s%s%s%s%s",
+	                       s_hwaddr,
+	                       s_vlanid ? "V" : "v",
+	                       s_vlanid ? s_vlanid : "",
+	                       s_ip4addr ? "A" : "DHCP",
+	                       s_ip4addr ? s_ip4addr : "");
+	uuid = nm_utils_uuid_generate_from_string (tmp);
+	g_free (tmp);
+
+	s_con = nm_setting_connection_new ();
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_TYPE, type,
+	              NM_SETTING_CONNECTION_UUID, uuid,
+	              NM_SETTING_CONNECTION_ID, id,
+	              NM_SETTING_CONNECTION_READ_ONLY, TRUE,
+	              NULL);
+
+	g_free (uuid);
+	g_free (id);
+
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+	return TRUE;
+}
+
+static gboolean
+is_ibft_vlan_device (const GPtrArray *block)
+{
+	char *s_vlan_id = NULL;
+
+	if (parse_ibft_config (block, NULL, ISCSI_VLAN_ID_TAG, &s_vlan_id, NULL)) {
+		long int vlan_id;
+
+		g_assert (s_vlan_id);
+
+		/* VLAN 0 is normally a valid VLAN ID, but in the iBFT case it
+		 * means "no VLAN".
+		 */
+		errno = 0;
+		vlan_id = strtol (s_vlan_id, NULL, 10);
+		if (errno == 0 && vlan_id >= 1 && vlan_id <= 4095)
+			return TRUE;
+	}
+	return FALSE;
+}
+
+static gboolean
+vlan_setting_add_from_block (const GPtrArray *block,
+                             NMConnection *connection,
+                             GError **error)
+{
+	NMSetting *s_vlan = NULL;
+	const char *vlan_id_str = NULL;
+	long int vlan_id = -1;
+	gboolean success;
+
+	g_assert (block);
+	g_assert (connection);
+
+	/* This won't fail since this function shouldn't be called unless the
+	 * iBFT VLAN ID exists and is > 0.
+	 */
+	success = parse_ibft_config (block, NULL, ISCSI_VLAN_ID_TAG, &vlan_id_str, NULL);
+	g_assert (success);
+	g_assert (vlan_id_str);
+
+	/* VLAN 0 is normally a valid VLAN ID, but in the iBFT case it means "no VLAN" */
+	errno = 0;
+	vlan_id = strtol (vlan_id_str, NULL, 10);
+	if (errno || vlan_id < 1 || vlan_id > 4095) {
+		g_set_error (error, IBFT_PLUGIN_ERROR, 0,
+		             "Invalid VLAN_ID '%s'", vlan_id_str);
+		return FALSE;
+	}
+
+	s_vlan = nm_setting_vlan_new ();
+	g_object_set (s_vlan, NM_SETTING_VLAN_ID, (guint32) vlan_id, NULL);
+	nm_connection_add_setting (connection, NM_SETTING (s_vlan));
+
+	return TRUE;
+}
+
+static gboolean
+wired_setting_add_from_block (const GPtrArray *block,
+                              NMConnection *connection,
+                              GError **error)
+{
+	NMSetting *s_wired = NULL;
+	const char *hwaddr = NULL;
+	GByteArray *mac;
+
+	g_assert (block);
+	g_assert (connection);
+
+	if (!parse_ibft_config (block, NULL, ISCSI_HWADDR_TAG, &hwaddr, NULL)) {
+		g_set_error_literal (error, IBFT_PLUGIN_ERROR, 0,
+		                     "iBFT: malformed iscsiadm record: missing " ISCSI_HWADDR_TAG);
+		return FALSE;
+	}
+
+	mac = nm_utils_hwaddr_atoba (hwaddr, ARPHRD_ETHER);
+	if (!mac) {
+		g_set_error (error, IBFT_PLUGIN_ERROR, 0,
+		             "iBFT: malformed iscsiadm record: invalid " ISCSI_HWADDR_TAG " '%s'.",
+		             hwaddr);
+		return FALSE;
+	}
+
+	s_wired = nm_setting_wired_new ();
+	g_object_set (s_wired, NM_SETTING_WIRED_MAC_ADDRESS, mac, NULL);
+	g_byte_array_unref (mac);
+
+	nm_connection_add_setting (connection, s_wired);
+	return TRUE;
+}
+
+NMConnection *
+connection_from_block (const GPtrArray *block, GError **error)
+{
+	NMConnection *connection = NULL;
+	gboolean is_vlan = FALSE;
+	const char *iface = NULL;
+
+	g_assert (block);
+
+	if (!parse_ibft_config (block, error, ISCSI_IFACE_TAG, &iface, NULL)) {
+		g_set_error_literal (error, IBFT_PLUGIN_ERROR, 0,
+		                     "iBFT: malformed iscsiadm record: missing " ISCSI_IFACE_TAG);
+		return NULL;
+	}
+
+	connection = nm_connection_new ();
+
+	is_vlan = is_ibft_vlan_device (block);
+	if (is_vlan && !vlan_setting_add_from_block (block, connection, error))
+		goto error;
+
+	/* Always have a wired setting; for VLAN it defines the parent */
+	if (!wired_setting_add_from_block (block, connection, error))
+		goto error;
+
+	if (!ip4_setting_add_from_block (block, connection, error))
+		goto error;
+
+	if (!connection_setting_add (block,
+	                             connection,
+	                             is_vlan ? NM_SETTING_VLAN_SETTING_NAME : NM_SETTING_WIRED_SETTING_NAME,
+	                             is_vlan ? "VLAN" : NULL,
+	                             iface,
+	                             error))
+		goto error;
+
+	if (!nm_connection_verify (connection, error))
+		goto error;
+
+	return connection;
+
+error:
+	g_object_unref (connection);
+	return NULL;
+}
+
diff --git a/system-settings/plugins/ibft/reader.h b/system-settings/plugins/ibft/reader.h
new file mode 100644
index 0000000..0b2f22b
--- /dev/null
+++ b/system-settings/plugins/ibft/reader.h
@@ -0,0 +1,36 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager system settings service
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2014 Red Hat, Inc.
+ */
+
+#ifndef __READER_H__
+#define __READER_H__
+
+#include <glib.h>
+#include <nm-connection.h>
+
+gboolean read_ibft_blocks (const char *iscsiadm_path,
+                           GSList **out_blocks,
+                           GError **error);
+
+NMConnection *connection_from_block (const GPtrArray *block, GError **error);
+
+/* For testcases */
+gboolean parse_ibft_config (const GPtrArray *data, GError **error, ...) G_GNUC_NULL_TERMINATED;
+
+#endif  /* __READER_H__ */
diff --git a/system-settings/plugins/ibft/tests/Makefile.am b/system-settings/plugins/ibft/tests/Makefile.am
new file mode 100644
index 0000000..7c15ae0
--- /dev/null
+++ b/system-settings/plugins/ibft/tests/Makefile.am
@@ -0,0 +1,43 @@
+AM_CPPFLAGS = \
+	$(GLIB_CFLAGS) \
+	$(DBUS_CFLAGS) \
+	-I$(top_srcdir)/include \
+	-I$(top_srcdir)/libnm-util \
+	-I$(top_srcdir)/system-settings/plugins/ibft \
+	-DG_LOG_DOMAIN=\""NetworkManager-ibft"\" \
+	-DTEST_IBFT_DIR=\"$(abs_srcdir)\" \
+	-DTEST_SCRATCH_DIR=\"$(abs_builddir)/\"
+
+AM_LDFLAGS = \
+	$(GLIB_LIBS) \
+	$(DBUS_LIBS)
+
+noinst_PROGRAMS = test-ibft
+
+test_ibft_SOURCES = \
+	test-ibft.c \
+	../reader.c \
+	../errors.c \
+	../common.h
+
+test_ibft_LDADD = \
+	$(top_builddir)/libnm-util/libnm-util.la
+
+if WITH_TESTS
+
+check-local: test-ibft
+	$(abs_builddir)/test-ibft
+
+endif
+
+EXTRA_DIST = \
+	iscsiadm-test-dhcp \
+	iscsiadm-test-static \
+	iscsiadm-test-bad-ipaddr \
+	iscsiadm-test-bad-gateway \
+	iscsiadm-test-bad-dns1 \
+	iscsiadm-test-bad-dns2 \
+	iscsiadm-test-bad-entry \
+	iscsiadm-test-bad-record \
+	iscsiadm-test-vlan
+
diff --git a/system-settings/plugins/ibft/tests/iscsiadm-test-bad-dns1 b/system-settings/plugins/ibft/tests/iscsiadm-test-bad-dns1
new file mode 100755
index 0000000..54f02da
--- /dev/null
+++ b/system-settings/plugins/ibft/tests/iscsiadm-test-bad-dns1
@@ -0,0 +1,21 @@
+#!/bin/bash
+
+cat << EOF
+# BEGIN RECORD
+iface.initiatorname = iqn.pjones6
+iface.hwaddress = 00:33:21:98:b9:f0
+iface.bootproto = STATIC
+iface.ipaddress = 192.168.32.72
+iface.subnet_mask = 255.255.252.0
+iface.gateway = 192.168.35.254
+iface.primary_dns = 10000.500.250.1
+iface.secondary_dns = 10.16.255.3
+iface.vlan_id = 0
+iface.net_ifacename = eth0
+node.name = iqn.0.2008-11.com.blahblah:iscsi0
+node.conn[0].address = 10.16.52.16
+node.conn[0].port = 3260
+node.boot_lun = 00000000
+# END RECORD
+EOF
+
diff --git a/system-settings/plugins/ibft/tests/iscsiadm-test-bad-dns2 b/system-settings/plugins/ibft/tests/iscsiadm-test-bad-dns2
new file mode 100755
index 0000000..ebd7a9c
--- /dev/null
+++ b/system-settings/plugins/ibft/tests/iscsiadm-test-bad-dns2
@@ -0,0 +1,21 @@
+#!/bin/bash
+
+cat << EOF
+# BEGIN RECORD
+iface.initiatorname = iqn.pjones6
+iface.hwaddress = 00:33:21:98:b9:f0
+iface.bootproto = STATIC
+iface.ipaddress = 192.168.32.72
+iface.subnet_mask = 255.255.252.0
+iface.gateway = 192.168.35.254
+iface.primary_dns = 10.16.255.2
+iface.secondary_dns = blah.foo.bar.baz
+iface.vlan_id = 0
+iface.net_ifacename = eth0
+node.name = iqn.0.2008-11.com.blahblah:iscsi0
+node.conn[0].address = 10.16.52.16
+node.conn[0].port = 3260
+node.boot_lun = 00000000
+# END RECORD
+EOF
+
diff --git a/system-settings/plugins/ibft/tests/iscsiadm-test-bad-entry b/system-settings/plugins/ibft/tests/iscsiadm-test-bad-entry
new file mode 100755
index 0000000..4e32604
--- /dev/null
+++ b/system-settings/plugins/ibft/tests/iscsiadm-test-bad-entry
@@ -0,0 +1,20 @@
+#!/bin/bash
+
+cat << EOF
+# BEGIN RECORD
+iface.initiatorname = iqn.pjones6
+iface.hwaddress = 00:33:21:98:b9:f0
+iface.bootproto = STATIC
+iface.ipaddress 192.168.32.72
+iface.subnet_mask = 255.255.252.0
+iface.gateway = 192.168.35.254
+iface.primary_dns = 10.16.255.2
+iface.secondary_dns = 10.16.255.3
+iface.vlan_id = 0
+iface.net_ifacename = eth0
+node.name = iqn.0.2008-11.com.blahblah:iscsi0
+node.conn[0].address = 10.16.52.16
+node.conn[0].port = 3260
+node.boot_lun = 00000000
+# END RECORD
+
diff --git a/system-settings/plugins/ibft/tests/iscsiadm-test-bad-gateway b/system-settings/plugins/ibft/tests/iscsiadm-test-bad-gateway
new file mode 100755
index 0000000..5390a6c
--- /dev/null
+++ b/system-settings/plugins/ibft/tests/iscsiadm-test-bad-gateway
@@ -0,0 +1,21 @@
+#!/bin/bash
+
+cat << EOF
+# BEGIN RECORD
+iface.initiatorname = iqn.pjones6
+iface.hwaddress = 00:33:21:98:b9:f0
+iface.bootproto = STATIC
+iface.ipaddress = 192.168.32.72
+iface.subnet_mask = 255.255.252.0
+iface.gateway = bb.cc.dd.ee
+iface.primary_dns = 10.16.255.2
+iface.secondary_dns = 10.16.255.3
+iface.vlan_id = 0
+iface.net_ifacename = eth0
+node.name = iqn.0.2008-11.com.blahblah:iscsi0
+node.conn[0].address = 10.16.52.16
+node.conn[0].port = 3260
+node.boot_lun = 00000000
+# END RECORD
+EOF
+
diff --git a/system-settings/plugins/ibft/tests/iscsiadm-test-bad-ipaddr b/system-settings/plugins/ibft/tests/iscsiadm-test-bad-ipaddr
new file mode 100755
index 0000000..b41cd1f
--- /dev/null
+++ b/system-settings/plugins/ibft/tests/iscsiadm-test-bad-ipaddr
@@ -0,0 +1,21 @@
+#!/bin/bash
+
+cat << EOF
+# BEGIN RECORD
+iface.initiatorname = iqn.pjones6
+iface.hwaddress = 00:33:21:98:b9:f0
+iface.bootproto = STATIC
+iface.ipaddress = aa.bb.cc.dd
+iface.subnet_mask = 255.255.252.0
+iface.gateway = 192.168.35.254
+iface.primary_dns = 10.16.255.2
+iface.secondary_dns = 10.16.255.3
+iface.vlan_id = 0
+iface.net_ifacename = eth0
+node.name = iqn.0.2008-11.com.blahblah:iscsi0
+node.conn[0].address = 10.16.52.16
+node.conn[0].port = 3260
+node.boot_lun = 00000000
+# END RECORD
+EOF
+
diff --git a/system-settings/plugins/ibft/tests/iscsiadm-test-bad-record b/system-settings/plugins/ibft/tests/iscsiadm-test-bad-record
new file mode 100755
index 0000000..22b34e6
--- /dev/null
+++ b/system-settings/plugins/ibft/tests/iscsiadm-test-bad-record
@@ -0,0 +1,18 @@
+#!/bin/bash
+
+cat << EOF
+# BEGIN RECORD
+iface.initiatorname = iqn.pjones6
+iface.hwaddress = 00:33:21:98:b9:f0
+iface.bootproto = DHCP
+iface.gateway = 10.16.52.254
+iface.primary_dns = 10.16.255.2
+iface.secondary_dns = 10.16.255.3
+iface.vlan_id = 0
+iface.net_ifacename = eth0
+node.name = iqn.0.2008-11.com.blahblah:iscsi0
+node.conn[0].address = 10.16.52.16
+node.conn[0].port = 3260
+node.boot_lun = 00000000
+EOF
+
diff --git a/system-settings/plugins/ibft/tests/iscsiadm-test-dhcp b/system-settings/plugins/ibft/tests/iscsiadm-test-dhcp
new file mode 100755
index 0000000..556b058
--- /dev/null
+++ b/system-settings/plugins/ibft/tests/iscsiadm-test-dhcp
@@ -0,0 +1,33 @@
+#!/bin/bash
+
+cat << EOF
+# BEGIN RECORD
+iface.initiatorname = iqn.pjones6
+iface.hwaddress = 00:33:21:98:b9:f0
+iface.bootproto = DHCP
+iface.gateway = 10.16.52.254
+iface.primary_dns = 10.16.255.2
+iface.secondary_dns = 10.16.255.3
+iface.vlan_id = 0
+iface.net_ifacename = eth0
+node.name = iqn.0.2008-11.com.blahblah:iscsi0
+node.conn[0].address = 10.16.52.16
+node.conn[0].port = 3260
+node.boot_lun = 00000000
+# END RECORD
+# BEGIN RECORD
+iface.initiatorname = iqn.pjones6
+iface.hwaddress = 00:33:21:98:b9:f1
+iface.bootproto = DHCP
+iface.gateway = 10.16.52.254
+iface.primary_dns = 10.16.255.2
+iface.secondary_dns = 10.16.255.3
+iface.vlan_id = 0
+iface.net_ifacename = eth1
+node.name = iqn.1.2008-11.com.blahblah:iscsi1
+node.conn[0].address = 10.16.52.16
+node.conn[0].port = 3260
+node.boot_lun = 00000000
+# END RECORD
+EOF
+
diff --git a/system-settings/plugins/ibft/tests/iscsiadm-test-static b/system-settings/plugins/ibft/tests/iscsiadm-test-static
new file mode 100755
index 0000000..5171148
--- /dev/null
+++ b/system-settings/plugins/ibft/tests/iscsiadm-test-static
@@ -0,0 +1,35 @@
+#!/bin/bash
+
+cat << EOF
+# BEGIN RECORD
+iface.initiatorname = iqn.pjones6
+iface.hwaddress = 00:33:21:98:b9:f0
+iface.bootproto = STATIC
+iface.ipaddress = 192.168.32.72
+iface.subnet_mask = 255.255.252.0
+iface.gateway = 192.168.35.254
+iface.primary_dns = 10.16.255.2
+iface.secondary_dns = 10.16.255.3
+iface.vlan_id = 0
+iface.net_ifacename = eth0
+node.name = iqn.0.2008-11.com.blahblah:iscsi0
+node.conn[0].address = 10.16.52.16
+node.conn[0].port = 3260
+node.boot_lun = 00000000
+# END RECORD
+# BEGIN RECORD
+iface.initiatorname = iqn.pjones6
+iface.hwaddress = 00:33:21:98:b9:f1
+iface.bootproto = DHCP
+iface.gateway = 10.16.52.254
+iface.primary_dns = 10.16.255.2
+iface.secondary_dns = 10.16.255.3
+iface.vlan_id = 0
+iface.net_ifacename = eth1
+node.name = iqn.1.2008-11.com.blahblah:iscsi1
+node.conn[0].address = 10.16.52.16
+node.conn[0].port = 3260
+node.boot_lun = 00000000
+# END RECORD
+EOF
+
diff --git a/system-settings/plugins/ibft/tests/iscsiadm-test-vlan b/system-settings/plugins/ibft/tests/iscsiadm-test-vlan
new file mode 100755
index 0000000..59b80bd
--- /dev/null
+++ b/system-settings/plugins/ibft/tests/iscsiadm-test-vlan
@@ -0,0 +1,19 @@
+#!/bin/bash
+
+cat << EOF
+# BEGIN RECORD 6.2.0.873-21
+iface.initiatorname = iqn.2010-04.org.ipxe:d05faa97-c4be-44f6-a723-efde9aa399a0
+iface.transport_name = tcp
+iface.hwaddress = 00:33:21:98:b9:f0
+iface.bootproto = STATIC
+iface.ipaddress = 192.168.6.200
+iface.subnet_mask = 255.255.255.0
+iface.vlan_id = 123
+iface.net_ifacename = eth0
+node.name = iqn.2003-01.org.x:disk1
+node.conn[0].address = 192.168.6.32
+node.conn[0].port = 3260
+node.boot_lun = 01000000
+# END RECORD
+EOF
+
diff --git a/system-settings/plugins/ibft/tests/test-ibft.c b/system-settings/plugins/ibft/tests/test-ibft.c
new file mode 100644
index 0000000..d1f5e63
--- /dev/null
+++ b/system-settings/plugins/ibft/tests/test-ibft.c
@@ -0,0 +1,326 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager system settings service
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2014 Red Hat, Inc.
+ */
+
+#include "config.h"
+
+#include <stdio.h>
+#include <stdarg.h>
+#include <unistd.h>
+#include <string.h>
+#include <netinet/ether.h>
+#include <netinet/in.h>
+#include <arpa/inet.h>
+#include <sys/socket.h>
+
+#include "common.h"
+#include "reader.h"
+#include <nm-utils.h>
+
+static GPtrArray *
+read_block (const char *iscsiadm_path, const char *expected_mac)
+{
+	GSList *blocks = NULL, *iter;
+	GPtrArray *block = NULL;
+	GError *error = NULL;
+	gboolean success;
+	GByteArray *e_mac, *f_mac;
+
+	e_mac = nm_utils_hwaddr_atoba (expected_mac, ARPHRD_ETHER);
+	g_assert (e_mac);
+
+	success = read_ibft_blocks (iscsiadm_path, &blocks, &error);
+	g_assert_no_error (error);
+	g_assert (success);
+	g_assert (blocks);
+
+	for (iter = blocks; iter; iter = iter->next) {
+		const char *s_hwaddr = NULL;
+		gboolean found;
+
+		if (!parse_ibft_config (iter->data, NULL, "iface.hwaddress", &s_hwaddr, NULL))
+			continue;
+		g_assert (s_hwaddr);
+
+		f_mac = nm_utils_hwaddr_atoba (s_hwaddr, ARPHRD_ETHER);
+		g_assert (f_mac);
+
+		found = (e_mac->len == f_mac->len && memcmp (e_mac->data, f_mac->data, e_mac->len) == 0);
+		g_byte_array_unref (f_mac);
+		if (found) {
+			block = g_ptr_array_ref (iter->data);
+			break;
+		}
+	}
+	g_assert (block);
+
+	g_slist_free_full (blocks, (GDestroyNotify) g_ptr_array_unref);
+	g_byte_array_unref (e_mac);
+	return block;
+}
+
+static void
+test_read_ibft_dhcp (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIP4Config *s_ip4;
+	GError *error = NULL;
+	const GByteArray *mac_address;
+	GByteArray *tmp;
+	const char *expected_mac_address = "00:33:21:98:b9:f1";
+	GPtrArray *block;
+
+	block = read_block (TEST_IBFT_DIR "/iscsiadm-test-dhcp", expected_mac_address);
+
+	connection = connection_from_block (block, &error);
+	g_assert_no_error (error);
+
+	g_assert (!nm_connection_get_setting_vlan (connection));
+
+	/* ===== CONNECTION SETTING ===== */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_WIRED_SETTING_NAME);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "iBFT eth1");
+	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, 0);
+	g_assert (nm_setting_connection_get_autoconnect (s_con));
+	g_assert (nm_setting_connection_get_read_only (s_con));
+
+	/* ===== WIRED SETTING ===== */
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+	mac_address = nm_setting_wired_get_mac_address (s_wired);
+	g_assert (mac_address);
+	tmp = nm_utils_hwaddr_atoba (expected_mac_address, ARPHRD_ETHER);
+	g_assert (tmp);
+	g_assert_cmpint (tmp->len, ==, ETH_ALEN);
+	g_assert_cmpint (mac_address->len, ==, tmp->len);
+	g_assert (memcmp (mac_address->data, tmp->data, mac_address->len) == 0);
+	g_byte_array_unref (tmp);
+
+	g_assert_cmpint (nm_setting_wired_get_mtu (s_wired), ==, 0);
+
+	/* ===== IPv4 SETTING ===== */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip4_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
+
+	g_object_unref (connection);
+	g_ptr_array_unref (block);
+}
+
+static void
+test_read_ibft_static (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIP4Config *s_ip4;
+	GError *error = NULL;
+	const GByteArray *mac_address;
+	GByteArray *tmp;
+	const char *expected_mac_address = "00:33:21:98:b9:f0";
+	NMIP4Address *ip4_addr;
+	GPtrArray *block;
+	struct in_addr n_addr;
+
+	block = read_block (TEST_IBFT_DIR "/iscsiadm-test-static", expected_mac_address);
+
+	connection = connection_from_block (block, &error);
+	g_assert_no_error (error);
+
+	g_assert (!nm_connection_get_setting_vlan (connection));
+
+	/* ===== CONNECTION SETTING ===== */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_WIRED_SETTING_NAME);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, "iBFT eth0");
+	g_assert_cmpint (nm_setting_connection_get_timestamp (s_con), ==, 0);
+	g_assert (nm_setting_connection_get_autoconnect (s_con));
+	g_assert (nm_setting_connection_get_read_only (s_con));
+
+	/* ===== WIRED SETTING ===== */
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+	mac_address = nm_setting_wired_get_mac_address (s_wired);
+	g_assert (mac_address);
+	tmp = nm_utils_hwaddr_atoba (expected_mac_address, ARPHRD_ETHER);
+	g_assert (tmp);
+	g_assert_cmpint (tmp->len, ==, ETH_ALEN);
+	g_assert_cmpint (mac_address->len, ==, tmp->len);
+	g_assert (memcmp (mac_address->data, tmp->data, mac_address->len) == 0);
+	g_byte_array_unref (tmp);
+	g_assert_cmpint (nm_setting_wired_get_mtu (s_wired), ==, 0);
+
+	/* ===== IPv4 SETTING ===== */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip4_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
+
+	g_assert_cmpint (nm_setting_ip4_config_get_num_dns (s_ip4), ==, 2);
+	g_assert (inet_pton (AF_INET, "10.16.255.2", &n_addr) > 0);
+	g_assert (nm_setting_ip4_config_get_dns (s_ip4, 0) == n_addr.s_addr);
+	g_assert (inet_pton (AF_INET, "10.16.255.3", &n_addr) > 0);
+	g_assert (nm_setting_ip4_config_get_dns (s_ip4, 1) == n_addr.s_addr);
+
+	g_assert_cmpint (nm_setting_ip4_config_get_num_addresses (s_ip4), ==, 1);
+	ip4_addr = nm_setting_ip4_config_get_address (s_ip4, 0);
+	g_assert (ip4_addr);
+	g_assert (inet_pton (AF_INET, "192.168.32.72", &n_addr) > 0);
+	g_assert (nm_ip4_address_get_address (ip4_addr) == n_addr.s_addr);
+	g_assert_cmpint (nm_ip4_address_get_prefix (ip4_addr), ==, 22);
+	g_assert (inet_pton (AF_INET, "192.168.35.254", &n_addr) > 0);
+	g_assert (nm_ip4_address_get_gateway (ip4_addr) == n_addr.s_addr);
+
+	g_object_unref (connection);
+	g_ptr_array_unref (block);
+}
+
+static void
+test_read_ibft_malformed (gconstpointer user_data)
+{
+	const char *iscsiadm_path = user_data;
+	GSList *blocks = NULL;
+	GError *error = NULL;
+	gboolean success;
+
+	g_assert (g_file_test (iscsiadm_path, G_FILE_TEST_EXISTS));
+
+	success = read_ibft_blocks (iscsiadm_path, &blocks, &error);
+	g_assert_no_error (error);
+	g_assert (success);
+	g_assert (blocks == NULL);
+}
+
+static void
+test_read_ibft_bad_address (gconstpointer user_data)
+{
+	const char *iscsiadm_path = user_data;
+	NMConnection *connection;
+	const char *expected_mac_address = "00:33:21:98:b9:f0";
+	GPtrArray *block;
+	GError *error = NULL;
+
+	g_assert (g_file_test (iscsiadm_path, G_FILE_TEST_EXISTS));
+
+	block = read_block (iscsiadm_path, expected_mac_address);
+
+	connection = connection_from_block (block, &error);
+	g_assert_error (error, IBFT_PLUGIN_ERROR, 0);
+	g_assert (strstr (error->message, "iBFT: malformed iscsiadm record: invalid"));
+	g_clear_error (&error);
+	g_assert (connection == NULL);
+
+	g_ptr_array_unref (block);
+}
+
+static void
+test_read_ibft_vlan (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingVlan *s_vlan;
+	NMSettingIP4Config *s_ip4;
+	const GByteArray *mac_address;
+	GByteArray *tmp;
+	const char *expected_mac_address = "00:33:21:98:b9:f0";
+	NMIP4Address *ip4_addr;
+	GError *error = NULL;
+	GPtrArray *block;
+	struct in_addr n_addr;
+
+	block = read_block (TEST_IBFT_DIR "/iscsiadm-test-vlan", expected_mac_address);
+
+	connection = connection_from_block (block, &error);
+	g_assert_no_error (error);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_connection_type (s_con), ==, NM_SETTING_VLAN_SETTING_NAME);
+
+	/* ===== WIRED SETTING ===== */
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+	mac_address = nm_setting_wired_get_mac_address (s_wired);
+	g_assert (mac_address);
+	tmp = nm_utils_hwaddr_atoba (expected_mac_address, ARPHRD_ETHER);
+	g_assert (tmp);
+	g_assert_cmpint (tmp->len, ==, ETH_ALEN);
+	g_assert_cmpint (mac_address->len, ==, tmp->len);
+	g_assert (memcmp (mac_address->data, tmp->data, mac_address->len) == 0);
+	g_byte_array_unref (tmp);
+
+	/* ===== VLAN SETTING ===== */
+	s_vlan = nm_connection_get_setting_vlan (connection);
+	g_assert (s_vlan);
+	g_assert_cmpint (nm_setting_vlan_get_id (s_vlan), ==, 123);
+	g_assert_cmpstr (nm_setting_vlan_get_parent (s_vlan), ==, NULL);
+
+	/* ===== IPv4 SETTING ===== */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip4_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_MANUAL);
+
+	g_assert_cmpint (nm_setting_ip4_config_get_num_dns (s_ip4), ==, 0);
+
+	g_assert_cmpint (nm_setting_ip4_config_get_num_addresses (s_ip4), ==, 1);
+	ip4_addr = nm_setting_ip4_config_get_address (s_ip4, 0);
+	g_assert (ip4_addr);
+	g_assert (inet_pton (AF_INET, "192.168.6.200", &n_addr) > 0);
+	g_assert (nm_ip4_address_get_address (ip4_addr) == n_addr.s_addr);
+	g_assert_cmpint (nm_ip4_address_get_prefix (ip4_addr), ==, 24);
+	g_assert (nm_ip4_address_get_gateway (ip4_addr) == 0);
+
+	g_object_unref (connection);
+	g_ptr_array_unref (block);
+}
+
+#define TPATH "/settings/plugins/ibft/"
+
+int main (int argc, char **argv)
+{
+	GError *error = NULL;
+	gboolean success;
+
+	g_type_init ();
+
+	success = nm_utils_init (&error);
+	g_assert_no_error (error);
+	g_assert (success);
+
+	g_test_init (&argc, &argv, NULL);
+	g_log_set_always_fatal (G_LOG_LEVEL_ERROR | G_LOG_LEVEL_CRITICAL);
+
+	g_test_add_func (TPATH "ibft/dhcp", test_read_ibft_dhcp);
+	g_test_add_func (TPATH "ibft/static", test_read_ibft_static);
+	g_test_add_func (TPATH "ibft/vlan", test_read_ibft_vlan);
+	g_test_add_data_func (TPATH "ibft/bad-record-read", TEST_IBFT_DIR "/iscsiadm-test-bad-record", test_read_ibft_malformed);
+	g_test_add_data_func (TPATH "ibft/bad-entry-read", TEST_IBFT_DIR "/iscsiadm-test-bad-entry", test_read_ibft_malformed);
+	g_test_add_data_func (TPATH "ibft/bad-ipaddr-read", TEST_IBFT_DIR "/iscsiadm-test-bad-ipaddr", test_read_ibft_bad_address);
+	g_test_add_data_func (TPATH "ibft/bad-gateway-read", TEST_IBFT_DIR "/iscsiadm-test-bad-gateway", test_read_ibft_bad_address);
+	g_test_add_data_func (TPATH "ibft/bad-dns1-read", TEST_IBFT_DIR "/iscsiadm-test-bad-dns1", test_read_ibft_bad_address);
+	g_test_add_data_func (TPATH "ibft/bad-dns2-read", TEST_IBFT_DIR "/iscsiadm-test-bad-dns2", test_read_ibft_bad_address);
+
+	return g_test_run ();
+}
+
diff --git a/system-settings/plugins/ifcfg-rh/reader.c b/system-settings/plugins/ifcfg-rh/reader.c
index d9e6970..384d797 100644
--- a/system-settings/plugins/ifcfg-rh/reader.c
+++ b/system-settings/plugins/ifcfg-rh/reader.c
@@ -290,252 +290,6 @@ read_mac_address (shvarFile *ifcfg, const char *key, int type,
 	return TRUE;
 }
 
-static void
-iscsiadm_child_setup (gpointer user_data G_GNUC_UNUSED)
-{
-	/* We are in the child process here; set a different process group to
-	 * ensure signal isolation between child and parent.
-	 */
-	pid_t pid = getpid ();
-	setpgid (pid, pid);
-}
-
-static char *
-match_iscsiadm_tag (const char *line, const char *tag, gboolean *skip)
-{
-	char *p;
-
-	if (g_ascii_strncasecmp (line, tag, strlen (tag)))
-		return NULL;
-
-	p = strchr (line, '=');
-	if (!p) {
-		g_warning ("%s: malformed iscsiadm record: no = in '%s'.",
-		           __func__, line);
-		*skip = TRUE;
-		return NULL;
-	}
-
-	p++; /* advance past = */
-	return g_strstrip (p);
-}
-
-#define ISCSI_HWADDR_TAG    "iface.hwaddress"
-#define ISCSI_BOOTPROTO_TAG "iface.bootproto"
-#define ISCSI_IPADDR_TAG    "iface.ipaddress"
-#define ISCSI_SUBNET_TAG    "iface.subnet_mask"
-#define ISCSI_GATEWAY_TAG   "iface.gateway"
-#define ISCSI_DNS1_TAG      "iface.primary_dns"
-#define ISCSI_DNS2_TAG      "iface.secondary_dns"
-
-static gboolean
-fill_ip4_setting_from_ibft (shvarFile *ifcfg,
-                            NMSettingIP4Config *s_ip4,
-                            const char *iscsiadm_path,
-                            GError **error)
-{
-	const char *argv[4] = { iscsiadm_path, "-m", "fw", NULL };
-	const char *envp[1] = { NULL };
-	gboolean success = FALSE, in_record = FALSE, hwaddr_matched = FALSE, skip = FALSE;
-	char *out = NULL, *err = NULL;
-	gint status = 0;
-	GByteArray *ifcfg_mac = NULL;
-	char **lines = NULL, **iter;
-	const char *method = NULL;
-	struct in_addr ipaddr;
-	struct in_addr gateway;
-	struct in_addr dns1;
-	struct in_addr dns2;
-	guint32 prefix = 0;
-
-	g_return_val_if_fail (s_ip4 != NULL, FALSE);
-	g_return_val_if_fail (iscsiadm_path != NULL, FALSE);
-
-	if (!g_spawn_sync ("/", (char **) argv, (char **) envp, 0,
-	                   iscsiadm_child_setup, NULL, &out, &err, &status, error))
-		return FALSE;
-
-	if (!WIFEXITED (status)) {
-		g_set_error (error, IFCFG_PLUGIN_ERROR, 0,
-		             "%s exited abnormally.", iscsiadm_path);
-		goto done;
-	}
-
-	if (WEXITSTATUS (status) != 0) {
-		g_set_error (error, IFCFG_PLUGIN_ERROR, 0,
-		             "%s exited with error %d.  Message: '%s'",
-		             iscsiadm_path, WEXITSTATUS (status), err ? err : "(none)");
-		goto done;
-	}
-
-	if (!read_mac_address (ifcfg, "HWADDR", ARPHRD_ETHER, &ifcfg_mac, error))
-		goto done;
-	/* Ensure we got a MAC */
-	if (!ifcfg_mac) {
-		g_set_error (error, IFCFG_PLUGIN_ERROR, 0,
-		             "Missing device MAC address (no HWADDR tag present).");
-		goto done;
-	}
-
-	memset (&ipaddr, 0, sizeof (ipaddr));
-	memset (&gateway, 0, sizeof (gateway));
-	memset (&dns1, 0, sizeof (dns1));
-	memset (&dns2, 0, sizeof (dns2));
-
-	/* Success, lets parse the output */
-	lines = g_strsplit_set (out, "\n\r", -1);
-	for (iter = lines; iter && *iter; iter++) {
-		char *p;
-
-		if (!g_ascii_strcasecmp (*iter, "# BEGIN RECORD")) {
-			if (in_record) {
-				g_warning ("%s: malformed iscsiadm record: already parsing record.", __func__);
-				skip = TRUE;
-			}
-		} else if (!g_ascii_strcasecmp (*iter, "# END RECORD")) {
-			if (!skip && hwaddr_matched) {
-				/* Record is good; fill IP4 config with its info */
-				if (!method) {
-					g_warning ("%s: malformed iscsiadm record: missing BOOTPROTO.", __func__);
-					return FALSE;
-				}
-
-				g_object_set (s_ip4, NM_SETTING_IP4_CONFIG_METHOD, method, NULL);
-
-				if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_MANUAL)) {
-					NMIP4Address *addr;
-
-				    if (!ipaddr.s_addr || !prefix) {
-						g_warning ("%s: malformed iscsiadm record: BOOTPROTO=static "
-						           "but missing IP address or prefix.", __func__);
-						return FALSE;
-					}
-
-					addr = nm_ip4_address_new ();
-					nm_ip4_address_set_address (addr, ipaddr.s_addr);
-					nm_ip4_address_set_prefix (addr, prefix);
-					nm_ip4_address_set_gateway (addr, gateway.s_addr);
-					nm_setting_ip4_config_add_address (s_ip4, addr);
-					nm_ip4_address_unref (addr);
-
-					if (dns1.s_addr)
-						nm_setting_ip4_config_add_dns (s_ip4, dns1.s_addr);
-					if (dns2.s_addr)
-						nm_setting_ip4_config_add_dns (s_ip4, dns2.s_addr);
-
-					// FIXME: DNS search domains?
-				}
-				return TRUE;
-			}
-			skip = FALSE;
-			hwaddr_matched = FALSE;
-			memset (&ipaddr, 0, sizeof (ipaddr));
-			memset (&gateway, 0, sizeof (gateway));
-			memset (&dns1, 0, sizeof (dns1));
-			memset (&dns2, 0, sizeof (dns2));
-			prefix = 0;
-			method = NULL;
-		}
-
-		if (skip)
-			continue;
-
-		/* HWADDR */
-		if (!skip && (p = match_iscsiadm_tag (*iter, ISCSI_HWADDR_TAG, &skip))) {
-			struct ether_addr *ibft_mac;
-
-			ibft_mac = ether_aton (p);
-			if (!ibft_mac) {
-				g_warning ("%s: malformed iscsiadm record: invalid hwaddress.", __func__);
-				skip = TRUE;
-				continue;
-			}
-
-			if (memcmp (ifcfg_mac->data, (guint8 *) ibft_mac->ether_addr_octet, ETH_ALEN)) {
-				/* This record isn't for the current device, ignore it */
-				skip = TRUE;
-				continue;
-			}
-
-			/* Success, this record is for this device */
-			hwaddr_matched = TRUE;
-		}
-
-		/* BOOTPROTO */
-		if (!skip && (p = match_iscsiadm_tag (*iter, ISCSI_BOOTPROTO_TAG, &skip))) {
-			if (!g_ascii_strcasecmp (p, "dhcp"))
-				method = NM_SETTING_IP4_CONFIG_METHOD_AUTO;
-			else if (!g_ascii_strcasecmp (p, "static"))
-				method = NM_SETTING_IP4_CONFIG_METHOD_MANUAL;
-			else {
-				g_warning ("%s: malformed iscsiadm record: unknown BOOTPROTO '%s'.",
-				           __func__, p);
-				skip = TRUE;
-				continue;
-			}
-		}
-
-		if (!skip && (p = match_iscsiadm_tag (*iter, ISCSI_IPADDR_TAG, &skip))) {
-			if (inet_pton (AF_INET, p, &ipaddr) < 1) {
-				g_warning ("%s: malformed iscsiadm record: invalid IP address '%s'.",
-				           __func__, p);
-				skip = TRUE;
-				continue;
-			}
-		}
-
-		if (!skip && (p = match_iscsiadm_tag (*iter, ISCSI_SUBNET_TAG, &skip))) {
-			struct in_addr mask;
-
-			if (inet_pton (AF_INET, p, &mask) < 1) {
-				g_warning ("%s: malformed iscsiadm record: invalid subnet mask '%s'.",
-				           __func__, p);
-				skip = TRUE;
-				continue;
-			}
-
-			prefix = nm_utils_ip4_netmask_to_prefix (mask.s_addr);
-		}
-
-		if (!skip && (p = match_iscsiadm_tag (*iter, ISCSI_GATEWAY_TAG, &skip))) {
-			if (inet_pton (AF_INET, p, &gateway) < 1) {
-				g_warning ("%s: malformed iscsiadm record: invalid IP gateway '%s'.",
-				           __func__, p);
-				skip = TRUE;
-				continue;
-			}
-		}
-
-		if (!skip && (p = match_iscsiadm_tag (*iter, ISCSI_DNS1_TAG, &skip))) {
-			if (inet_pton (AF_INET, p, &dns1) < 1) {
-				g_warning ("%s: malformed iscsiadm record: invalid DNS1 address '%s'.",
-				           __func__, p);
-				skip = TRUE;
-				continue;
-			}
-		}
-
-		if (!skip && (p = match_iscsiadm_tag (*iter, ISCSI_DNS2_TAG, &skip))) {
-			if (inet_pton (AF_INET, p, &dns2) < 1) {
-				g_warning ("%s: malformed iscsiadm record: invalid DNS2 address '%s'.",
-				           __func__, p);
-				skip = TRUE;
-				continue;
-			}
-		}
-	}
-
-	success = TRUE;
-
-done:
-	if (ifcfg_mac)
-		g_byte_array_free (ifcfg_mac, TRUE);
-	g_strfreev (lines);
-	g_free (out);
-	g_free (err);
-	return success;
-}
-
 static gboolean
 read_ip4_address (shvarFile *ifcfg,
                   const char *tag,
@@ -1298,16 +1052,7 @@ make_ip4_setting (shvarFile *ifcfg,
 	if (value) {
 		if (!g_ascii_strcasecmp (value, "bootp") || !g_ascii_strcasecmp (value, "dhcp"))
 			method = NM_SETTING_IP4_CONFIG_METHOD_AUTO;
-		else if (!g_ascii_strcasecmp (value, "ibft")) {
-			g_object_set (s_ip4, NM_SETTING_IP4_CONFIG_NEVER_DEFAULT, never_default, NULL);
-			/* iSCSI Boot Firmware Table: need to read values from the iSCSI 
-			 * firmware for this device and create the IP4 setting using those.
-			 */
-			if (fill_ip4_setting_from_ibft (ifcfg, s_ip4, iscsiadm_path, error))
-				return NM_SETTING (s_ip4);
-			g_object_unref (s_ip4);
-			return NULL;
-		} else if (!g_ascii_strcasecmp (value, "autoip")) {
+		else if (!g_ascii_strcasecmp (value, "autoip")) {
 			g_free (value);
 			g_object_set (s_ip4,
 			              NM_SETTING_IP4_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_LINK_LOCAL,
@@ -4444,6 +4189,18 @@ connection_from_file (const char *filename,
 		g_free (lower);
 	}
 
+	/* iBFT is handled by the iBFT settings plugin */
+	bootproto = svGetValue (parsed, "BOOTPROTO", FALSE);
+	if (bootproto && !g_ascii_strcasecmp (bootproto, "ibft")) {
+		if (ignore_error)
+			*ignore_error = TRUE;
+		g_set_error (&error, IFCFG_PLUGIN_ERROR, 0,
+		             "Ignoring iBFT configuration");
+		g_free (bootproto);
+		goto done;
+	}
+	g_free (bootproto);
+
 	/* Construct the connection */
 	if (!strcasecmp (type, TYPE_ETHERNET))
 		connection = wired_connection_from_ifcfg (filename, parsed, nm_controlled, unmanaged, &error);
@@ -4512,21 +4269,6 @@ connection_from_file (const char *filename,
 	} else if (s_port)
 		nm_connection_add_setting (connection, s_port);
 
-	/* iSCSI / ibft connections are read-only since their settings are
-	 * stored in NVRAM and can only be changed in BIOS.
-	 */
-	bootproto = svGetValue (parsed, "BOOTPROTO", FALSE);
-	if (   bootproto
-	    && connection
-	    && !g_ascii_strcasecmp (bootproto, "ibft")) {
-		NMSettingConnection *s_con;
-
-		s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
-		g_assert (s_con);
-
-		g_object_set (G_OBJECT (s_con), NM_SETTING_CONNECTION_READ_ONLY, TRUE, NULL);
-	}
-
 	if (s_ip4) {
 		/* read ifcfg aliases for filename */
 		read_aliases (connection, filename, network_file);
diff --git a/system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-bad-dns1 b/system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-bad-dns1
deleted file mode 100755
index 4a6a938..0000000
--- a/system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-bad-dns1
+++ /dev/null
@@ -1,21 +0,0 @@
-#!/bin/bash
-
-cat << EOF
-# BEGIN RECORD
-iface.initiatorname = iqn.pjones6
-iface.hwaddress = 00:33:21:98:b9:f0
-iface.bootproto = STATIC
-iface.ipaddress = 192.168.32.72
-iface.subnet_mask = 255.255.252.0
-iface.gateway = 192.168.35.254
-iface.primary_dns = 10000.500.250.1
-iface.secondary_dns = 10.16.255.3
-iface.vlan = 0
-iface.net_ifacename = eth0
-node.name = iqn.0.2008-11.com.blahblah:iscsi0
-node.conn[0].address = 10.16.52.16
-node.conn[0].port = 3260
-node.boot_lun = 00000000
-# END RECORD
-EOF
-
diff --git a/system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-bad-dns2 b/system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-bad-dns2
deleted file mode 100755
index 9bd5839..0000000
--- a/system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-bad-dns2
+++ /dev/null
@@ -1,21 +0,0 @@
-#!/bin/bash
-
-cat << EOF
-# BEGIN RECORD
-iface.initiatorname = iqn.pjones6
-iface.hwaddress = 00:33:21:98:b9:f0
-iface.bootproto = STATIC
-iface.ipaddress = 192.168.32.72
-iface.subnet_mask = 255.255.252.0
-iface.gateway = 192.168.35.254
-iface.primary_dns = 10.16.255.2
-iface.secondary_dns = blah.foo.bar.baz
-iface.vlan = 0
-iface.net_ifacename = eth0
-node.name = iqn.0.2008-11.com.blahblah:iscsi0
-node.conn[0].address = 10.16.52.16
-node.conn[0].port = 3260
-node.boot_lun = 00000000
-# END RECORD
-EOF
-
diff --git a/system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-bad-gateway b/system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-bad-gateway
deleted file mode 100755
index b3dc744..0000000
--- a/system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-bad-gateway
+++ /dev/null
@@ -1,21 +0,0 @@
-#!/bin/bash
-
-cat << EOF
-# BEGIN RECORD
-iface.initiatorname = iqn.pjones6
-iface.hwaddress = 00:33:21:98:b9:f0
-iface.bootproto = STATIC
-iface.ipaddress = aa.bb.cc.dd
-iface.subnet_mask = 255.255.252.0
-iface.gateway = 192.168.35.254
-iface.primary_dns = 10.16.255.2
-iface.secondary_dns = 10.16.255.3
-iface.vlan = 0
-iface.net_ifacename = eth0
-node.name = iqn.0.2008-11.com.blahblah:iscsi0
-node.conn[0].address = 10.16.52.16
-node.conn[0].port = 3260
-node.boot_lun = 00000000
-# END RECORD
-EOF
-
diff --git a/system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-bad-ipaddr b/system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-bad-ipaddr
deleted file mode 100755
index 92f4477..0000000
--- a/system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-bad-ipaddr
+++ /dev/null
@@ -1,21 +0,0 @@
-#!/bin/bash
-
-cat << EOF
-# BEGIN RECORD
-iface.initiatorname = iqn.pjones6
-iface.hwaddress = 00:33:21:98:b9:f0
-iface.bootproto = STATIC
-iface.ipaddress = 192.168.32.72
-iface.subnet_mask = 255.255.252.0
-iface.gateway = bb.cc.dd.ee
-iface.primary_dns = 10.16.255.2
-iface.secondary_dns = 10.16.255.3
-iface.vlan = 0
-iface.net_ifacename = eth0
-node.name = iqn.0.2008-11.com.blahblah:iscsi0
-node.conn[0].address = 10.16.52.16
-node.conn[0].port = 3260
-node.boot_lun = 00000000
-# END RECORD
-EOF
-
diff --git a/system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-dhcp b/system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-dhcp
deleted file mode 100755
index 6de0637..0000000
--- a/system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-dhcp
+++ /dev/null
@@ -1,33 +0,0 @@
-#!/bin/bash
-
-cat << EOF
-# BEGIN RECORD
-iface.initiatorname = iqn.pjones6
-iface.hwaddress = 00:33:21:98:b9:f0
-iface.bootproto = DHCP
-iface.gateway = 10.16.52.254
-iface.primary_dns = 10.16.255.2
-iface.secondary_dns = 10.16.255.3
-iface.vlan = 0
-iface.net_ifacename = eth0
-node.name = iqn.0.2008-11.com.blahblah:iscsi0
-node.conn[0].address = 10.16.52.16
-node.conn[0].port = 3260
-node.boot_lun = 00000000
-# END RECORD
-# BEGIN RECORD
-iface.initiatorname = iqn.pjones6
-iface.hwaddress = 00:33:21:98:b9:f1
-iface.bootproto = DHCP
-iface.gateway = 10.16.52.254
-iface.primary_dns = 10.16.255.2
-iface.secondary_dns = 10.16.255.3
-iface.vlan = 0
-iface.net_ifacename = eth1
-node.name = iqn.1.2008-11.com.blahblah:iscsi1
-node.conn[0].address = 10.16.52.16
-node.conn[0].port = 3260
-node.boot_lun = 00000000
-# END RECORD
-EOF
-
diff --git a/system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-static b/system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-static
deleted file mode 100755
index 99a6e7c..0000000
--- a/system-settings/plugins/ifcfg-rh/tests/iscsiadm-test-static
+++ /dev/null
@@ -1,35 +0,0 @@
-#!/bin/bash
-
-cat << EOF
-# BEGIN RECORD
-iface.initiatorname = iqn.pjones6
-iface.hwaddress = 00:33:21:98:b9:f0
-iface.bootproto = STATIC
-iface.ipaddress = 192.168.32.72
-iface.subnet_mask = 255.255.252.0
-iface.gateway = 192.168.35.254
-iface.primary_dns = 10.16.255.2
-iface.secondary_dns = 10.16.255.3
-iface.vlan = 0
-iface.net_ifacename = eth0
-node.name = iqn.0.2008-11.com.blahblah:iscsi0
-node.conn[0].address = 10.16.52.16
-node.conn[0].port = 3260
-node.boot_lun = 00000000
-# END RECORD
-# BEGIN RECORD
-iface.initiatorname = iqn.pjones6
-iface.hwaddress = 00:33:21:98:b9:f1
-iface.bootproto = DHCP
-iface.gateway = 10.16.52.254
-iface.primary_dns = 10.16.255.2
-iface.secondary_dns = 10.16.255.3
-iface.vlan = 0
-iface.net_ifacename = eth1
-node.name = iqn.1.2008-11.com.blahblah:iscsi1
-node.conn[0].address = 10.16.52.16
-node.conn[0].port = 3260
-node.boot_lun = 00000000
-# END RECORD
-EOF
-
diff --git a/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-ibft b/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-ibft
new file mode 100644
index 0000000..d3e4edc
--- /dev/null
+++ b/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-ibft
@@ -0,0 +1,10 @@
+# Generated by dracut initrd
+DEVICE="ibft0"
+ONBOOT=yes
+NETBOOT=yes
+UUID="2aa8c19d-9744-4ca4-b74f-c37e73f2918e"
+BOOTPROTO=ibft
+HWADDR="00:33:21:98:b9:f0"
+TYPE=Ethernet
+NAME="ibft0"
+
diff --git a/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-ibft-dhcp b/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-ibft-dhcp
deleted file mode 100644
index abfcd6e..0000000
--- a/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-ibft-dhcp
+++ /dev/null
@@ -1,4 +0,0 @@
-# Intel Corporation 82540EP Gigabit Ethernet Controller (Mobile)
-DEVICE=eth0
-HWADDR=00:33:21:98:b9:f1
-BOOTPROTO=ibft
diff --git a/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-ibft-static b/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-ibft-static
deleted file mode 100644
index 99b02e4..0000000
--- a/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-ibft-static
+++ /dev/null
@@ -1,4 +0,0 @@
-# Intel Corporation 82540EP Gigabit Ethernet Controller (Mobile)
-DEVICE=eth0
-HWADDR=00:33:21:98:b9:f0
-BOOTPROTO=ibft
diff --git a/system-settings/plugins/ifcfg-rh/tests/test-ifcfg-rh.c b/system-settings/plugins/ifcfg-rh/tests/test-ifcfg-rh.c
index a240f34..693d651 100644
--- a/system-settings/plugins/ifcfg-rh/tests/test-ifcfg-rh.c
+++ b/system-settings/plugins/ifcfg-rh/tests/test-ifcfg-rh.c
@@ -9804,376 +9804,29 @@ test_write_wifi_dynamic_wep_leap (void)
 	g_object_unref (reread);
 }
 
-#define TEST_IFCFG_IBFT_DHCP TEST_IFCFG_DIR"/network-scripts/ifcfg-test-ibft-dhcp"
-
 static void
-test_read_ibft_dhcp (void)
+test_read_ibft_ignored (void)
 {
 	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIP4Config *s_ip4;
 	char *unmanaged = NULL;
 	char *keyfile = NULL;
 	char *routefile = NULL;
 	char *route6file = NULL;
 	gboolean ignore_error = FALSE;
 	GError *error = NULL;
-	const char *tmp;
-	const GByteArray *array;
-	char expected_mac_address[ETH_ALEN] = { 0x00, 0x33, 0x21, 0x98, 0xb9, 0xf1 };
-	const char *expected_id = "System test-ibft-dhcp";
-	guint64 expected_timestamp = 0;
 
-	connection = connection_from_file (TEST_IFCFG_IBFT_DHCP,
+	connection = connection_from_file (TEST_IFCFG_DIR"/network-scripts/ifcfg-test-ibft",
+	                                   NULL, TYPE_ETHERNET,
 	                                   NULL,
-	                                   TYPE_ETHERNET,
-	                                   TEST_IFCFG_DIR "/iscsiadm-test-dhcp",
 	                                   &unmanaged,
 	                                   &keyfile,
 	                                   &routefile,
 	                                   &route6file,
 	                                   &error,
 	                                   &ignore_error);
-	ASSERT (connection != NULL,
-	        "ibft-dhcp-read", "failed to read %s: %s", TEST_IFCFG_IBFT_DHCP, error->message);
-
-	ASSERT (nm_connection_verify (connection, &error),
-	        "ibft-dhcp-verify", "failed to verify %s: %s", TEST_IFCFG_IBFT_DHCP, error->message);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
-	ASSERT (s_con != NULL,
-	        "ibft-dhcp-verify-connection", "failed to verify %s: missing %s setting",
-	        TEST_IFCFG_IBFT_DHCP,
-	        NM_SETTING_CONNECTION_SETTING_NAME);
-
-	/* ID */
-	tmp = nm_setting_connection_get_id (s_con);
-	ASSERT (tmp != NULL,
-	        "ibft-dhcp-verify-connection", "failed to verify %s: missing %s / %s key",
-	        TEST_IFCFG_IBFT_DHCP,
-	        NM_SETTING_CONNECTION_SETTING_NAME,
-	        NM_SETTING_CONNECTION_ID);
-	ASSERT (strcmp (tmp, expected_id) == 0,
-	        "ibft-dhcp-verify-connection", "failed to verify %s: unexpected %s / %s key value",
-	        TEST_IFCFG_IBFT_DHCP,
-	        NM_SETTING_CONNECTION_SETTING_NAME,
-	        NM_SETTING_CONNECTION_ID);
-
-	/* UUID can't be tested if the ifcfg does not contain the UUID key, because
-	 * the UUID is generated on the full path of the ifcfg file, which can change
-	 * depending on where the tests are run.
-	 */
-
-	/* Timestamp */
-	ASSERT (nm_setting_connection_get_timestamp (s_con) == expected_timestamp,
-	        "ibft-dhcp-verify-connection", "failed to verify %s: unexpected %s /%s key value",
-	        TEST_IFCFG_IBFT_DHCP,
-	        NM_SETTING_CONNECTION_SETTING_NAME,
-	        NM_SETTING_CONNECTION_TIMESTAMP);
-
-	/* Autoconnect */
-	ASSERT (nm_setting_connection_get_autoconnect (s_con) == TRUE,
-	        "ibft-dhcp-verify-connection", "failed to verify %s: unexpected %s /%s key value",
-	        TEST_IFCFG_IBFT_DHCP,
-	        NM_SETTING_CONNECTION_SETTING_NAME,
-	        NM_SETTING_CONNECTION_AUTOCONNECT);
-
-	/* Read-only */
-	ASSERT (nm_setting_connection_get_read_only (s_con) == TRUE,
-	        "ibft-dhcp-verify-connection", "failed to verify %s: unexpected %s /%s key value",
-	        TEST_IFCFG_IBFT_DHCP,
-	        NM_SETTING_CONNECTION_SETTING_NAME,
-	        NM_SETTING_CONNECTION_READ_ONLY);
-
-	/* ===== WIRED SETTING ===== */
-
-	s_wired = NM_SETTING_WIRED (nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRED));
-	ASSERT (s_wired != NULL,
-	        "ibft-dhcp-verify-wired", "failed to verify %s: missing %s setting",
-	        TEST_IFCFG_IBFT_DHCP,
-	        NM_SETTING_WIRED_SETTING_NAME);
-
-	/* MAC address */
-	array = nm_setting_wired_get_mac_address (s_wired);
-	ASSERT (array != NULL,
-	        "ibft-dhcp-verify-wired", "failed to verify %s: missing %s / %s key",
-	        TEST_IFCFG_IBFT_DHCP,
-	        NM_SETTING_WIRED_SETTING_NAME,
-	        NM_SETTING_WIRED_MAC_ADDRESS);
-	ASSERT (array->len == ETH_ALEN,
-	        "ibft-dhcp-verify-wired", "failed to verify %s: unexpected %s / %s key value length",
-	        TEST_IFCFG_IBFT_DHCP,
-	        NM_SETTING_WIRED_SETTING_NAME,
-	        NM_SETTING_WIRED_MAC_ADDRESS);
-	ASSERT (memcmp (array->data, &expected_mac_address[0], sizeof (expected_mac_address)) == 0,
-	        "ibft-dhcp-verify-wired", "failed to verify %s: unexpected %s / %s key value",
-	        TEST_IFCFG_IBFT_DHCP,
-	        NM_SETTING_WIRED_SETTING_NAME,
-	        NM_SETTING_WIRED_MAC_ADDRESS);
-
-	ASSERT (nm_setting_wired_get_mtu (s_wired) == 0,
-	        "ibft-dhcp-verify-wired", "failed to verify %s: unexpected %s / %s key value",
-	        TEST_IFCFG_IBFT_DHCP,
-	        NM_SETTING_WIRED_SETTING_NAME,
-	        NM_SETTING_WIRED_MTU);
-
-	/* ===== IPv4 SETTING ===== */
-
-	s_ip4 = NM_SETTING_IP4_CONFIG (nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG));
-	ASSERT (s_ip4 != NULL,
-	        "ibft-dhcp-verify-ip4", "failed to verify %s: missing %s setting",
-	        TEST_IFCFG_IBFT_DHCP,
-	        NM_SETTING_IP4_CONFIG_SETTING_NAME);
-
-	/* Method */
-	tmp = nm_setting_ip4_config_get_method (s_ip4);
-	ASSERT (strcmp (tmp, NM_SETTING_IP4_CONFIG_METHOD_AUTO) == 0,
-	        "ibft-dhcp-verify-ip4", "failed to verify %s: unexpected %s / %s key value",
-	        TEST_IFCFG_IBFT_DHCP,
-	        NM_SETTING_IP4_CONFIG_SETTING_NAME,
-	        NM_SETTING_IP4_CONFIG_METHOD);
-
-	g_object_unref (connection);
-}
-
-#define TEST_IFCFG_IBFT_STATIC TEST_IFCFG_DIR"/network-scripts/ifcfg-test-ibft-static"
-
-static void
-test_read_ibft_static (void)
-{
-	NMConnection *connection;
-	NMSettingConnection *s_con;
-	NMSettingWired *s_wired;
-	NMSettingIP4Config *s_ip4;
-	char *unmanaged = NULL;
-	char *keyfile = NULL;
-	char *routefile = NULL;
-	char *route6file = NULL;
-	gboolean ignore_error = FALSE;
-	GError *error = NULL;
-	const char *tmp;
-	const GByteArray *array;
-	char expected_mac_address[ETH_ALEN] = { 0x00, 0x33, 0x21, 0x98, 0xb9, 0xf0 };
-	const char *expected_id = "System test-ibft-static";
-	guint64 expected_timestamp = 0;
-	const char *expected_dns1 = "10.16.255.2";
-	const char *expected_dns2 = "10.16.255.3";
-	struct in_addr addr;
-	const char *expected_address1 = "192.168.32.72";
-	const char *expected_address1_gw = "192.168.35.254";
-	NMIP4Address *ip4_addr;
-
-	connection = connection_from_file (TEST_IFCFG_IBFT_STATIC,
-	                                   NULL,
-	                                   TYPE_ETHERNET,
-	                                   TEST_IFCFG_DIR "/iscsiadm-test-static",
-	                                   &unmanaged,
-	                                   &keyfile,
-	                                   &routefile,
-	                                   &route6file,
-	                                   &error,
-	                                   &ignore_error);
-	ASSERT (connection != NULL,
-	        "ibft-static-read", "failed to read %s: %s", TEST_IFCFG_IBFT_STATIC, error->message);
-
-	ASSERT (nm_connection_verify (connection, &error),
-	        "ibft-static-verify", "failed to verify %s: %s", TEST_IFCFG_IBFT_STATIC, error->message);
-
-	/* ===== CONNECTION SETTING ===== */
-
-	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
-	ASSERT (s_con != NULL,
-	        "ibft-static-verify-connection", "failed to verify %s: missing %s setting",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_CONNECTION_SETTING_NAME);
-
-	/* ID */
-	tmp = nm_setting_connection_get_id (s_con);
-	ASSERT (tmp != NULL,
-	        "ibft-static-verify-connection", "failed to verify %s: missing %s / %s key",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_CONNECTION_SETTING_NAME,
-	        NM_SETTING_CONNECTION_ID);
-	ASSERT (strcmp (tmp, expected_id) == 0,
-	        "ibft-static-verify-connection", "failed to verify %s: unexpected %s / %s key value",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_CONNECTION_SETTING_NAME,
-	        NM_SETTING_CONNECTION_ID);
-
-	/* UUID can't be tested if the ifcfg does not contain the UUID key, because
-	 * the UUID is generated on the full path of the ifcfg file, which can change
-	 * depending on where the tests are run.
-	 */
-
-	/* Timestamp */
-	ASSERT (nm_setting_connection_get_timestamp (s_con) == expected_timestamp,
-	        "ibft-static-verify-connection", "failed to verify %s: unexpected %s /%s key value",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_CONNECTION_SETTING_NAME,
-	        NM_SETTING_CONNECTION_TIMESTAMP);
-
-	/* Autoconnect */
-	ASSERT (nm_setting_connection_get_autoconnect (s_con) == TRUE,
-	        "ibft-static-verify-connection", "failed to verify %s: unexpected %s /%s key value",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_CONNECTION_SETTING_NAME,
-	        NM_SETTING_CONNECTION_AUTOCONNECT);
-
-	/* Read-only */
-	ASSERT (nm_setting_connection_get_read_only (s_con) == TRUE,
-	        "ibft-static-verify-connection", "failed to verify %s: unexpected %s /%s key value",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_CONNECTION_SETTING_NAME,
-	        NM_SETTING_CONNECTION_READ_ONLY);
-
-	/* ===== WIRED SETTING ===== */
-
-	s_wired = NM_SETTING_WIRED (nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRED));
-	ASSERT (s_wired != NULL,
-	        "ibft-static-verify-wired", "failed to verify %s: missing %s setting",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_WIRED_SETTING_NAME);
-
-	/* MAC address */
-	array = nm_setting_wired_get_mac_address (s_wired);
-	ASSERT (array != NULL,
-	        "ibft-static-verify-wired", "failed to verify %s: missing %s / %s key",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_WIRED_SETTING_NAME,
-	        NM_SETTING_WIRED_MAC_ADDRESS);
-	ASSERT (array->len == ETH_ALEN,
-	        "ibft-static-verify-wired", "failed to verify %s: unexpected %s / %s key value length",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_WIRED_SETTING_NAME,
-	        NM_SETTING_WIRED_MAC_ADDRESS);
-	ASSERT (memcmp (array->data, &expected_mac_address[0], sizeof (expected_mac_address)) == 0,
-	        "ibft-static-verify-wired", "failed to verify %s: unexpected %s / %s key value",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_WIRED_SETTING_NAME,
-	        NM_SETTING_WIRED_MAC_ADDRESS);
-
-	ASSERT (nm_setting_wired_get_mtu (s_wired) == 0,
-	        "ibft-static-verify-wired", "failed to verify %s: unexpected %s / %s key value",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_WIRED_SETTING_NAME,
-	        NM_SETTING_WIRED_MTU);
-
-	/* ===== IPv4 SETTING ===== */
-
-	s_ip4 = NM_SETTING_IP4_CONFIG (nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG));
-	ASSERT (s_ip4 != NULL,
-	        "ibft-static-verify-ip4", "failed to verify %s: missing %s setting",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_IP4_CONFIG_SETTING_NAME);
-
-	/* Method */
-	tmp = nm_setting_ip4_config_get_method (s_ip4);
-	ASSERT (strcmp (tmp, NM_SETTING_IP4_CONFIG_METHOD_MANUAL) == 0,
-	        "ibft-static-verify-ip4", "failed to verify %s: unexpected %s / %s key value",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_IP4_CONFIG_SETTING_NAME,
-	        NM_SETTING_IP4_CONFIG_METHOD);
-
-	/* DNS Addresses */
-	ASSERT (nm_setting_ip4_config_get_num_dns (s_ip4) == 2,
-	        "ibft-static-verify-ip4", "failed to verify %s: unexpected %s / %s key value",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_IP4_CONFIG_SETTING_NAME,
-	        NM_SETTING_IP4_CONFIG_DNS);
-
-	ASSERT (inet_pton (AF_INET, expected_dns1, &addr) > 0,
-	        "ibft-static-verify-ip4", "failed to verify %s: couldn't convert DNS IP address #1",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_IP4_CONFIG_SETTING_NAME,
-	        NM_SETTING_IP4_CONFIG_DNS);
-	ASSERT (nm_setting_ip4_config_get_dns (s_ip4, 0) == addr.s_addr,
-	        "ibft-static-verify-ip4", "failed to verify %s: unexpected %s / %s key value #1",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_IP4_CONFIG_SETTING_NAME,
-	        NM_SETTING_IP4_CONFIG_DNS);
-
-	ASSERT (inet_pton (AF_INET, expected_dns2, &addr) > 0,
-	        "ibft-static-verify-ip4", "failed to verify %s: couldn't convert DNS IP address #2",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_IP4_CONFIG_SETTING_NAME,
-	        NM_SETTING_IP4_CONFIG_DNS);
-	ASSERT (nm_setting_ip4_config_get_dns (s_ip4, 1) == addr.s_addr,
-	        "ibft-static-verify-ip4", "failed to verify %s: unexpected %s / %s key value #2",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_IP4_CONFIG_SETTING_NAME,
-	        NM_SETTING_IP4_CONFIG_DNS);
-
-	ASSERT (nm_setting_ip4_config_get_num_addresses (s_ip4) == 1,
-	        "ibft-static-verify-ip4", "failed to verify %s: unexpected %s / %s key value",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_IP4_CONFIG_SETTING_NAME,
-	        NM_SETTING_IP4_CONFIG_DNS);
-
-	/* Address #1 */
-	ip4_addr = nm_setting_ip4_config_get_address (s_ip4, 0);
-	ASSERT (ip4_addr,
-	        "ibft-static-verify-ip4", "failed to verify %s: missing IP4 address #1",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_IP4_CONFIG_SETTING_NAME,
-	        NM_SETTING_IP4_CONFIG_ADDRESSES);
-
-	ASSERT (nm_ip4_address_get_prefix (ip4_addr) == 22,
-	        "ibft-static-verify-ip4", "failed to verify %s: unexpected IP4 address #1 prefix",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_IP4_CONFIG_SETTING_NAME,
-	        NM_SETTING_IP4_CONFIG_ADDRESSES);
-
-	ASSERT (inet_pton (AF_INET, expected_address1, &addr) > 0,
-	        "ibft-static-verify-ip4", "failed to verify %s: couldn't convert IP address #1",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_IP4_CONFIG_SETTING_NAME,
-	        NM_SETTING_IP4_CONFIG_DNS);
-	ASSERT (nm_ip4_address_get_address (ip4_addr) == addr.s_addr,
-	        "ibft-static-verify-ip4", "failed to verify %s: unexpected IP4 address #1",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_IP4_CONFIG_SETTING_NAME,
-	        NM_SETTING_IP4_CONFIG_ADDRESSES);
-
-	ASSERT (inet_pton (AF_INET, expected_address1_gw, &addr) > 0,
-	        "ibft-static-verify-ip4", "failed to verify %s: couldn't convert IP address #1 gateway",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_IP4_CONFIG_SETTING_NAME,
-	        NM_SETTING_IP4_CONFIG_ADDRESSES);
-	ASSERT (nm_ip4_address_get_gateway (ip4_addr) == addr.s_addr,
-	        "ibft-static-verify-ip4", "failed to verify %s: unexpected IP4 address #1 gateway",
-	        TEST_IFCFG_IBFT_STATIC,
-	        NM_SETTING_IP4_CONFIG_SETTING_NAME,
-	        NM_SETTING_IP4_CONFIG_ADDRESSES);
-
-	g_object_unref (connection);
-}
-
-static void
-test_read_ibft_malformed (const char *name, const char *iscsiadm_path)
-{
-	NMConnection *connection;
-	char *unmanaged = NULL;
-	char *keyfile = NULL;
-	char *routefile = NULL;
-	char *route6file = NULL;
-	gboolean ignore_error = FALSE;
-	GError *error = NULL;
-
-	connection = connection_from_file (TEST_IFCFG_IBFT_STATIC,
-	                                   NULL,
-	                                   TYPE_ETHERNET,
-	                                   iscsiadm_path,
-	                                   &unmanaged,
-	                                   &keyfile,
-	                                   &routefile,
-	                                   &route6file,
-	                                   &error,
-	                                   &ignore_error);
-	ASSERT (connection == NULL,
-	        name, "unexpectedly able to read %s", TEST_IFCFG_IBFT_STATIC);
+	g_assert_error (error, IFCFG_PLUGIN_ERROR, 0);
+	g_assert (connection == NULL);
+	g_clear_error (&error);
 }
 
 static void
@@ -12076,14 +11729,7 @@ int main (int argc, char **argv)
 	test_write_dns_options ();
 
 	/* iSCSI / ibft */
-	test_read_ibft_dhcp ();
-	test_read_ibft_static ();
-	test_read_ibft_malformed ("ibft-bad-record-read", TEST_IFCFG_DIR "/iscsiadm-test-bad-record");
-	test_read_ibft_malformed ("ibft-bad-entry-read", TEST_IFCFG_DIR "/iscsiadm-test-bad-entry");
-	test_read_ibft_malformed ("ibft-bad-ipaddr-read", TEST_IFCFG_DIR "/iscsiadm-test-bad-ipaddr");
-	test_read_ibft_malformed ("ibft-bad-gateway-read", TEST_IFCFG_DIR "/iscsiadm-test-bad-gateway");
-	test_read_ibft_malformed ("ibft-bad-dns1-read", TEST_IFCFG_DIR "/iscsiadm-test-bad-dns1");
-	test_read_ibft_malformed ("ibft-bad-dns2-read", TEST_IFCFG_DIR "/iscsiadm-test-bad-dns2");
+	test_read_ibft_ignored ();
 
 	/* bonding */
 	test_read_bond_main ();
-- 
1.7.1

