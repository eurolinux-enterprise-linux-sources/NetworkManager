Date: Mon, 12 Aug 2013 18:08:36 -0500
From: Dan Williams <dcbw@redhat.com>
Subject: NetworkManager interactive VPN secrets

Backport of the patches on the dcbw/vpn-need-secrets branch, fixed up
for the fact that of course there's no agents in 0.8, but a single user
settings service.  Once source of noise is that we need to fix up the
secrets code to handle char** hints, instead of the previous hints1 and
hints2, since VPN plugins may send more than 2 hints.

---
 introspection/nm-settings.xml                      |   15 +
 introspection/nm-vpn-plugin.xml                    |   74 ++++++-
 libnm-glib/libnm-glib-vpn.ver                      |    1 +
 libnm-glib/libnm-glib.ver                          |    2 +
 libnm-glib/nm-settings-service.c                   |   51 ++++-
 libnm-glib/nm-settings-service.h                   |   27 ++
 libnm-glib/nm-vpn-plugin.c                         |  272 ++++++++++++++------
 libnm-glib/nm-vpn-plugin.h                         |   16 +-
 marshallers/nm-marshal.list                        |    3 +-
 .../nm-applet-dbus-126.conf                        |    6 +
 network-manager-applet-0.8.1/src/applet.c          |    5 +-
 .../src/vpn-password-dialog.c                      |   48 +++--
 .../src/vpn-password-dialog.h                      |    1 +
 src/nm-activation-request.c                        |    6 +-
 src/nm-activation-request.h                        |    3 +-
 src/nm-device-bt.c                                 |    3 +-
 src/nm-device-ethernet.c                           |    2 -
 src/nm-device-modem.c                              |    3 +-
 src/nm-device-wifi.c                               |    7 +-
 src/nm-manager.c                                   |   89 +++++--
 src/nm-secrets-provider-interface.c                |   11 +-
 src/nm-secrets-provider-interface.h                |    6 +-
 src/ppp-manager/nm-ppp-manager.c                   |   23 +-
 src/vpn-manager/nm-vpn-connection.c                |  274 +++++++++++++++-----
 src/vpn-manager/nm-vpn-connection.h                |    3 +-
 src/vpn-manager/nm-vpn-manager.c                   |    3 +-
 src/vpn-manager/nm-vpn-manager.h                   |    1 +
 src/vpn-manager/nm-vpn-service.c                   |    3 +-
 src/vpn-manager/nm-vpn-service.h                   |    1 +
 29 files changed, 740 insertions(+), 219 deletions(-)

diff --git a/introspection/nm-settings.xml b/introspection/nm-settings.xml
index b252c00..a970719 100644
--- a/introspection/nm-settings.xml
+++ b/introspection/nm-settings.xml
@@ -42,6 +42,21 @@
       </arg>
     </signal>
 
+    <property name="Capabilities" type="u" access="read" tp:type="NM_SETTINGS_SERVICE_CAPABILITIES">
+      <tp:docstring>
+        Indicates various settings service capabilities.
+      </tp:docstring>
+    </property>
+
+    <tp:flags name="NM_SETTINGS_SERVICE_CAPABILITIES" value-prefix="NM_SETTINGS_SERVICE_CAPABILITY" type="u">
+      <tp:flag suffix="NONE" value="0x0">
+        <tp:docstring>No capability.</tp:docstring>
+      </tp:flag>
+      <tp:flag suffix="VPN_HINTS" value="0x1">
+        <tp:docstring>The agent supports passing hints to VPN plugin authentication dialogs.</tp:docstring>
+      </tp:flag>
+    </tp:flags>
+
   </interface>
 </node>
 
diff --git a/introspection/nm-vpn-plugin.xml b/introspection/nm-vpn-plugin.xml
index 72861f2..30c29d4 100644
--- a/introspection/nm-vpn-plugin.xml
+++ b/introspection/nm-vpn-plugin.xml
@@ -5,9 +5,11 @@
     <tp:docstring>
       This interface is provided by plugins providing VPN services to the NetworkManager daemon.
     </tp:docstring>
+
     <method name="Connect">
       <tp:docstring>
-        Tells the plugin to connect.
+        Tells the plugin to connect.  Interactive secrets requests (eg, emitting
+        the SecretsRequired signal) are not allowed.
       </tp:docstring>
       <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_vpn_plugin_connect"/>
       <arg name="connection" type="a{sa{sv}}" direction="in" tp:type="String_String_Variant_Map_Map">
@@ -21,6 +23,35 @@
         <tp:error name="org.freedesktop.NetworkManager.VPN.Error.StoppingInProgress"/>
         <tp:error name="org.freedesktop.NetworkManager.VPN.Error.BadArguments"/>
         <tp:error name="org.freedesktop.NetworkManager.VPN.Error.LaunchFailed"/>
+        <tp:error name="org.freedesktop.NetworkManager.VPN.Error.WrongState"/>
+      </tp:possible-errors>
+    </method>
+
+    <method name="ConnectInteractive">
+      <tp:docstring>
+        Tells the plugin to connect, allowing interactive secrets requests (eg
+        the plugin is allowed to emit the SecretsRequired signal if the VPN
+        service indicates that it needs additional secrets during the connect
+        process).
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_vpn_plugin_connect_interactive"/>
+      <arg name="connection" type="a{sa{sv}}" direction="in" tp:type="String_String_Variant_Map_Map">
+        <tp:docstring>
+          Describes the connection to be established.
+        </tp:docstring>
+      </arg>
+      <arg name="details" type="a{sv}" direction="in" tp:type="String_Variant_Map">
+        <tp:docstring>
+          Additional details about the Connect process.
+        </tp:docstring>
+      </arg>
+      <tp:possible-errors>
+        <tp:error name="org.freedesktop.NetworkManager.VPN.Error.StartingInProgress"/>
+        <tp:error name="org.freedesktop.NetworkManager.VPN.Error.AlreadyStarted"/>
+        <tp:error name="org.freedesktop.NetworkManager.VPN.Error.StoppingInProgress"/>
+        <tp:error name="org.freedesktop.NetworkManager.VPN.Error.BadArguments"/>
+        <tp:error name="org.freedesktop.NetworkManager.VPN.Error.LaunchFailed"/>
+        <tp:error name="org.freedesktop.NetworkManager.VPN.Error.WrongState"/>
       </tp:possible-errors>
     </method>
 
@@ -96,6 +127,47 @@
       </arg>
     </signal>
 
+    <signal name="SecretsRequired">
+      <tp:docstring>
+        Emitted during an ongoing ConnectInteractive() request when the plugin
+        has determined that new secrets are required.  NetworkManager will then
+        call the NewSecrets() method with a connection hash including the new
+        secrets.
+      </tp:docstring>
+      <arg name="message" type="s" direction="out">
+          <tp:docstring>
+              Informational message, if any, about the request.  For example, if
+              a second PIN is required, could indicate to the user to wait for
+              the token code to change until entering the next PIN.
+          </tp:docstring>
+      </arg>
+      <arg name="secrets" type="as" direction="out">
+          <tp:docstring>
+              Array of strings of VPN secret names which the plugin thinks
+              secrets may be required for, or other VPN-specific data to be
+              processed by the VPN's front-end.
+          </tp:docstring>
+      </arg>
+    </signal>
+
+    <method name="NewSecrets">
+      <tp:docstring>
+        Called in response to a SecretsRequired signal to deliver updated secrets
+        or other information to the plugin.
+      </tp:docstring>
+      <annotation name="org.freedesktop.DBus.GLib.CSymbol" value="impl_vpn_plugin_new_secrets"/>
+      <arg name="connection" type="a{sa{sv}}" direction="in" tp:type="String_String_Variant_Map_Map">
+        <tp:docstring>
+          Describes the connection including the new secrets.
+        </tp:docstring>
+      </arg>
+      <tp:possible-errors>
+        <tp:error name="org.freedesktop.NetworkManager.VPN.Error.WrongState"/>
+        <tp:error name="org.freedesktop.NetworkManager.VPN.Error.BadArguments"/>
+        <tp:error name="org.freedesktop.NetworkManager.VPN.Error.LaunchFailed"/>
+      </tp:possible-errors>
+    </method>
+
     <signal name="Ip4Config">
       <tp:docstring>
         The plugin obtained an IPv4 configuration.
diff --git a/libnm-glib/libnm-glib-vpn.ver b/libnm-glib/libnm-glib-vpn.ver
index 16643d2..47487e3 100644
--- a/libnm-glib/libnm-glib-vpn.ver
+++ b/libnm-glib/libnm-glib-vpn.ver
@@ -7,6 +7,7 @@ global:
 	nm_vpn_plugin_get_connection;
 	nm_vpn_plugin_get_state;
 	nm_vpn_plugin_get_type;
+	nm_vpn_plugin_secrets_required;
 	nm_vpn_plugin_set_ip4_config;
 	nm_vpn_plugin_set_login_banner;
 	nm_vpn_plugin_set_state;
diff --git a/libnm-glib/libnm-glib.ver b/libnm-glib/libnm-glib.ver
index dabde6e..f64c3c0 100644
--- a/libnm-glib/libnm-glib.ver
+++ b/libnm-glib/libnm-glib.ver
@@ -163,7 +163,9 @@ global:
 	nm_settings_interface_get_connection_by_path;
 	nm_settings_interface_get_type;
 	nm_settings_interface_list_connections;
+	nm_settings_service_capabilities_get_type;
 	nm_settings_service_export;
+	nm_settings_service_export_with_capabilities;
 	nm_settings_service_export_connection;
 	nm_settings_service_get_connection_by_path;
 	nm_settings_service_get_type;
diff --git a/libnm-glib/nm-settings-service.c b/libnm-glib/nm-settings-service.c
index 6266d10..ffd33a5 100644
--- a/libnm-glib/nm-settings-service.c
+++ b/libnm-glib/nm-settings-service.c
@@ -51,6 +51,7 @@ typedef struct {
 	DBusGConnection *bus;
 	NMConnectionScope scope;
 	gboolean exported;
+	NMSettingsServiceCapabilities capabilities;
 
 	gboolean disposed;
 } NMSettingsServicePrivate;
@@ -59,15 +60,38 @@ enum {
 	PROP_0,
 	PROP_BUS,
 	PROP_SCOPE,
+	PROP_CAPABILITIES,
 
 	LAST_PROP
 };
 
+/**************************************************************/
+
+GType
+nm_settings_service_capabilities_get_type (void)
+{
+  static volatile gsize g_define_type_id__volatile = 0;
+
+  if (g_once_init_enter (&g_define_type_id__volatile))
+    {
+      static const GFlagsValue values[] = {
+        { NM_SETTINGS_SERVICE_CAPABILITY_NONE, "NM_SETTINGS_SERVICE_CAPABILITY_NONE", "none" },
+        { NM_SETTINGS_SERVICE_CAPABILITY_VPN_HINTS, "NM_SETTINGS_SERVICE_CAPABILITY_VPN_HINTS", "vpn-hints" },
+        { 0, NULL, NULL }
+      };
+      GType g_define_type_id =
+        g_flags_register_static (g_intern_static_string ("NMSettingsServiceCapabilities"), values);
+      g_once_init_leave (&g_define_type_id__volatile, g_define_type_id);
+    }
+
+  return g_define_type_id__volatile;
+}
 
 /**************************************************************/
 
 void
-nm_settings_service_export (NMSettingsService *self)
+nm_settings_service_export_with_capabilities (NMSettingsService *self,
+                                              NMSettingsServiceCapabilities capabilities)
 {
 	NMSettingsServicePrivate *priv;
 
@@ -81,12 +105,20 @@ nm_settings_service_export (NMSettingsService *self)
 	/* Don't allow exporting twice */
 	g_return_if_fail (priv->exported == FALSE);
 
+	priv->capabilities = capabilities;
+
 	dbus_g_connection_register_g_object (priv->bus,
 	                                     NM_DBUS_PATH_SETTINGS,
 	                                     G_OBJECT (self));
 	priv->exported = TRUE;
 }
 
+void
+nm_settings_service_export (NMSettingsService *self)
+{
+	nm_settings_service_export_with_capabilities (self, NM_SETTINGS_SERVICE_CAPABILITY_NONE);
+}
+
 /**************************************************************/
 
 static GSList *
@@ -312,6 +344,9 @@ get_property (GObject *object, guint prop_id,
 	case PROP_SCOPE:
 		g_value_set_uint (value, priv->scope);
 		break;
+	case PROP_CAPABILITIES:
+		g_value_set_uint (value, priv->capabilities);
+		break;
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -369,4 +404,18 @@ nm_settings_service_class_init (NMSettingsServiceClass *class)
 	                                                    NM_CONNECTION_SCOPE_USER,
 	                                                    NM_CONNECTION_SCOPE_USER,
 	                                                    G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+
+	/**
+	 * NMSettingsService:capabilities:
+	 *
+	 * The capabilities of the settings service.
+	 **/
+	g_object_class_install_property (object_class, PROP_CAPABILITIES,
+	                                 g_param_spec_uint (NM_SETTINGS_SERVICE_CAPABILITIES,
+	                                                    "Capabilities",
+	                                                    "Capabilities",
+	                                                    NM_SETTINGS_SERVICE_CAPABILITY_NONE,
+	                                                    G_MAXUINT32,
+	                                                    NM_SETTINGS_SERVICE_CAPABILITY_NONE,
+	                                                    G_PARAM_READABLE));
 }
diff --git a/libnm-glib/nm-settings-service.h b/libnm-glib/nm-settings-service.h
index 9f4b95f..6ec1152 100644
--- a/libnm-glib/nm-settings-service.h
+++ b/libnm-glib/nm-settings-service.h
@@ -29,6 +29,26 @@
 
 G_BEGIN_DECLS
 
+/**
+ * NMSettingsServiceCapabilities:
+ * @NM_SETTINGS_SERVICE_CAPABILITY_NONE: the service supports no special
+ * capabilities
+ * @NM_SETTINGS_SERVICE_CAPABILITY_VPN_HINTS: the service supports sending hints
+ * given by the NMSettingsConnectionClass::get_secrets() class method to VPN
+ * plugin authentication dialogs.
+ * @NM_SETTINGS_SERVICE_CAPABILITY_LAST: bounds checking value; should not be used.
+ *
+ * #NMSettingsServiceCapabilities indicate various capabilities of the settings
+ * service.
+ */
+typedef enum /*< flags >*/ {
+	NM_SETTINGS_SERVICE_CAPABILITY_NONE = 0x0,
+	NM_SETTINGS_SERVICE_CAPABILITY_VPN_HINTS = 0x1,
+
+	/* boundary value */
+	NM_SETTINGS_SERVICE_CAPABILITY_LAST = NM_SETTINGS_SERVICE_CAPABILITY_VPN_HINTS
+} NMSettingsServiceCapabilities;
+
 #define NM_TYPE_SETTINGS_SERVICE            (nm_settings_service_get_type ())
 #define NM_SETTINGS_SERVICE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_SETTINGS_SERVICE, NMSettingsService))
 #define NM_SETTINGS_SERVICE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_SETTINGS_SERVICE, NMSettingsServiceClass))
@@ -38,6 +58,7 @@ G_BEGIN_DECLS
 
 #define NM_SETTINGS_SERVICE_BUS "bus"
 #define NM_SETTINGS_SERVICE_SCOPE "scope"
+#define NM_SETTINGS_SERVICE_CAPABILITIES "capabilities"
 
 typedef struct {
 	GObject parent;
@@ -69,11 +90,17 @@ typedef struct {
 
 GType nm_settings_service_get_type (void);
 
+#define NM_TYPE_SETTINGS_SERVICE_CAPABILITIES (nm_settings_service_capabilities_get_type ())
+GType nm_settings_service_capabilities_get_type (void);
+
 NMExportedConnection *nm_settings_service_get_connection_by_path (NMSettingsService *self,
                                                                   const char *path);
 
 void nm_settings_service_export (NMSettingsService *self);
 
+void nm_settings_service_export_with_capabilities (NMSettingsService *self,
+                                                   NMSettingsServiceCapabilities capabilities);
+
 void nm_settings_service_export_connection (NMSettingsService *self,
                                             NMSettingsConnectionInterface *exported);
 
diff --git a/libnm-glib/nm-vpn-plugin.c b/libnm-glib/nm-vpn-plugin.c
index fe7a2b6..ec188e6 100644
--- a/libnm-glib/nm-vpn-plugin.c
+++ b/libnm-glib/nm-vpn-plugin.c
@@ -30,13 +30,22 @@
 
 static gboolean impl_vpn_plugin_connect    (NMVPNPlugin *plugin,
 								    GHashTable *connection,
-								    GError **err);
+                                            GError **error);
+
+static gboolean impl_vpn_plugin_connect_interactive (NMVPNPlugin *plugin,
+                                                     GHashTable *connection,
+                                                     GHashTable *details,
+                                                     GError **error);
 
 static gboolean impl_vpn_plugin_need_secrets (NMVPNPlugin *plugin,
 								    GHashTable *connection,
 								    char **service_name,
 								    GError **err);
 
+static gboolean impl_vpn_plugin_new_secrets (NMVPNPlugin *plugin,
+                                             GHashTable *connection,
+                                             GError **err);
+
 static gboolean impl_vpn_plugin_disconnect (NMVPNPlugin *plugin,
 								    GError **err);
 
@@ -50,7 +59,6 @@ static gboolean impl_vpn_plugin_set_failure (NMVPNPlugin *plugin,
 
 #include "nm-vpn-plugin-glue.h"
 
-#define NM_VPN_PLUGIN_CONNECT_TIMER 60
 #define NM_VPN_PLUGIN_QUIT_TIMER    20
 
 G_DEFINE_ABSTRACT_TYPE (NMVPNPlugin, nm_vpn_plugin, G_TYPE_OBJECT)
@@ -69,6 +77,7 @@ typedef struct {
 	guint connect_timer;
 	guint quit_timer;
 	guint fail_stop_id;
+	gboolean interactive;
 } NMVPNPluginPrivate;
 
 #define NM_VPN_PLUGIN_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_VPN_PLUGIN, NMVPNPluginPrivate))
@@ -79,6 +88,7 @@ enum {
 	LOGIN_BANNER,
 	FAILURE,
 	QUIT,
+	SECRETS_REQUIRED,
 
 	LAST_SIGNAL
 };
@@ -288,60 +298,14 @@ fail_stop (gpointer data)
 	return FALSE;
 }
 
-static gboolean
-nm_vpn_plugin_connect (NMVPNPlugin *plugin,
-				   NMConnection *connection,
-				   GError **err)
+static void
+schedule_fail_stop (NMVPNPlugin *plugin)
 {
 	NMVPNPluginPrivate *priv = NM_VPN_PLUGIN_GET_PRIVATE (plugin);
-	gboolean ret = FALSE;
-	NMVPNServiceState state;
-
-	g_return_val_if_fail (NM_IS_VPN_PLUGIN (plugin), FALSE);
 
-	state = nm_vpn_plugin_get_state (plugin);
-	switch (state) {
-	case NM_VPN_SERVICE_STATE_STARTING:
-		g_set_error (err,
-				   NM_VPN_PLUGIN_ERROR,
-				   NM_VPN_PLUGIN_ERROR_STARTING_IN_PROGRESS,
-				   "%s",
-				   "Could not process the request because the VPN connection is already being started.");
-		break;
-	case NM_VPN_SERVICE_STATE_STARTED:
-		g_set_error (err,
-				   NM_VPN_PLUGIN_ERROR,
-				   NM_VPN_PLUGIN_ERROR_ALREADY_STARTED,
-				   "%s",
-				   "Could not process the request because a VPN connection was already active.");
-		break;
-	case NM_VPN_SERVICE_STATE_STOPPING:
-		g_set_error (err,
-				   NM_VPN_PLUGIN_ERROR,
-				   NM_VPN_PLUGIN_ERROR_STOPPING_IN_PROGRESS,
-				   "%s",
-				   "Could not process the request because the VPN connection is being stopped.");
-		break;
-	case NM_VPN_SERVICE_STATE_STOPPED:
-	case NM_VPN_SERVICE_STATE_INIT:
-		nm_vpn_plugin_set_state (plugin, NM_VPN_SERVICE_STATE_STARTING);
-		ret = NM_VPN_PLUGIN_GET_CLASS (plugin)->connect (plugin, connection, err);
-		if (!ret) {
-			/* Stop the plugin from and idle handler so that the Connect
-			 * method return gets sent before the STOP StateChanged signal.
-			 */
-			if (priv->fail_stop_id)
-				g_source_remove (priv->fail_stop_id);
-			priv->fail_stop_id = g_idle_add (fail_stop, plugin);
-		}
-		break;
-
-	default:
-		g_assert_not_reached ();
-		break;
-	}
-
-	return ret;
+	if (priv->fail_stop_id)
+		g_source_remove (priv->fail_stop_id);
+	priv->fail_stop_id = g_idle_add (fail_stop, plugin);
 }
 
 void
@@ -356,31 +320,102 @@ nm_vpn_plugin_set_ip4_config (NMVPNPlugin *plugin,
 	nm_vpn_plugin_set_state (plugin, NM_VPN_SERVICE_STATE_STARTED);
 }
 
+static void
+connect_timer_removed (gpointer data)
+{
+	NM_VPN_PLUGIN_GET_PRIVATE (data)->connect_timer = 0;
+}
+
+static void
+connect_timer_start (NMVPNPlugin *plugin)
+{
+	NMVPNPluginPrivate *priv = NM_VPN_PLUGIN_GET_PRIVATE (plugin);
+
+	priv->connect_timer = g_timeout_add_seconds_full (G_PRIORITY_DEFAULT,
+	                                                  60,
+	                                                  connect_timer_expired,
+	                                                  plugin,
+	                                                  connect_timer_removed);
+}
 
 static gboolean
-impl_vpn_plugin_connect (NMVPNPlugin *plugin,
-					GHashTable *properties,
-					GError **error)
+_connect_generic (NMVPNPlugin *plugin,
+                  GHashTable *properties,
+                  GHashTable *details,
+                  GError **error)
 {
+	NMVPNPluginPrivate *priv = NM_VPN_PLUGIN_GET_PRIVATE (plugin);
+	NMVPNPluginClass *vpn_class = NM_VPN_PLUGIN_GET_CLASS (plugin);
 	NMConnection *connection;
 	gboolean success = FALSE;
+	GError *local = NULL;
 
-	connection = nm_connection_new_from_hash (properties, error);
+	if (priv->state != NM_VPN_SERVICE_STATE_STOPPED &&
+	    priv->state != NM_VPN_SERVICE_STATE_INIT) {
+		g_set_error (error, NM_VPN_PLUGIN_ERROR, NM_VPN_PLUGIN_ERROR_WRONG_STATE,
+		             "Could not start connection: wrong plugin state %d",
+		             priv->state);
+		return FALSE;
+	}
+
+	connection = nm_connection_new_from_hash (properties, &local);
 	if (!connection) {
-		nm_warning ("%s: Invalid connection: '%s' / '%s' invalid: %d",
-		            __func__,
-		            g_type_name (nm_connection_lookup_setting_type_by_quark ((*error)->domain)),
-		            (*error)->message,
-		            (*error)->code);
+		g_set_error (error, NM_VPN_PLUGIN_ERROR, NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,
+		             "Invalid connection: (%d) %s",
+		             local->code, local->message);
+		g_clear_error (&local);
+		return FALSE;
+	}
+
+	nm_vpn_plugin_set_state (plugin, NM_VPN_SERVICE_STATE_STARTING);
+
+	priv->interactive = FALSE;
+	if (details && !vpn_class->connect_interactive) {
+		g_set_error_literal (error, NM_VPN_PLUGIN_ERROR, NM_VPN_PLUGIN_ERROR_GENERAL,
+		                     "Plugin does not implement ConnectInteractive()");
+		return FALSE;
+	}
+
+	if (details) {
+		priv->interactive = TRUE;
+		success = vpn_class->connect_interactive (plugin, connection, details, error);
+	} else
+		success = vpn_class->connect (plugin, connection, error);
+
+	if (success) {
+		/* Add a timer to make sure we do not wait indefinitely for the successful connect. */
+		connect_timer_start (plugin);
 	} else {
-		success = nm_vpn_plugin_connect (plugin, connection, error);
-		g_object_unref (connection);
+		/* Stop the plugin from an idle handler so that the Connect
+		 * method return gets sent before the STOP StateChanged signal.
+		 */
+		schedule_fail_stop (plugin);
 	}
 
+	g_object_unref (connection);
 	return success;
 }
 
 static gboolean
+impl_vpn_plugin_connect (NMVPNPlugin *plugin,
+                         GHashTable *connection,
+                         GError **error)
+{
+	return _connect_generic (plugin, connection, NULL, error);
+}
+
+static gboolean
+impl_vpn_plugin_connect_interactive (NMVPNPlugin *plugin,
+                                     GHashTable *connection,
+                                     GHashTable *details,
+                                     GError **error)
+{
+	return _connect_generic (plugin, connection, details, error);
+}
+
+/***************************************************************/
+
+static gboolean
 impl_vpn_plugin_need_secrets (NMVPNPlugin *plugin,
                               GHashTable *properties,
                               char **setting_name,
@@ -435,6 +470,94 @@ out:
 }
 
 static gboolean
+impl_vpn_plugin_new_secrets (NMVPNPlugin *plugin,
+                             GHashTable *properties,
+                             GError **error)
+{
+	NMVPNPluginPrivate *priv = NM_VPN_PLUGIN_GET_PRIVATE (plugin);
+	NMConnection *connection;
+	GError *local = NULL;
+	gboolean success;
+
+	if (priv->state != NM_VPN_SERVICE_STATE_STARTING) {
+		g_set_error (error, NM_VPN_PLUGIN_ERROR, NM_VPN_PLUGIN_ERROR_WRONG_STATE,
+		             "Could not accept new secrets: wrong plugin state %d",
+		             priv->state);
+		return FALSE;
+	}
+
+	connection = nm_connection_new_from_hash (properties, &local);
+	if (!connection) {
+		g_set_error (error, NM_VPN_PLUGIN_ERROR, NM_VPN_PLUGIN_ERROR_BAD_ARGUMENTS,
+		             "Invalid connection: (%d) %s",
+		             local->code, local->message);
+		g_clear_error (&local);
+		return FALSE;
+	}
+
+	if (!NM_VPN_PLUGIN_GET_CLASS (plugin)->new_secrets) {
+		g_set_error_literal (error, NM_VPN_PLUGIN_ERROR, NM_VPN_PLUGIN_ERROR_GENERAL,
+		                     "Could not accept new secrets: plugin cannot process interactive secrets");
+		g_object_unref (connection);
+		return FALSE;
+	}
+
+	success = NM_VPN_PLUGIN_GET_CLASS (plugin)->new_secrets (plugin, connection, error);
+	if (success) {
+		/* Add a timer to make sure we do not wait indefinitely for the successful connect. */
+		connect_timer_start (plugin);
+	} else {
+		/* Stop the plugin from and idle handler so that the NewSecrets
+		 * method return gets sent before the STOP StateChanged signal.
+		 */
+		schedule_fail_stop (plugin);
+	}
+
+	g_object_unref (connection);
+	return success;
+}
+
+/**
+ * nm_vpn_plugin_secrets_required:
+ * @plugin: the #NMVPNPlugin
+ * @message: an information message about why secrets are required, if any
+ * @hints: VPN specific secret names for required new secrets
+ *
+ * Called by VPN plugin implementations to signal to NetworkManager that secrets
+ * are required during the connection process.  This signal may be used to
+ * request new secrets when the secrets originally provided by NetworkManager
+ * are insufficient, or the VPN process indicates that it needs additional
+ * information to complete the request.
+ *
+ * Since: 0.9.10
+ */
+void
+nm_vpn_plugin_secrets_required (NMVPNPlugin *plugin,
+                                const char *message,
+                                const char **hints)
+{
+	NMVPNPluginPrivate *priv = NM_VPN_PLUGIN_GET_PRIVATE (plugin);
+
+	/* Plugin must be able to accept the new secrets if it calls this method */
+	g_return_if_fail (NM_VPN_PLUGIN_GET_CLASS (plugin)->new_secrets);
+
+	/* Plugin cannot call this method if NetworkManager didn't originally call
+	 * ConnectInteractive().
+	 */
+	g_return_if_fail (priv->interactive == TRUE);
+
+	/* Cancel the connect timer since secrets might take a while.  It'll
+	 * get restarted when the secrets come back via NewSecrets().
+	 */
+	if (priv->connect_timer)
+		g_source_remove (priv->connect_timer);
+
+	g_signal_emit (plugin, signals[SECRETS_REQUIRED], 0, message, hints);
+}
+
+/***************************************************************/
+
+static gboolean
 impl_vpn_plugin_disconnect (NMVPNPlugin *plugin,
 					   GError **err)
 {
@@ -653,12 +776,6 @@ finalize (GObject *object)
 }
 
 static void
-connect_timer_removed (gpointer data)
-{
-	NM_VPN_PLUGIN_GET_PRIVATE (data)->connect_timer = 0;
-}
-
-static void
 quit_timer_removed (gpointer data)
 {
 	NM_VPN_PLUGIN_GET_PRIVATE (data)->quit_timer = 0;
@@ -679,13 +796,6 @@ state_changed (NMVPNPlugin *plugin, NMVPNServiceState state)
 			g_source_remove (priv->fail_stop_id);
 			priv->fail_stop_id = 0;
 		}
-
-		/* Add a timer to make sure we do not wait indefinitely for the successful connect. */
-		priv->connect_timer = g_timeout_add_seconds_full (G_PRIORITY_DEFAULT,
-		                                                  NM_VPN_PLUGIN_CONNECT_TIMER,
-		                                                  connect_timer_expired,
-		                                                  plugin,
-		                                                  connect_timer_removed);
 		break;
 	case NM_VPN_SERVICE_STATE_STOPPED:
 		priv->quit_timer = g_timeout_add_seconds_full (G_PRIORITY_DEFAULT,
@@ -759,6 +869,14 @@ nm_vpn_plugin_class_init (NMVPNPluginClass *plugin_class)
 				    G_TYPE_NONE, 1,
 				    G_TYPE_UINT);
 
+	signals[SECRETS_REQUIRED] =
+		g_signal_new ("secrets-required",
+		              G_OBJECT_CLASS_TYPE (object_class),
+		              G_SIGNAL_RUN_FIRST,
+		              0, NULL, NULL,
+		              NULL,
+		              G_TYPE_NONE, 2, G_TYPE_STRING, G_TYPE_STRV);
+
 	signals[IP4_CONFIG] =
 		g_signal_new ("ip4-config",
 				    G_OBJECT_CLASS_TYPE (object_class),
diff --git a/libnm-glib/nm-vpn-plugin.h b/libnm-glib/nm-vpn-plugin.h
index 8a3c2f1..eb2145b 100644
--- a/libnm-glib/nm-vpn-plugin.h
+++ b/libnm-glib/nm-vpn-plugin.h
@@ -92,13 +92,21 @@ typedef struct {
 
 	void (*quit)           (NMVPNPlugin *plugin);
 
+	/* more methods */
+	gboolean (*new_secrets)  (NMVPNPlugin *plugin,
+	                          NMConnection *connection,
+	                          GError **error);
+
+	gboolean (*connect_interactive) (NMVPNPlugin *plugin,
+	                                 NMConnection *connection,
+	                                 GHashTable *details,
+	                                 GError **error);
+
 	/* Padding for future expansion */
 	void (*_reserved1) (void);
 	void (*_reserved2) (void);
 	void (*_reserved3) (void);
 	void (*_reserved4) (void);
-	void (*_reserved5) (void);
-	void (*_reserved6) (void);
 } NMVPNPluginClass;
 
 GType  nm_vpn_plugin_get_type       (void);
@@ -110,6 +118,10 @@ NMVPNServiceState  nm_vpn_plugin_get_state      (NMVPNPlugin *plugin);
 void               nm_vpn_plugin_set_state      (NMVPNPlugin *plugin,
 									    NMVPNServiceState state);
 
+void               nm_vpn_plugin_secrets_required (NMVPNPlugin *plugin,
+                                                   const char *message,
+                                                   const char **hints);
+
 void               nm_vpn_plugin_set_login_banner (NMVPNPlugin *plugin,
 										 const char *banner);
 
diff --git a/marshallers/nm-marshal.list b/marshallers/nm-marshal.list
index c0c4fcd..089dd8a 100644
--- a/marshallers/nm-marshal.list
+++ b/marshallers/nm-marshal.list
@@ -20,10 +20,11 @@ VOID:INT,UINT,BOOLEAN
 VOID:OBJECT,OBJECT,ENUM
 VOID:POINTER,STRING
 VOID:STRING,BOXED
-BOOLEAN:POINTER,STRING,BOOLEAN,UINT,STRING,STRING
+BOOLEAN:POINTER,STRING,BOOLEAN,UINT,POINTER
 VOID:STRING,BOOLEAN,UINT,STRING,STRING
 BOOLEAN:VOID
 VOID:STRING,BOOLEAN
 VOID:STRING,OBJECT,POINTER
 VOID:BOOLEAN,UINT
 VOID:POINTER,POINTER,POINTER,POINTER,INT
+VOID:STRING,POINTER
diff --git a/network-manager-applet-0.8.1/nm-applet-dbus-126.conf b/network-manager-applet-0.8.1/nm-applet-dbus-126.conf
index 2bd6b1a..380b3ff 100644
--- a/network-manager-applet-0.8.1/nm-applet-dbus-126.conf
+++ b/network-manager-applet-0.8.1/nm-applet-dbus-126.conf
@@ -19,6 +19,9 @@
                 <allow send_destination="org.freedesktop.NetworkManagerUserSettings"
                        send_interface="org.freedesktop.NetworkManagerSettings.Connection"/>
 
+                <allow send_destination="org.freedesktop.NetworkManagerUserSettings"
+                       send_interface="org.freedesktop.DBus.Properties"/>
+
                 <!-- Only root can get secrets -->
                 <allow send_destination="org.freedesktop.NetworkManagerUserSettings"
                        send_interface="org.freedesktop.NetworkManagerSettings.Connection.Secrets"/>
@@ -31,6 +34,9 @@
 
                 <allow send_destination="org.freedesktop.NetworkManagerUserSettings"
                        send_interface="org.freedesktop.NetworkManagerSettings.Connection"/>
+
+                <allow send_destination="org.freedesktop.NetworkManagerUserSettings"
+                       send_interface="org.freedesktop.DBus.Properties"/>
         </policy>
         <policy context="default">
                 <allow send_destination="org.freedesktop.NetworkManagerUserSettings"
diff --git a/network-manager-applet-0.8.1/src/applet.c b/network-manager-applet-0.8.1/src/applet.c
index 88c74a1..6a900d9 100644
--- a/network-manager-applet-0.8.1/src/applet.c
+++ b/network-manager-applet-0.8.1/src/applet.c
@@ -2852,7 +2852,7 @@ applet_settings_new_secrets_requested_cb (NMAGConfSettings *settings,
 
 	/* VPN secrets get handled a bit differently */
 	if (!strcmp (nm_setting_connection_get_connection_type (s_con), NM_SETTING_VPN_SETTING_NAME)) {
-		nma_vpn_request_password (NM_SETTINGS_CONNECTION_INTERFACE (connection), ask_user, callback, callback_data);
+		nma_vpn_request_password (NM_SETTINGS_CONNECTION_INTERFACE (connection), ask_user, hints, callback, callback_data);
 		return;
 	}
 
@@ -3294,7 +3294,8 @@ constructor (GType type,
 	                  G_CALLBACK (applet_settings_new_secrets_requested_cb),
 	                  applet);
 
-	nm_settings_service_export (NM_SETTINGS_SERVICE (applet->gconf_settings));
+	nm_settings_service_export_with_capabilities (NM_SETTINGS_SERVICE (applet->gconf_settings),
+	                                              NM_SETTINGS_SERVICE_CAPABILITY_VPN_HINTS);
 
 	/* Start our DBus service */
 	if (!applet_dbus_manager_start_service (dbus_mgr)) {
diff --git a/network-manager-applet-0.8.1/src/vpn-password-dialog.c b/network-manager-applet-0.8.1/src/vpn-password-dialog.c
index a4fbda7..5a3b249 100644
--- a/network-manager-applet-0.8.1/src/vpn-password-dialog.c
+++ b/network-manager-applet-0.8.1/src/vpn-password-dialog.c
@@ -88,11 +88,14 @@ out:
 }
 
 static char *
-find_auth_dialog_binary (const char *service, const char *name)
+find_auth_dialog_binary (const char *service,
+                         const char *name,
+                         gboolean *out_hints_supported)
 {
 	GDir * dir;
 	char * prog = NULL;
 	const char *f;
+	gboolean hints_supported = FALSE;
 
 	dir = g_dir_open (VPN_NAME_FILES_DIR, 0, NULL);
 	if (!dir)
@@ -117,6 +120,7 @@ find_auth_dialog_binary (const char *service, const char *name)
 			    strcmp (thisservice, service) == 0) {
 
 				prog = g_key_file_get_string (keyfile, "GNOME", "auth-dialog", NULL);
+				hints_supported = g_key_file_get_boolean (keyfile, "GNOME", "supports-hints", NULL);
 			}
 			g_free (thisservice);
 		}
@@ -151,6 +155,8 @@ out:
 		g_free (prog);
 		prog = g_strdup_printf ("%s/%s", LIBEXECDIR, prog_basename);
 		g_free (prog_basename);
+
+		*out_hints_supported = hints_supported;
 	}
 
 	return prog;
@@ -168,16 +174,11 @@ destroy_gvalue (gpointer data)
 gboolean
 nma_vpn_request_password (NMSettingsConnectionInterface *connection_iface,
                           gboolean retry,
+                          const char **hints,
                           NMANewSecretsRequestedFunc callback,
                           gpointer callback_data)
 {
-	const char *argv[] = { NULL /*"/usr/libexec/nm-vpnc-auth-dialog"*/, 
-	                       "-u", NULL /*"2a5d52b5-95b4-4431-b96e-3dd46128f9a7"*/, 
-	                       "-n", NULL /*"davidznet42"*/,
-	                       "-s", NULL /*"org.freedesktop.vpnc"*/, 
-	                       "-r",
-	                       NULL
-	                     };
+	char **argv = NULL;
 	int         child_stdin;
 	int         child_stdout;
 	GPid        child_pid;
@@ -194,6 +195,8 @@ nma_vpn_request_password (NMSettingsConnectionInterface *connection_iface,
 	const char *id;
 	const char *connection_type;
 	const char *service_type;
+	guint i = 0, u, hints_len;
+	gboolean supports_hints = FALSE;
 
 	g_return_val_if_fail (NM_IS_CONNECTION (connection), FALSE);
 
@@ -214,7 +217,7 @@ nma_vpn_request_password (NMSettingsConnectionInterface *connection_iface,
 	g_return_val_if_fail (service_type != NULL, FALSE);
 
 	/* find the auth-dialog binary */
-	auth_dialog_binary = find_auth_dialog_binary (service_type, id);
+	auth_dialog_binary = find_auth_dialog_binary (service_type, id, &supports_hints);
 	if (!auth_dialog_binary) {
 		g_set_error (&error,
 		             NM_SETTINGS_INTERFACE_ERROR,
@@ -224,18 +227,28 @@ nma_vpn_request_password (NMSettingsConnectionInterface *connection_iface,
 		goto out;
 	}
 
-	/* Fix up parameters with what we got */
-	argv[0] = auth_dialog_binary;
-	argv[2] = nm_setting_connection_get_uuid (s_con);
-	argv[4] = id;
-	argv[6] = service_type;
-	if (!retry)
-		argv[7] = NULL;
+	hints_len = g_strv_length ((char **) hints);
+	argv = g_new0 (char *, 10 + (2 * hints_len));
+	argv[i++] = auth_dialog_binary;
+	argv[i++] = "-u";
+	argv[i++] = (char *) nm_setting_connection_get_uuid (s_con);
+	argv[i++] = "-n";
+	argv[i++] = (char *) id;
+	argv[i++] = "-s";
+	argv[i++] = (char *) service_type;
+	if (retry)
+		argv[i++] = "-r";
+
+	/* add hints */
+	for (u = 0; supports_hints && (u < hints_len); u++) {
+		argv[i++] = "-t";
+		argv[i++] = (char *) hints[u];
+	}
 
 	child_status = -1;
 
 	if (!g_spawn_async_with_pipes (NULL,                       /* working_directory */
-				       (gchar **) argv,            /* argv */
+				       argv,                       /* argv */
 				       NULL,                       /* envp */
 				       G_SPAWN_DO_NOT_REAP_CHILD,  /* flags */
 				       NULL,                       /* child_setup */
@@ -328,6 +341,7 @@ nma_vpn_request_password (NMSettingsConnectionInterface *connection_iface,
 
  out:
 	g_free (auth_dialog_binary);
+	g_free (argv);
 
 	if (error) {
 		callback (NM_SETTINGS_CONNECTION_INTERFACE (connection), NULL, error, callback_data);
diff --git a/network-manager-applet-0.8.1/src/vpn-password-dialog.h b/network-manager-applet-0.8.1/src/vpn-password-dialog.h
index 325f7bf..2f238ae 100644
--- a/network-manager-applet-0.8.1/src/vpn-password-dialog.h
+++ b/network-manager-applet-0.8.1/src/vpn-password-dialog.h
@@ -27,6 +27,7 @@
 
 gboolean nma_vpn_request_password (NMSettingsConnectionInterface *connection,
                                    gboolean retry,
+                                   const char **hints,
                                    NMANewSecretsRequestedFunc callback,
                                    gpointer callback_data);
 
diff --git a/src/nm-activation-request.c b/src/nm-activation-request.c
index 8160ade..b73a7c2 100644
--- a/src/nm-activation-request.c
+++ b/src/nm-activation-request.c
@@ -454,8 +454,7 @@ nm_act_request_get_secrets (NMActRequest *self,
                             const char *setting_name,
                             gboolean request_new,
                             RequestSecretsCaller caller,
-                            const char *hint1,
-                            const char *hint2)
+                            const char **hints)
 {
 	g_return_val_if_fail (self, FALSE);
 	g_return_val_if_fail (NM_IS_ACT_REQUEST (self), FALSE);
@@ -465,8 +464,7 @@ nm_act_request_get_secrets (NMActRequest *self,
 	                                                  setting_name,
 	                                                  request_new,
 	                                                  caller,
-	                                                  hint1,
-	                                                  hint2);
+	                                                  hints);
 }
 
 NMConnection *
diff --git a/src/nm-activation-request.h b/src/nm-activation-request.h
index b93e94e..399753f 100644
--- a/src/nm-activation-request.h
+++ b/src/nm-activation-request.h
@@ -98,8 +98,7 @@ gboolean nm_act_request_get_secrets    (NMActRequest *req,
                                         const char *setting_name,
                                         gboolean request_new,
                                         RequestSecretsCaller caller,
-                                        const char *hint1,
-                                        const char *hint2);
+                                        const char **hints);
 
 GObject *     nm_act_request_get_master (NMActRequest *req);
 
diff --git a/src/nm-device-bt.c b/src/nm-device-bt.c
index c4d5c45..466a21f 100644
--- a/src/nm-device-bt.c
+++ b/src/nm-device-bt.c
@@ -339,12 +339,13 @@ modem_need_auth (NMModem *modem,
 {
 	NMDeviceBt *self = NM_DEVICE_BT (user_data);
 	NMActRequest *req;
+	const char *hints[3] = { hint1, hint2, NULL };
 
 	req = nm_device_get_act_request (NM_DEVICE (self));
 	g_assert (req);
 
 	nm_device_state_changed (NM_DEVICE (self), NM_DEVICE_STATE_NEED_AUTH, NM_DEVICE_STATE_REASON_NONE);
-	nm_act_request_get_secrets (req, setting_name, retry, caller, hint1, hint2);
+	nm_act_request_get_secrets (req, setting_name, retry, caller, hints);
 }
 
 static void
diff --git a/src/nm-device-ethernet.c b/src/nm-device-ethernet.c
index bd0b3e7..5d44579 100644
--- a/src/nm-device-ethernet.c
+++ b/src/nm-device-ethernet.c
@@ -855,7 +855,6 @@ link_timeout_cb (gpointer user_data)
 	                            setting_name,
 	                            TRUE,
 	                            SECRETS_CALLER_ETHERNET,
-	                            NULL,
 	                            NULL);
 
 	return FALSE;
@@ -1147,7 +1146,6 @@ handle_auth_or_fail (NMDeviceEthernet *self,
 		                            setting_name,
 		                            get_new,
 		                            SECRETS_CALLER_ETHERNET,
-		                            NULL,
 		                            NULL);
 
 		g_object_set_data (G_OBJECT (connection), WIRED_SECRETS_TRIES, GUINT_TO_POINTER (++tries));
diff --git a/src/nm-device-modem.c b/src/nm-device-modem.c
index 441f92c..b88939b 100644
--- a/src/nm-device-modem.c
+++ b/src/nm-device-modem.c
@@ -117,12 +117,13 @@ modem_need_auth (NMModem *modem,
 {
 	NMDeviceModem *self = NM_DEVICE_MODEM (user_data);
 	NMActRequest *req;
+	const char *hints[3] = { hint1, hint2, NULL };
 
 	req = nm_device_get_act_request (NM_DEVICE (self));
 	g_assert (req);
 
 	nm_device_state_changed (NM_DEVICE (self), NM_DEVICE_STATE_NEED_AUTH, NM_DEVICE_STATE_REASON_NONE);
-	nm_act_request_get_secrets (req, setting_name, retry, caller, hint1, hint2);
+	nm_act_request_get_secrets (req, setting_name, retry, caller, hints);
 }
 
 static void
diff --git a/src/nm-device-wifi.c b/src/nm-device-wifi.c
index 4e09026..b3e3351 100644
--- a/src/nm-device-wifi.c
+++ b/src/nm-device-wifi.c
@@ -2428,7 +2428,6 @@ link_timeout_cb (gpointer user_data)
 		                            setting_name,
 		                            TRUE,
 		                            SECRETS_CALLER_WIFI,
-		                            NULL,
 		                            NULL);
 
 		return FALSE;
@@ -2578,6 +2577,8 @@ handle_8021x_auth_fail (NMDeviceWifi *self, guint32 new_state, guint32 old_state
 	}
 
 	if (ask) {
+		const char *hints[2] = { NM_SETTING_802_1X_PASSWORD, NULL };
+
 		nm_connection_clear_secrets (connection);
 		cleanup_association_attempt (self, TRUE);
 
@@ -2590,8 +2591,7 @@ handle_8021x_auth_fail (NMDeviceWifi *self, guint32 new_state, guint32 old_state
 		                            NM_SETTING_802_1X_SETTING_NAME,
 		                            TRUE,
 		                            SECRETS_CALLER_WIFI,
-		                            NM_SETTING_802_1X_PASSWORD,
-		                            NULL);
+		                            hints);
 	}
 
 	return ask;
@@ -2890,7 +2890,6 @@ handle_auth_or_fail (NMDeviceWifi *self,
 		                            setting_name,
 		                            get_new,
 		                            SECRETS_CALLER_WIFI,
-		                            NULL,
 		                            NULL);
 
 		g_object_set_data (G_OBJECT (connection), WIRELESS_SECRETS_TRIES, GUINT_TO_POINTER (++tries));
diff --git a/src/nm-manager.c b/src/nm-manager.c
index f6b10d9..2c310b5 100644
--- a/src/nm-manager.c
+++ b/src/nm-manager.c
@@ -212,10 +212,12 @@ typedef struct {
 
 	GHashTable *user_connections;
 	DBusGProxy *user_proxy;
+	DBusGProxy *user_props_proxy;
 	NMAuthCallResult user_con_perm;
 	NMAuthCallResult user_net_perm;
 	NMAuthCallResult user_wifi_share_open_perm;
 	NMAuthCallResult user_wifi_share_enc_perm;
+	NMSettingsServiceCapabilities user_capabilities;
 
 	GHashTable *system_connections;
 	NMSysconfigSettings *sys_settings;
@@ -1027,12 +1029,18 @@ user_proxy_cleanup (NMManager *self, gboolean resync_bt)
 	priv->user_con_perm = NM_AUTH_CALL_RESULT_UNKNOWN;
 	priv->user_wifi_share_open_perm = NM_AUTH_CALL_RESULT_UNKNOWN;
 	priv->user_wifi_share_enc_perm = NM_AUTH_CALL_RESULT_UNKNOWN;
+	priv->user_capabilities = NM_SETTINGS_SERVICE_CAPABILITY_NONE;
 
 	if (priv->user_proxy) {
 		g_object_unref (priv->user_proxy);
 		priv->user_proxy = NULL;
 	}
 
+	if (priv->user_props_proxy) {
+		g_object_unref (priv->user_props_proxy);
+		priv->user_props_proxy = NULL;
+	}
+
 	if (resync_bt) {
 		/* Resync BT devices since they are generated from connections */
 		bluez_manager_resync_devices (self);
@@ -1381,6 +1389,35 @@ user_settings_authorized (NMManager *self, NMAuthChain *chain)
 }
 
 static void
+user_capabilities_cb  (DBusGProxy *proxy,
+                       DBusGProxyCall *call_id,
+                       gpointer user_data)
+{
+	NMManager *self = NM_MANAGER (user_data);
+	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
+	GError *err = NULL;
+	GValue value = { 0, };
+
+	if (!dbus_g_proxy_end_call (proxy, call_id, &err,
+	                            G_TYPE_VALUE, &value,
+	                            G_TYPE_INVALID)) {
+		nm_log_warn (LOGD_USER_SET, "couldn't retrieve user settings service capabilities: %s",
+		             err && err->message ? err->message : "(unknown)");
+		g_error_free (err);
+		priv->user_capabilities = NM_SETTINGS_SERVICE_CAPABILITY_NONE;
+		return;
+	}
+
+	if (!G_VALUE_HOLDS_UINT (&value)) {
+		nm_log_warn (LOGD_USER_SET, "couldn't retrieve user settings service capabilities: not a UINT");
+		priv->user_capabilities = NM_SETTINGS_SERVICE_CAPABILITY_NONE;
+	} else {
+		priv->user_capabilities = g_value_get_uint (&value);
+	}
+	g_value_unset (&value);
+}
+
+static void
 user_proxy_auth_done (NMAuthChain *chain,
                       GError *error,
                       DBusGMethodInvocation *context,
@@ -1418,6 +1455,15 @@ user_proxy_auth_done (NMAuthChain *chain,
 			              G_CALLBACK (user_proxy_destroyed_cb),
 			              self);
 
+		/* Request capabilities */
+		dbus_g_proxy_begin_call (priv->user_props_proxy, "Get",
+		                         user_capabilities_cb,
+		                         self,
+		                         NULL,
+		                         G_TYPE_STRING, NM_DBUS_IFACE_SETTINGS,
+		                         G_TYPE_STRING, "Capabilities",
+		                         G_TYPE_INVALID);
+
 		/* Request user connections */
 		dbus_g_proxy_begin_call (priv->user_proxy, "ListConnections",
 			                     user_list_connections_cb,
@@ -1463,6 +1509,21 @@ user_proxy_init (NMManager *self)
 		return;
 	}
 
+	priv->user_props_proxy = dbus_g_proxy_new_for_name_owner (bus,
+	                                                          NM_DBUS_SERVICE_USER_SETTINGS,
+	                                                          NM_DBUS_PATH_SETTINGS,
+	                                                          DBUS_INTERFACE_PROPERTIES,
+	                                                          &error);
+	if (!priv->user_props_proxy) {
+		nm_log_err (LOGD_USER_SET, "could not init user settings properties proxy: (%d) %s",
+		            error ? error->code : -1,
+		            error && error->message ? error->message : "(unknown)");
+		g_clear_error (&error);
+		g_object_unref (priv->user_proxy);
+		priv->user_proxy = NULL;
+		return;
+	}
+
 	/* Kick off some PolicyKit authorization requests to figure out what
 	 * permissions this user settings service has.
 	 */
@@ -3116,13 +3177,11 @@ user_get_secrets (NMManager *self,
                   const char *setting_name,
                   gboolean request_new,
                   RequestSecretsCaller caller_id,
-                  const char *hint1,
-                  const char *hint2)
+                  const char **hints)
 {
 	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
 	DBusGConnection *g_connection;
 	GetSecretsInfo *info = NULL;
-	GPtrArray *hints = NULL;
 
 	info = g_malloc0 (sizeof (GetSecretsInfo));
 
@@ -3144,22 +3203,15 @@ user_get_secrets (NMManager *self,
 
 	g_object_weak_ref (G_OBJECT (provider), (GWeakNotify) free_get_secrets_info, info);
 
-	hints = g_ptr_array_sized_new (2);
-	if (hint1)
-		g_ptr_array_add (hints, (char *) hint1);
-	if (hint2)
-		g_ptr_array_add (hints, (char *) hint2);
-
 	info->call = dbus_g_proxy_begin_call_with_timeout (info->proxy, "GetSecrets",
 	                                                   user_get_secrets_cb,
 	                                                   info,
 	                                                   NULL,
 	                                                   G_MAXINT32,
 	                                                   G_TYPE_STRING, setting_name,
-	                                                   DBUS_TYPE_G_ARRAY_OF_STRING, hints,
+	                                                   G_TYPE_STRV, hints,
 	                                                   G_TYPE_BOOLEAN, request_new,
 	                                                   G_TYPE_INVALID);
-	g_ptr_array_free (hints, TRUE);
 	return info;
 }
 
@@ -3228,8 +3280,7 @@ system_get_secrets (NMManager *self,
                     const char *setting_name,
                     gboolean request_new,
                     RequestSecretsCaller caller_id,
-                    const char *hint1,
-                    const char *hint2)
+                    const char **hints)
 {
 	GetSecretsInfo *info;
 
@@ -3238,8 +3289,8 @@ system_get_secrets (NMManager *self,
 	info->provider = provider;
 	info->caller = caller_id;
 	info->setting_name = g_strdup (setting_name);
-	info->hint1 = hint1 ? g_strdup (hint1) : NULL;
-	info->hint2 = hint2 ? g_strdup (hint2) : NULL;
+	info->hint1 = (hints && hints[0]) ? g_strdup (hints[0]) : NULL;
+	info->hint2 = (hints && hints[0] && hints[1]) ? g_strdup (hints[1]) : NULL;
 	info->connection_path = g_strdup (nm_connection_get_path (connection));
 	info->request_new = request_new;
 
@@ -3258,8 +3309,7 @@ provider_get_secrets (NMSecretsProviderInterface *provider,
                       const char *setting_name,
                       gboolean request_new,
                       RequestSecretsCaller caller_id,
-                      const char *hint1,
-                      const char *hint2,
+                      const char **hints,
                       gpointer user_data)
 {
 	NMManager *self = NM_MANAGER (user_data);
@@ -3285,10 +3335,10 @@ provider_get_secrets (NMSecretsProviderInterface *provider,
 	scope = nm_connection_get_scope (connection);
 	if (scope == NM_CONNECTION_SCOPE_SYSTEM) {
 		info = system_get_secrets (self, provider, connection, setting_name,
-		                           request_new, caller_id, hint1, hint2);
+		                           request_new, caller_id, hints);
 	} else if (scope == NM_CONNECTION_SCOPE_USER) {
 		info = user_get_secrets (self, provider, connection, setting_name,
-		                         request_new, caller_id, hint1, hint2);
+		                         request_new, caller_id, hints);
 	}
 
 	if (info)
@@ -3737,6 +3787,7 @@ activate_vpn_connection (NMManager *manager,
 	                                                     connection,
 	                                                     req,
 	                                                     device,
+	                                                     (priv->user_capabilities & NM_SETTINGS_SERVICE_CAPABILITY_VPN_HINTS),
 	                                                     error);
 	g_signal_connect (vpn_connection, "manager-get-secrets",
 	                  G_CALLBACK (provider_get_secrets), manager);
diff --git a/src/nm-secrets-provider-interface.c b/src/nm-secrets-provider-interface.c
index 47b8e57..51b09a9 100644
--- a/src/nm-secrets-provider-interface.c
+++ b/src/nm-secrets-provider-interface.c
@@ -43,9 +43,9 @@ nm_secrets_provider_interface_init (gpointer g_iface)
 	              G_SIGNAL_RUN_LAST,
 	              G_STRUCT_OFFSET (NMSecretsProviderInterface, manager_get_secrets),
 	              NULL, NULL,
-	              _nm_marshal_BOOLEAN__POINTER_STRING_BOOLEAN_UINT_STRING_STRING,
-	              G_TYPE_BOOLEAN, 6,
-	              G_TYPE_POINTER, G_TYPE_STRING, G_TYPE_BOOLEAN, G_TYPE_UINT, G_TYPE_STRING, G_TYPE_STRING);
+	              _nm_marshal_BOOLEAN__POINTER_STRING_BOOLEAN_UINT_POINTER,
+	              G_TYPE_BOOLEAN, 5,
+	              G_TYPE_POINTER, G_TYPE_STRING, G_TYPE_BOOLEAN, G_TYPE_UINT, G_TYPE_STRV);
 
 	g_signal_new ("manager-cancel-secrets",
 	              iface_type,
@@ -91,8 +91,7 @@ nm_secrets_provider_interface_get_secrets (NMSecretsProviderInterface *self,
                                            const char *setting_name,
                                            gboolean request_new,
                                            RequestSecretsCaller caller,
-                                           const char *hint1,
-                                           const char *hint2)
+                                           const char **hints)
 {
 	guint success = FALSE;
 
@@ -105,7 +104,7 @@ nm_secrets_provider_interface_get_secrets (NMSecretsProviderInterface *self,
 	nm_secrets_provider_interface_cancel_get_secrets (self);
 
 	g_signal_emit_by_name (self, "manager-get-secrets",
-	                       connection, setting_name, request_new, caller, hint1, hint2,
+	                       connection, setting_name, request_new, caller, hints,
 	                       &success);
 	if (!success) {
 		nm_log_warn (LOGD_CORE, "failed to get connection secrets.");
diff --git a/src/nm-secrets-provider-interface.h b/src/nm-secrets-provider-interface.h
index 3d9e08b..fb453c6 100644
--- a/src/nm-secrets-provider-interface.h
+++ b/src/nm-secrets-provider-interface.h
@@ -60,8 +60,7 @@ struct _NMSecretsProviderInterface {
 	                                const char *setting_name,
 	                                gboolean request_new,
 	                                RequestSecretsCaller caller,
-	                                const char *hint1,
-	                                const char *hint2);
+	                                const char **hints);
 
 	void (*manager_cancel_secrets) (NMSecretsProviderInterface *self);
 };
@@ -74,8 +73,7 @@ gboolean nm_secrets_provider_interface_get_secrets    (NMSecretsProviderInterfac
                                                        const char *setting_name,
                                                        gboolean request_new,
                                                        RequestSecretsCaller caller,
-                                                       const char *hint1,
-                                                       const char *hint2);
+                                                       const char **hints);
 
 void nm_secrets_provider_interface_cancel_get_secrets (NMSecretsProviderInterface *self);
 
diff --git a/src/ppp-manager/nm-ppp-manager.c b/src/ppp-manager/nm-ppp-manager.c
index 148ad2c..2453665 100644
--- a/src/ppp-manager/nm-ppp-manager.c
+++ b/src/ppp-manager/nm-ppp-manager.c
@@ -342,8 +342,8 @@ impl_ppp_manager_need_secrets (NMPPPManager *manager,
 	const char *connection_type;
 	const char *setting_name;
 	guint32 tries;
-	GPtrArray *hints = NULL;
-	const char *hint1 = NULL, *hint2 = NULL;
+	GPtrArray *connection_hints = NULL;
+	const char *hints[3] = { NULL, NULL, NULL };
 
 	connection = nm_act_request_get_connection (priv->act_req);
 
@@ -354,7 +354,7 @@ impl_ppp_manager_need_secrets (NMPPPManager *manager,
 	g_assert (connection_type);
 
 	nm_connection_clear_secrets (connection);
-	setting_name = nm_connection_need_secrets (connection, &hints);
+	setting_name = nm_connection_need_secrets (connection, &connection_hints);
 	if (!setting_name) {
 		NMSetting *setting;
 
@@ -396,11 +396,11 @@ impl_ppp_manager_need_secrets (NMPPPManager *manager,
 	}
 
 	/* Extract hints */
-	if (hints) {
-		if (hints->len > 0)
-			hint1 = g_ptr_array_index (hints, 0);
-		if (hints->len > 1)
-			hint2 = g_ptr_array_index (hints, 1);
+	if (connection_hints) {
+		if (connection_hints->len > 0)
+			hints[0] = g_ptr_array_index (connection_hints, 0);
+		if (connection_hints->len > 1)
+			hints[1] = g_ptr_array_index (connection_hints, 1);
 	}
 
 	tries = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (connection), PPP_MANAGER_SECRET_TRIES));
@@ -412,13 +412,12 @@ impl_ppp_manager_need_secrets (NMPPPManager *manager,
 	                            setting_name,
 	                            tries > 1 ? TRUE : FALSE,
 	                            SECRETS_CALLER_PPP,
-	                            hint1,
-	                            hint2);
+	                            hints);
 	g_object_set_data (G_OBJECT (connection), PPP_MANAGER_SECRET_TRIES, GUINT_TO_POINTER (++tries));
 	priv->pending_secrets_context = context;
 
-	if (hints)
-		g_ptr_array_free (hints, TRUE);
+	if (connection_hints)
+		g_ptr_array_free (connection_hints, TRUE);
 }
 
 static gboolean impl_ppp_manager_set_state (NMPPPManager *manager,
diff --git a/src/vpn-manager/nm-vpn-connection.c b/src/vpn-manager/nm-vpn-connection.c
index dc56daf..949d80b 100644
--- a/src/vpn-manager/nm-vpn-connection.c
+++ b/src/vpn-manager/nm-vpn-connection.c
@@ -62,6 +62,8 @@ typedef struct {
 	NMConnection *connection;
 
 	NMActRequest *act_request;
+	gboolean interactive_allowed;
+	gboolean interactive_used;
 
 	NMDevice *parent_dev;
 	gulong device_monitor;
@@ -70,7 +72,8 @@ typedef struct {
 	NMVPNConnectionState vpn_state;
 	NMVPNConnectionStateReason failure_reason;
 	DBusGProxy *proxy;
-	guint ipconfig_timeout;
+	GHashTable *connect_hash;
+	guint connect_timeout;
 	NMIP4Config *ip4_config;
 	guint32 ip4_internal_gw;
 	char *ip_iface;
@@ -98,6 +101,16 @@ enum {
 	LAST_PROP
 };
 
+static void plugin_interactive_secrets_required (DBusGProxy *proxy,
+                                                 const char *message,
+                                                 const char **secrets,
+                                                 gpointer user_data);
+
+static void connection_need_secrets_cb  (DBusGProxy *proxy,
+                                         char *setting_name,
+                                         GError *error,
+                                         gpointer user_data);
+
 static void
 nm_vpn_connection_set_vpn_state (NMVPNConnection *connection,
                                  NMVPNConnectionState vpn_state,
@@ -201,7 +214,8 @@ device_ip4_config_changed (NMDevice *device,
 NMVPNConnection *
 nm_vpn_connection_new (NMConnection *connection,
                        NMActRequest *act_request,
-                       NMDevice *parent_device)
+                       NMDevice *parent_device,
+                       gboolean vpn_hints_supported)
 {
 	NMVPNConnection *self;
 	NMVPNConnectionPrivate *priv;
@@ -219,6 +233,7 @@ nm_vpn_connection_new (NMConnection *connection,
 	priv->connection = g_object_ref (connection);
 	priv->parent_dev = g_object_ref (parent_device);
 	priv->act_request = g_object_ref (act_request);
+	priv->interactive_allowed = vpn_hints_supported;
 
 	priv->device_monitor = g_signal_connect (parent_device, "state-changed",
 									 G_CALLBACK (device_state_changed),
@@ -391,8 +406,14 @@ nm_vpn_connection_ip4_config_get (DBusGProxy *proxy,
 	nm_log_info (LOGD_VPN, "VPN connection '%s' (IP Config Get) reply received.",
 	             nm_vpn_connection_get_name (connection));
 
-	g_source_remove (priv->ipconfig_timeout);
-	priv->ipconfig_timeout = 0;
+	g_source_remove (priv->connect_timeout);
+	priv->connect_timeout = 0;
+
+	if (nm_vpn_connection_get_vpn_state (connection) == NM_VPN_CONNECTION_STATE_CONNECT) {
+		nm_vpn_connection_set_vpn_state (connection,
+		                                 NM_VPN_CONNECTION_STATE_IP_CONFIG_GET,
+		                                 NM_VPN_CONNECTION_STATE_REASON_NONE);
+	}
 
 	config = nm_ip4_config_new ();
 
@@ -539,19 +560,20 @@ error:
 }
 
 static gboolean
-nm_vpn_connection_ip_config_timeout (gpointer user_data)
+connect_timeout_cb (gpointer user_data)
 {
 	NMVPNConnection *connection = NM_VPN_CONNECTION (user_data);
 	NMVPNConnectionPrivate *priv = NM_VPN_CONNECTION_GET_PRIVATE (connection);
+	NMVPNConnectionState state;
 
-	priv->ipconfig_timeout = 0;
+	priv->connect_timeout = 0;
 
-	/* If the activation request's state is still IP_CONFIG_GET and we're
-	 * in this timeout, cancel activation because it's taken too long.
-	 */
-	if (nm_vpn_connection_get_vpn_state (connection) == NM_VPN_CONNECTION_STATE_IP_CONFIG_GET) {
-		nm_log_warn (LOGD_VPN, "VPN connection '%s' (IP Config Get) timeout exceeded.",
-		             nm_vpn_connection_get_name (connection));
+	/* Cancel activation if it's taken too long */
+	state = nm_vpn_connection_get_vpn_state (connection);
+	if (state == NM_VPN_CONNECTION_STATE_CONNECT ||
+	    state == NM_VPN_CONNECTION_STATE_IP_CONFIG_GET) {
+		nm_log_warn (LOGD_VPN, "VPN connection '%s' connect timeout exceeded.",
+		             nm_connection_get_id (priv->connection));
 		nm_vpn_connection_set_vpn_state (connection,
 		                                 NM_VPN_CONNECTION_STATE_FAILED,
 		                                 NM_VPN_CONNECTION_STATE_REASON_CONNECT_TIMEOUT);
@@ -561,34 +583,70 @@ nm_vpn_connection_ip_config_timeout (gpointer user_data)
 }
 
 static void
-nm_vpn_connection_connect_cb (DBusGProxy *proxy, GError *err, gpointer user_data)
+connect_success (NMVPNConnection *connection)
 {
-	NMVPNConnection *connection = NM_VPN_CONNECTION (user_data);
 	NMVPNConnectionPrivate *priv = NM_VPN_CONNECTION_GET_PRIVATE (connection);
 
+	/* 40 second timeout waiting for IP config signal from VPN service */
+	priv->connect_timeout = g_timeout_add_seconds (40, connect_timeout_cb, connection);
+
+	g_hash_table_destroy (priv->connect_hash);
+	priv->connect_hash = NULL;
+}
+
+static void
+connect_cb (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
+{
+	NMVPNConnection *self = NM_VPN_CONNECTION (user_data);
+	NMVPNConnectionPrivate *priv = NM_VPN_CONNECTION_GET_PRIVATE (self);
+	GError *err = NULL;
+
 	nm_log_info (LOGD_VPN, "VPN connection '%s' (Connect) reply received.",
-	             nm_vpn_connection_get_name (connection));
+	             nm_connection_get_id (priv->connection));
 
-	if (err) {
-		nm_log_warn (LOGD_VPN, "VPN connection '%s' failed to connect: '%s'.", 
-		             nm_vpn_connection_get_name (connection), err->message);
-		nm_vpn_connection_set_vpn_state (connection,
-		                                 NM_VPN_CONNECTION_STATE_FAILED,
-		                                 NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED);
-	} else {
-		nm_vpn_connection_set_vpn_state (connection,
-		                                 NM_VPN_CONNECTION_STATE_IP_CONFIG_GET,
-		                                 NM_VPN_CONNECTION_STATE_REASON_NONE);
-		
-		/* 40 second timeout waiting for IP config signal from VPN service */
-		priv->ipconfig_timeout = g_timeout_add_seconds (40, nm_vpn_connection_ip_config_timeout, connection);
+	dbus_g_proxy_end_call (proxy, call, &err, G_TYPE_INVALID);
+	if (!err) {
+		connect_success (self);
+		return;
+	}
+
+	nm_log_warn (LOGD_VPN, "VPN connection '%s' failed to connect: '%s'.", 
+	             nm_connection_get_id (priv->connection), err->message);
+	g_error_free (err);
+	nm_vpn_connection_set_vpn_state (self,
+	                                 NM_VPN_CONNECTION_STATE_FAILED,
+	                                 NM_VPN_CONNECTION_STATE_REASON_SERVICE_START_FAILED);
+}
+
+static void
+connect_interactive_cb (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
+{
+	NMVPNConnection *self = NM_VPN_CONNECTION (user_data);
+	NMVPNConnectionPrivate *priv = NM_VPN_CONNECTION_GET_PRIVATE (self);
+	GError *err = NULL;
+
+	nm_log_info (LOGD_VPN, "VPN connection '%s' (ConnectInteractive) reply received.",
+	             nm_connection_get_id (priv->connection));
+
+	dbus_g_proxy_end_call (proxy, call, &err, G_TYPE_INVALID);
+	if (!err) {
+		connect_success (self);
+		return;
 	}
+
+	/* Fall back to Connect() */
+	priv->interactive_used = FALSE;
+	dbus_g_proxy_begin_call (priv->proxy, "Connect",
+	                         connect_cb, self, NULL,
+	                         DBUS_TYPE_G_MAP_OF_MAP_OF_VARIANT, priv->connect_hash,
+	                         G_TYPE_INVALID);
 }
 
 static void
 really_activate (NMVPNConnection *connection)
 {
 	NMVPNConnectionPrivate *priv;
+	GHashTable *details;
 
 	g_return_if_fail (NM_IS_VPN_CONNECTION (connection));
 	g_return_if_fail (nm_vpn_connection_get_vpn_state (connection) == NM_VPN_CONNECTION_STATE_NEED_AUTH);
@@ -597,18 +655,39 @@ really_activate (NMVPNConnection *connection)
 
 	/* Ip4Config signal */
 	dbus_g_object_register_marshaller (g_cclosure_marshal_VOID__BOXED,
-								G_TYPE_NONE, G_TYPE_VALUE, G_TYPE_INVALID);
-	dbus_g_proxy_add_signal (priv->proxy, "Ip4Config",
-						DBUS_TYPE_G_MAP_OF_VARIANT,
-						G_TYPE_INVALID);
+	                                   G_TYPE_NONE, G_TYPE_VALUE, G_TYPE_INVALID);
+	dbus_g_proxy_add_signal (priv->proxy, "Ip4Config", DBUS_TYPE_G_MAP_OF_VARIANT, G_TYPE_INVALID);
 	dbus_g_proxy_connect_signal (priv->proxy, "Ip4Config",
-						    G_CALLBACK (nm_vpn_connection_ip4_config_get),
-						    connection, NULL);
+	                             G_CALLBACK (nm_vpn_connection_ip4_config_get),
+	                             connection, NULL);
+
+	if (priv->connect_hash)
+		g_hash_table_destroy (priv->connect_hash);
+	priv->connect_hash = nm_connection_to_hash (priv->connection);
+	details = g_hash_table_new (g_str_hash, g_str_equal);
 
-	org_freedesktop_NetworkManager_VPN_Plugin_connect_async (priv->proxy,
-												  nm_connection_to_hash (priv->connection),
-												  nm_vpn_connection_connect_cb,
-												  connection);
+	/* If the user settings service doesn't support VPN hints, then we can't use
+	 * ConnectInteractive(), because the service won't be able to pass hints
+	 * from the VPN plugin's interactive secrets requests to the VPN authentication
+	 * dialog and we won't get the secrets we need.  In this case fall back to
+	 * the old Connect() call.
+	 */
+	priv->interactive_used = priv->interactive_allowed;
+	if (priv->interactive_allowed) {
+		nm_log_dbg (LOGD_VPN, "Allowing interactive secrets as all agents have that capability");
+		dbus_g_proxy_begin_call (priv->proxy, "ConnectInteractive",
+		                         connect_interactive_cb, connection, NULL,
+		                         DBUS_TYPE_G_MAP_OF_MAP_OF_VARIANT, priv->connect_hash,
+		                         DBUS_TYPE_G_MAP_OF_VARIANT, details,
+		                         G_TYPE_INVALID);
+	} else {
+		nm_log_dbg (LOGD_VPN, "Calling old Connect function as not all agents support interactive secrets");
+		dbus_g_proxy_begin_call (priv->proxy, "Connect",
+		                         connect_cb, connection, NULL,
+		                         DBUS_TYPE_G_MAP_OF_MAP_OF_VARIANT, priv->connect_hash,
+		                         G_TYPE_INVALID);
+	}
+	g_hash_table_destroy (details);
 
 	nm_vpn_connection_set_vpn_state (connection,
 	                                 NM_VPN_CONNECTION_STATE_CONNECT,
@@ -620,6 +699,7 @@ nm_vpn_connection_activate (NMVPNConnection *connection)
 {
 	NMVPNConnectionPrivate *priv;
 	NMDBusManager *dbus_mgr;
+	GHashTable *hash;
 
 	g_return_if_fail (NM_IS_VPN_CONNECTION (connection));
 	g_return_if_fail (nm_vpn_connection_get_vpn_state (connection) == NM_VPN_CONNECTION_STATE_PREPARE);
@@ -644,9 +724,24 @@ nm_vpn_connection_activate (NMVPNConnection *connection)
 	                             G_CALLBACK (plugin_state_changed),
 	                             connection, NULL);
 
+	dbus_g_object_register_marshaller (_nm_marshal_VOID__STRING_POINTER,
+	                                   G_TYPE_NONE, G_TYPE_STRING, G_TYPE_STRV, G_TYPE_INVALID);
+	dbus_g_proxy_add_signal (priv->proxy, "SecretsRequired", G_TYPE_STRING, G_TYPE_STRV, G_TYPE_INVALID);
+	dbus_g_proxy_connect_signal (priv->proxy, "SecretsRequired",
+	                             G_CALLBACK (plugin_interactive_secrets_required),
+	                             connection, NULL);
+
 	nm_vpn_connection_set_vpn_state (connection,
 	                                 NM_VPN_CONNECTION_STATE_NEED_AUTH,
 	                                 NM_VPN_CONNECTION_STATE_REASON_NONE);
+
+	/* Kick off the first secrets check */
+	hash = nm_connection_to_hash (priv->connection);
+	org_freedesktop_NetworkManager_VPN_Plugin_need_secrets_async (priv->proxy,
+	                                                              hash,
+	                                                              connection_need_secrets_cb,
+	                                                              connection);
+	g_hash_table_destroy (hash);
 }
 
 const char *
@@ -776,6 +871,24 @@ secrets_update_setting (NMSecretsProviderInterface *interface,
 }
 
 static void
+plugin_new_secrets_cb  (DBusGProxy *proxy, DBusGProxyCall *call, void *user_data)
+{
+	NMVPNConnection *self = NM_VPN_CONNECTION (user_data);
+	NMVPNConnectionPrivate *priv = NM_VPN_CONNECTION_GET_PRIVATE (self);
+	GError *error = NULL;
+
+	if (!dbus_g_proxy_end_call (proxy, call, &error, G_TYPE_INVALID)) {
+		nm_log_err (LOGD_VPN, "(%s/%s) sending new secrets to the plugin failed: %s %s",
+		            nm_connection_get_uuid (priv->connection),
+		            nm_connection_get_id (priv->connection),
+		            g_quark_to_string (error->domain),
+		            error->message);
+		nm_vpn_connection_fail (self, NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS);
+		g_error_free (error);
+	}
+}
+
+static void
 secrets_result (NMSecretsProviderInterface *interface,
 	            const char *setting_name,
 	            RequestSecretsCaller caller,
@@ -784,13 +897,27 @@ secrets_result (NMSecretsProviderInterface *interface,
 {
 	NMVPNConnection *self = NM_VPN_CONNECTION (interface);
 	NMVPNConnectionPrivate *priv = NM_VPN_CONNECTION_GET_PRIVATE (self);
+	GHashTable *hash;
 
 	g_return_if_fail (priv->connection != NULL);
 	g_return_if_fail (caller == SECRETS_CALLER_VPN);
 
 	if (error)
 		nm_vpn_connection_fail (self, NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS);
-	else
+	else if (priv->interactive_used) {
+		/* Send the new secrets back to the VPN service */
+		nm_log_dbg (LOGD_VPN, "(%s/%s) sending secrets to the plugin",
+		            nm_connection_get_uuid (priv->connection),
+		            nm_connection_get_id (priv->connection));
+
+		/* Send the secrets back to the plugin */
+		hash = nm_connection_to_hash (priv->connection);
+		dbus_g_proxy_begin_call (priv->proxy, "NewSecrets",
+		                         plugin_new_secrets_cb, self, NULL,
+		                         DBUS_TYPE_G_MAP_OF_MAP_OF_VARIANT, hash,
+		                         G_TYPE_INVALID);
+		g_hash_table_destroy (hash);
+	} else
 		really_activate (self);
 }
 
@@ -831,27 +958,11 @@ connection_need_secrets_cb  (DBusGProxy *proxy,
                                                     setting_name,
                                                     FALSE,
                                                     SECRETS_CALLER_VPN,
-                                                    NULL,
                                                     NULL))
 		nm_vpn_connection_fail (self, NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS);
 }
 
 static void
-call_need_secrets (NMVPNConnection *vpn_connection)
-{
-	NMVPNConnectionPrivate *priv;
-	GHashTable *settings;
-
-	priv = NM_VPN_CONNECTION_GET_PRIVATE (vpn_connection);
-	settings = nm_connection_to_hash (priv->connection);
-	org_freedesktop_NetworkManager_VPN_Plugin_need_secrets_async (priv->proxy,
-	                         settings,
-	                         connection_need_secrets_cb,
-	                         vpn_connection);
-	g_hash_table_destroy (settings);
-}
-
-static void
 vpn_cleanup (NMVPNConnection *connection)
 {
 	NMVPNConnectionPrivate *priv = NM_VPN_CONNECTION_GET_PRIVATE (connection);
@@ -920,9 +1031,6 @@ connection_state_changed (NMVPNConnection *connection,
 	nm_secrets_provider_interface_cancel_get_secrets (NM_SECRETS_PROVIDER_INTERFACE (priv->act_request));
 
 	switch (state) {
-	case NM_VPN_CONNECTION_STATE_NEED_AUTH:
-		call_need_secrets (connection);
-		break;
 	case NM_VPN_CONNECTION_STATE_DISCONNECTED:
 	case NM_VPN_CONNECTION_STATE_FAILED:
 		if (priv->proxy) {
@@ -945,6 +1053,49 @@ connection_state_changed (NMVPNConnection *connection,
 }
 
 static void
+plugin_interactive_secrets_required (DBusGProxy *proxy,
+                                     const char *message,
+                                     const char **secrets,
+                                     gpointer user_data)
+{
+	NMVPNConnection *connection = NM_VPN_CONNECTION (user_data);
+	NMVPNConnectionPrivate *priv = NM_VPN_CONNECTION_GET_PRIVATE (connection);
+	guint32 secrets_len = secrets ? g_strv_length ((char **) secrets) : 0;
+	char **hints;
+	guint32 i;
+
+	g_warn_if_fail (priv->interactive_used == TRUE);
+
+	nm_log_info (LOGD_VPN, "VPN plugin requested secrets; state %d", priv->vpn_state);
+
+	g_return_if_fail (priv->vpn_state == NM_VPN_CONNECTION_STATE_CONNECT ||
+	                  priv->vpn_state == NM_VPN_CONNECTION_STATE_NEED_AUTH);
+
+	nm_vpn_connection_set_vpn_state (connection,
+	                                 NM_VPN_CONNECTION_STATE_NEED_AUTH,
+	                                 NM_VPN_CONNECTION_STATE_REASON_NONE);
+
+	/* Copy hints and add message to the end */
+	hints = g_malloc0 (sizeof (char *) * (secrets_len + 2));
+	for (i = 0; i < secrets_len; i++)
+		hints[i] = g_strdup (secrets[i]);
+	if (message)
+		hints[i] = g_strdup_printf ("x-vpn-message:%s", message);
+
+	/* Get the secrets the VPN plugin wants */
+	if (!nm_secrets_provider_interface_get_secrets (NM_SECRETS_PROVIDER_INTERFACE (connection),
+	                                                priv->connection,
+	                                                NM_SETTING_VPN_SETTING_NAME,
+	                                                FALSE,
+	                                                SECRETS_CALLER_VPN,
+	                                                (const char **) hints))
+		nm_vpn_connection_fail (connection, NM_VPN_CONNECTION_STATE_REASON_NO_SECRETS);
+	g_strfreev (hints);
+}
+
+/******************************************************************************/
+
+static void
 nm_vpn_connection_init (NMVPNConnection *self)
 {
 	NM_VPN_CONNECTION_GET_PRIVATE (self)->vpn_state = NM_VPN_CONNECTION_STATE_PREPARE;
@@ -961,6 +1112,9 @@ dispose (GObject *object)
 	}
 	priv->disposed = TRUE;
 
+	if (priv->connect_hash)
+		g_hash_table_destroy (priv->connect_hash);
+
 	if (priv->gw_route)
 		rtnl_route_put (priv->gw_route);
 
@@ -975,8 +1129,8 @@ dispose (GObject *object)
 	if (priv->ip4_config)
 		g_object_unref (priv->ip4_config);
 
-	if (priv->ipconfig_timeout)
-		g_source_remove (priv->ipconfig_timeout);
+	if (priv->connect_timeout)
+		g_source_remove (priv->connect_timeout);
 
 	if (priv->proxy)
 		g_object_unref (priv->proxy);
diff --git a/src/vpn-manager/nm-vpn-connection.h b/src/vpn-manager/nm-vpn-connection.h
index ab880b1..d3080af 100644
--- a/src/vpn-manager/nm-vpn-connection.h
+++ b/src/vpn-manager/nm-vpn-connection.h
@@ -59,7 +59,8 @@ GType nm_vpn_connection_get_type (void);
 
 NMVPNConnection * nm_vpn_connection_new (NMConnection *connection,
                                          NMActRequest *act_request,
-                                         NMDevice *parent_device);
+                                         NMDevice *parent_device,
+                                         gboolean vpn_hints_supported);
 
 void                 nm_vpn_connection_activate        (NMVPNConnection *connection);
 NMConnection *       nm_vpn_connection_get_connection  (NMVPNConnection *connection);
diff --git a/src/vpn-manager/nm-vpn-manager.c b/src/vpn-manager/nm-vpn-manager.c
index 309331a..af20a0f 100644
--- a/src/vpn-manager/nm-vpn-manager.c
+++ b/src/vpn-manager/nm-vpn-manager.c
@@ -164,6 +164,7 @@ nm_vpn_manager_activate_connection (NMVPNManager *manager,
                                     NMConnection *connection,
                                     NMActRequest *act_request,
                                     NMDevice *device,
+                                    gboolean vpn_hints_supported,
                                     GError **error)
 {
 	NMSettingVPN *vpn_setting;
@@ -208,7 +209,7 @@ nm_vpn_manager_activate_connection (NMVPNManager *manager,
 	}
 
 	if (service) {
-		vpn = nm_vpn_service_activate (service, connection, act_request, device, error);
+		vpn = nm_vpn_service_activate (service, connection, act_request, device, vpn_hints_supported, error);
 		if (vpn) {
 			g_signal_connect (vpn, "vpn-state-changed",
 			                  G_CALLBACK (connection_vpn_state_changed),
diff --git a/src/vpn-manager/nm-vpn-manager.h b/src/vpn-manager/nm-vpn-manager.h
index f14844a..de76f40 100644
--- a/src/vpn-manager/nm-vpn-manager.h
+++ b/src/vpn-manager/nm-vpn-manager.h
@@ -71,6 +71,7 @@ NMVPNConnection *nm_vpn_manager_activate_connection (NMVPNManager *manager,
                                                      NMConnection *connection,
                                                      NMActRequest *act_request,
                                                      NMDevice *device,
+                                                     gboolean vpn_hints_supported,
                                                      GError **error);
 
 gboolean nm_vpn_manager_deactivate_connection (NMVPNManager *manager,
diff --git a/src/vpn-manager/nm-vpn-service.c b/src/vpn-manager/nm-vpn-service.c
index bdbb377..81d401f 100644
--- a/src/vpn-manager/nm-vpn-service.c
+++ b/src/vpn-manager/nm-vpn-service.c
@@ -311,6 +311,7 @@ nm_vpn_service_activate (NMVPNService *service,
                          NMConnection *connection,
                          NMActRequest *act_request,
                          NMDevice *device,
+                         gboolean vpn_hints_supported,
                          GError **error)
 {
 	NMVPNConnection *vpn;
@@ -325,7 +326,7 @@ nm_vpn_service_activate (NMVPNService *service,
 
 	priv = NM_VPN_SERVICE_GET_PRIVATE (service);
 
-	vpn = nm_vpn_connection_new (connection, act_request, device);
+	vpn = nm_vpn_connection_new (connection, act_request, device, vpn_hints_supported);
 	g_signal_connect (vpn, "vpn-state-changed",
 				   G_CALLBACK (connection_vpn_state_changed),
 				   service);
diff --git a/src/vpn-manager/nm-vpn-service.h b/src/vpn-manager/nm-vpn-service.h
index 9c5e0ee..3f7c35e 100644
--- a/src/vpn-manager/nm-vpn-service.h
+++ b/src/vpn-manager/nm-vpn-service.h
@@ -53,6 +53,7 @@ NMVPNConnection * nm_vpn_service_activate (NMVPNService *service,
                                            NMConnection *connection,
                                            NMActRequest *act_request,
                                            NMDevice *device,
+                                           gboolean vpn_hints_supported,
                                            GError **error);
 
 GSList * nm_vpn_service_get_active_connections (NMVPNService *service);
diff -up NetworkManager-0.8.1/libnm-glib/Makefile.am.foo NetworkManager-0.8.1/libnm-glib/Makefile.am
--- NetworkManager-0.8.1/libnm-glib/Makefile.am.foo	2013-09-12 09:10:58.266830985 -0500
+++ NetworkManager-0.8.1/libnm-glib/Makefile.am	2013-09-12 09:11:44.276252625 -0500
@@ -144,7 +144,7 @@ libnm_glib_la_LIBADD = \
 	$(GUDEV_LIBS)
 
 libnm_glib_la_LDFLAGS = -Wl,--version-script=$(srcdir)/libnm-glib.ver \
-	-version-info "8:0:6"
+	-version-info "9:0:7"
 
 noinst_PROGRAMS = libnm-glib-test
 
@@ -157,7 +157,7 @@ libnm_glib_vpn_la_SOURCES = nm-vpn-plugi
 libnm_glib_vpn_la_CFLAGS = $(GLIB_CFLAGS) $(DBUS_CFLAGS)
 libnm_glib_vpn_la_LIBADD = $(top_builddir)/libnm-util/libnm-util.la $(GLIB_LIBS) $(DBUS_LIBS)
 libnm_glib_vpn_la_LDFLAGS = -Wl,--version-script=$(srcdir)/libnm-glib-vpn.ver \
-	-version-info "1:0:0"
+	-version-info "2:0:1"
 
 
 nm-client-bindings.h: $(top_srcdir)/introspection/nm-manager-client.xml
