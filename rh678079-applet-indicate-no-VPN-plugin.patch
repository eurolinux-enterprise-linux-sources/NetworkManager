From 61f10916983e185ad3a18887d89c5d0d3d208367 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ji=C5=99=C3=AD=20Klime=C5=A1?= <jklimes@redhat.com>
Date: Tue, 6 May 2014 11:02:47 +0200
Subject: [PATCH] Move vpn-helpers to dedicated directory to be usable in nm-applet
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit


Signed-off-by: Jiří Klimeš <jklimes@redhat.com>
---
 network-manager-applet-0.8.1/configure.ac          |   1 +
 network-manager-applet-0.8.1/src/Makefile.am       |   4 +-
 .../src/connection-editor/Makefile.am              |   4 +-
 .../src/connection-editor/vpn-helpers.c            | 386 ---------------------
 .../src/connection-editor/vpn-helpers.h            |  42 ---
 .../src/vpn-helpers/Makefile.am                    |  25 ++
 .../src/vpn-helpers/vpn-helpers.c                  | 386 +++++++++++++++++++++
 .../src/vpn-helpers/vpn-helpers.h                  |  42 +++
 8 files changed, 459 insertions(+), 431 deletions(-)
 delete mode 100644 network-manager-applet-0.8.1/src/connection-editor/vpn-helpers.c
 delete mode 100644 network-manager-applet-0.8.1/src/connection-editor/vpn-helpers.h
 create mode 100644 network-manager-applet-0.8.1/src/vpn-helpers/Makefile.am
 create mode 100644 network-manager-applet-0.8.1/src/vpn-helpers/vpn-helpers.c
 create mode 100644 network-manager-applet-0.8.1/src/vpn-helpers/vpn-helpers.h

diff --git a/network-manager-applet-0.8.1/configure.ac b/network-manager-applet-0.8.1/configure.ac
index 7f1021d..e488f53 100644
--- a/network-manager-applet-0.8.1/configure.ac
+++ b/network-manager-applet-0.8.1/configure.ac
@@ -120,6 +120,7 @@ src/marshallers/Makefile
 src/utils/Makefile
 src/utils/tests/Makefile
 src/gconf-helpers/Makefile
+src/vpn-helpers/Makefile
 src/wireless-security/Makefile
 src/connection-editor/Makefile
 src/gnome-bluetooth/Makefile
diff --git a/network-manager-applet-0.8.1/src/Makefile.am b/network-manager-applet-0.8.1/src/Makefile.am
index 432198e..4665510 100644
--- a/network-manager-applet-0.8.1/src/Makefile.am
+++ b/network-manager-applet-0.8.1/src/Makefile.am
@@ -1,4 +1,4 @@
-SUBDIRS = marshallers utils gconf-helpers wireless-security connection-editor gnome-bluetooth
+SUBDIRS = marshallers utils gconf-helpers vpn-helpers wireless-security connection-editor gnome-bluetooth
 
 bin_PROGRAMS = nm-applet
 
@@ -22,6 +22,7 @@ nm_applet_CPPFLAGS = \
 	-I${top_builddir}/src/marshallers \
 	-I${top_srcdir}/src/utils \
 	-I${top_srcdir}/src/gconf-helpers  \
+	-I${top_srcdir}/src/vpn-helpers  \
 	-I${top_srcdir}/src/wireless-security
 
 nm_applet_SOURCES =			\
@@ -70,6 +71,7 @@ nm_applet_LDADD = \
 	${top_builddir}/src/marshallers/libmarshallers.la \
 	${top_builddir}/src/utils/libutils.la \
 	${top_builddir}/src/gconf-helpers/libgconf-helpers.la \
+	${top_builddir}/src/vpn-helpers/libvpn-helpers.la \
 	${top_builddir}/src/wireless-security/libwireless-security.la \
 	-L${top_srcdir}/../libnm-util $(top_builddir)/../libnm-util/libnm-util.la \
 	-L${top_srcdir}/../libnm-glib $(top_builddir)/../libnm-glib/libnm-glib.la
diff --git a/network-manager-applet-0.8.1/src/connection-editor/Makefile.am b/network-manager-applet-0.8.1/src/connection-editor/Makefile.am
index fadc93d..9890596 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/Makefile.am
+++ b/network-manager-applet-0.8.1/src/connection-editor/Makefile.am
@@ -17,6 +17,7 @@ nm_connection_editor_CPPFLAGS = \
 	$(DBUS_CFLAGS) \
 	$(DISABLE_DEPRECATED) \
 	-I${top_srcdir}/src/gconf-helpers \
+	-I${top_srcdir}/src/vpn-helpers \
 	-I${top_srcdir}/src/utils \
 	-I${top_srcdir}/src/wireless-security \
 	-I${top_builddir}/src/marshallers
@@ -55,8 +56,6 @@ nm_connection_editor_SOURCES = \
 	page-bond.c \
 	page-vlan.h \
 	page-vlan.c \
-	vpn-helpers.h \
-	vpn-helpers.c \
 	ip4-routes-dialog.h \
 	ip4-routes-dialog.c \
 	ip6-routes-dialog.h \
@@ -73,6 +72,7 @@ nm-connection-editor-service-glue.h: $(top_srcdir)/src/connection-editor/nm-conn
 
 nm_connection_editor_LDADD = \
 	$(top_builddir)/src/gconf-helpers/libgconf-helpers.la \
+	$(top_builddir)/src/vpn-helpers/libvpn-helpers.la \
 	${top_builddir}/src/wireless-security/libwireless-security.la \
 	${top_builddir}/src/utils/libutils.la \
 	${top_builddir}/src/marshallers/libmarshallers.la \
diff --git a/network-manager-applet-0.8.1/src/connection-editor/vpn-helpers.c b/network-manager-applet-0.8.1/src/connection-editor/vpn-helpers.c
deleted file mode 100644
index 908c94e..0000000
--- a/network-manager-applet-0.8.1/src/connection-editor/vpn-helpers.c
+++ /dev/null
@@ -1,386 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager Connection editor -- Connection editor for NetworkManager
- *
- * Dan Williams <dcbw@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * (C) Copyright 2008 Red Hat, Inc.
- */
-
-#include <string.h>
-#include <glib.h>
-#include <gmodule.h>
-#include <gtk/gtk.h>
-#include <glib/gi18n.h>
-
-#include <nm-connection.h>
-#include <nm-setting-connection.h>
-#include <nm-setting-vpn.h>
-
-#include "vpn-helpers.h"
-#include "utils.h"
-
-#define NM_VPN_API_SUBJECT_TO_CHANGE
-#include "nm-vpn-plugin-ui-interface.h"
-
-#define VPN_NAME_FILES_DIR SYSCONFDIR"/NetworkManager/VPN"
-
-static GHashTable *plugins = NULL;
-
-NMVpnPluginUiInterface *
-vpn_get_plugin_by_service (const char *service)
-{
-	g_return_val_if_fail (service != NULL, NULL);
-
-	return g_hash_table_lookup (plugins, service);
-}
-
-GHashTable *
-vpn_get_plugins (GError **error)
-{
-	GDir *dir;
-	const char *f;
-
-	if (error)
-		g_return_val_if_fail (*error == NULL, NULL);
-
-	if (plugins)
-		return plugins;
-
-	dir = g_dir_open (VPN_NAME_FILES_DIR, 0, NULL);
-	if (!dir) {
-		g_set_error (error, NMA_ERROR, NMA_ERROR_GENERIC, "Couldn't read VPN .name files directory " VPN_NAME_FILES_DIR ".");
-		return NULL;
-	}
-
-	plugins = g_hash_table_new_full (g_str_hash, g_str_equal,
-	                                 (GDestroyNotify) g_free, (GDestroyNotify) g_object_unref);
-
-	while ((f = g_dir_read_name (dir))) {
-		char *path = NULL, *service = NULL;
-		char *so_path = NULL, *so_name = NULL;
-		GKeyFile *keyfile = NULL;
-		GModule *module;
-		NMVpnPluginUiFactory factory = NULL;
-
-		if (!g_str_has_suffix (f, ".name"))
-			continue;
-
-		path = g_strdup_printf ("%s/%s", VPN_NAME_FILES_DIR, f);
-
-		keyfile = g_key_file_new ();
-		if (!g_key_file_load_from_file (keyfile, path, 0, NULL))
-			goto next;
-
-		service = g_key_file_get_string (keyfile, "VPN Connection", "service", NULL);
-		if (!service)
-			goto next;
-
-		so_path = g_key_file_get_string (keyfile,  "GNOME", "properties", NULL);
-		if (!so_path)
-			goto next;
-
-		/* Remove any path and extension components, then reconstruct path
-		 * to the SO in LIBDIR
-		 */
-		so_name = g_path_get_basename (so_path);
-		g_free (so_path);
-		so_path = g_strdup_printf ("%s/NetworkManager/%s", LIBDIR, so_name);
-		g_free (so_name);
-
-		module = g_module_open (so_path, G_MODULE_BIND_LAZY | G_MODULE_BIND_LOCAL);
-		if (!module) {
-			g_set_error (error, NMA_ERROR, NMA_ERROR_GENERIC, "Cannot load the VPN plugin which provides the "
-			             "service '%s'.", service);
-			goto next;
-		}
-
-		if (g_module_symbol (module, "nm_vpn_plugin_ui_factory", (gpointer) &factory)) {
-			NMVpnPluginUiInterface *plugin;
-			GError *factory_error = NULL;
-			gboolean success = FALSE;
-
-			plugin = factory (&factory_error);
-			if (plugin) {
-				char *plug_name = NULL, *plug_service = NULL;
-
-				/* Validate plugin properties */
-				g_object_get (G_OBJECT (plugin),
-				              NM_VPN_PLUGIN_UI_INTERFACE_NAME, &plug_name,
-				              NM_VPN_PLUGIN_UI_INTERFACE_SERVICE, &plug_service,
-				              NULL);
-				if (!plug_name || !strlen (plug_name)) {
-					g_set_error (error, NMA_ERROR, NMA_ERROR_GENERIC, "cannot load VPN plugin in '%s': missing plugin name", 
-					             g_module_name (module));
-				} else if (!plug_service || strcmp (plug_service, service)) {
-					g_set_error (error, NMA_ERROR, NMA_ERROR_GENERIC, "cannot load VPN plugin in '%s': invalid service name", 
-					             g_module_name (module));
-				} else {
-					/* Success! */
-					g_object_set_data_full (G_OBJECT (plugin), "gmodule", module,
-					                        (GDestroyNotify) g_module_close);
-					g_hash_table_insert (plugins, g_strdup (service), plugin);
-					success = TRUE;
-				}
-				g_free (plug_name);
-				g_free (plug_service);
-			} else {
-				g_set_error (error, NMA_ERROR, NMA_ERROR_GENERIC, "cannot load VPN plugin in '%s': %s", 
-				             g_module_name (module), g_module_error ());
-			}
-
-			if (!success)
-				g_module_close (module);
-		} else {
-			g_set_error (error, NMA_ERROR, NMA_ERROR_GENERIC, "cannot locate nm_vpn_plugin_ui_factory() in '%s': %s", 
-			             g_module_name (module), g_module_error ());
-			g_module_close (module);
-		}
-
-	next:
-		g_free (so_path);
-		g_free (service);
-		g_key_file_free (keyfile);
-		g_free (path);
-	}
-	g_dir_close (dir);
-
-	return plugins;
-}
-
-typedef struct {
-	VpnImportSuccessCallback callback;
-	gpointer user_data;
-} ActionInfo;
-
-static void
-import_vpn_from_file_cb (GtkWidget *dialog, gint response, gpointer user_data)
-{
-	char *filename = NULL;
-	ActionInfo *info = (ActionInfo *) user_data;
-	GHashTableIter iter;
-	gpointer key;
-	NMVpnPluginUiInterface *plugin;
-	NMConnection *connection = NULL;
-	GError *error = NULL;
-
-	if (response != GTK_RESPONSE_ACCEPT)
-		goto out;
-
-	filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (dialog));
-	if (!filename) {
-		g_warning ("%s: didn't get a filename back from the chooser!", __func__);
-		goto out;
-	}
-
-	g_hash_table_iter_init (&iter, plugins);
-	while (!connection && g_hash_table_iter_next (&iter, &key, (gpointer *)&plugin)) {
-		g_clear_error (&error);
-		connection = nm_vpn_plugin_ui_interface_import (plugin, filename, &error);
-	}
-
-	if (connection) {
-		if (nm_connection_get_scope (connection) == NM_CONNECTION_SCOPE_UNKNOWN)
-			nm_connection_set_scope (connection, NM_CONNECTION_SCOPE_USER);
-		info->callback (connection, info->user_data);
-	} else {
-		GtkWidget *err_dialog;
-		char *basename = g_path_get_basename (filename);
-
-		err_dialog = gtk_message_dialog_new (NULL,
-		                                     GTK_DIALOG_DESTROY_WITH_PARENT,
-		                                     GTK_MESSAGE_ERROR,
-		                                     GTK_BUTTONS_OK,
-		                                     _("Cannot import VPN connection"));
-		gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (err_dialog),
-		                                 _("The file '%s' could not be read or does not contain recognized VPN connection information\n\nError: %s."),
-		                                 basename, error ? error->message : "unknown error");
-		g_free (basename);
-		g_signal_connect (err_dialog, "delete-event", G_CALLBACK (gtk_widget_destroy), NULL);
-		g_signal_connect (err_dialog, "response", G_CALLBACK (gtk_widget_destroy), NULL);
-		gtk_widget_show_all (err_dialog);
-		gtk_window_present (GTK_WINDOW (err_dialog));
-	}
-
-	g_clear_error (&error);
-	g_free (filename);
-
-out:
-	gtk_widget_hide (dialog);
-	gtk_widget_destroy (dialog);
-	g_free (info);
-}
-
-static void
-destroy_import_chooser (GtkWidget *dialog, gpointer user_data)
-{
-	g_free (user_data);
-	gtk_widget_destroy (dialog);
-}
-
-void
-vpn_import (VpnImportSuccessCallback callback, gpointer user_data)
-{
-	GtkWidget *dialog;
-	ActionInfo *info;
-
-	dialog = gtk_file_chooser_dialog_new (_("Select file to import"),
-	                                      NULL,
-	                                      GTK_FILE_CHOOSER_ACTION_OPEN,
-	                                      GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
-	                                      GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
-	                                      NULL);
-	info = g_malloc0 (sizeof (ActionInfo));
-	info->callback = callback;
-	info->user_data = user_data;
-
-	g_signal_connect (G_OBJECT (dialog), "close", G_CALLBACK (destroy_import_chooser), info);
-	g_signal_connect (G_OBJECT (dialog), "response", G_CALLBACK (import_vpn_from_file_cb), info);
-	gtk_widget_show_all (dialog);
-	gtk_window_present (GTK_WINDOW (dialog));
-}
-
-static void
-export_vpn_to_file_cb (GtkWidget *dialog, gint response, gpointer user_data)
-{
-	NMConnection *connection = NM_CONNECTION (user_data);
-	char *filename = NULL;
-	GError *error = NULL;
-	NMVpnPluginUiInterface *plugin;
-	NMSettingConnection *s_con = NULL;
-	NMSettingVPN *s_vpn = NULL;
-	const char *service_type;
-	const char *id = NULL;
-	gboolean success = FALSE;
-
-	if (response != GTK_RESPONSE_ACCEPT)
-		goto out;
-
-	filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (dialog));
-	if (!filename) {
-		g_set_error (&error, NMA_ERROR, NMA_ERROR_GENERIC, "no filename");
-		goto done;
-	}
-
-	if (g_file_test (filename, G_FILE_TEST_EXISTS)) {
-		int replace_response;
-		GtkWidget *replace_dialog;
-		char *basename;
-
-		basename = g_path_get_basename (filename);
-		replace_dialog = gtk_message_dialog_new (NULL,
-		                                         GTK_DIALOG_DESTROY_WITH_PARENT,
-		                                         GTK_MESSAGE_QUESTION,
-		                                         GTK_BUTTONS_CANCEL,
-		                                         _("A file named \"%s\" already exists."),
-		                                         basename);
-		gtk_dialog_add_buttons (GTK_DIALOG (replace_dialog), _("_Replace"), GTK_RESPONSE_OK, NULL);
-		gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (replace_dialog),
-							  _("Do you want to replace %s with the VPN connection you are saving?"), basename);
-		g_free (basename);
-		replace_response = gtk_dialog_run (GTK_DIALOG (replace_dialog));
-		gtk_widget_destroy (replace_dialog);
-		if (replace_response != GTK_RESPONSE_OK)
-			goto out;
-	}
-
-	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
-	id = s_con ? nm_setting_connection_get_id (s_con) : NULL;
-	if (!id) {
-		g_set_error (&error, NMA_ERROR, NMA_ERROR_GENERIC, "connection setting invalid");
-		goto done;
-	}
-
-	s_vpn = (NMSettingVPN *) nm_connection_get_setting (connection, NM_TYPE_SETTING_VPN);
-	service_type = s_vpn ? nm_setting_vpn_get_service_type (s_vpn) : NULL;
-
-	if (!service_type) {
-		g_set_error (&error, NMA_ERROR, NMA_ERROR_GENERIC, "VPN setting invalid");
-		goto done;
-	}
-
-	plugin = vpn_get_plugin_by_service (service_type);
-	if (plugin)
-		success = nm_vpn_plugin_ui_interface_export (plugin, filename, connection, &error);
-
-done:
-	if (!success) {
-		GtkWidget *err_dialog;
-		char *basename = filename ? g_path_get_basename (filename) : g_strdup ("(none)");
-
-		err_dialog = gtk_message_dialog_new (NULL,
-		                                     GTK_DIALOG_DESTROY_WITH_PARENT,
-		                                     GTK_MESSAGE_ERROR,
-		                                     GTK_BUTTONS_OK,
-		                                     _("Cannot export VPN connection"));
-		gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (err_dialog),
-		                                 _("The VPN connection '%s' could not be exported to %s.\n\nError: %s."),
-		                                 id ? id : "(unknown)", basename, error ? error->message : "unknown error");
-		g_free (basename);
-		g_signal_connect (err_dialog, "delete-event", G_CALLBACK (gtk_widget_destroy), NULL);
-		g_signal_connect (err_dialog, "response", G_CALLBACK (gtk_widget_destroy), NULL);
-		gtk_widget_show_all (err_dialog);
-		gtk_window_present (GTK_WINDOW (err_dialog));
-	}
-
-out:
-	if (error)
-		g_error_free (error);
-	g_object_unref (connection);
-
-	gtk_widget_hide (dialog);
-	gtk_widget_destroy (dialog);
-}
-
-void
-vpn_export (NMConnection *connection)
-{
-	GtkWidget *dialog;
-	NMVpnPluginUiInterface *plugin;
-	NMSettingVPN *s_vpn = NULL;
-	const char *service_type;
-
-	s_vpn = NM_SETTING_VPN (nm_connection_get_setting (connection, NM_TYPE_SETTING_VPN));
-	service_type = s_vpn ? nm_setting_vpn_get_service_type (s_vpn) : NULL;
-
-	if (!service_type) {
-		g_warning ("%s: invalid VPN connection!", __func__);
-		return;
-	}
-
-	dialog = gtk_file_chooser_dialog_new (_("Export VPN connection..."),
-	                                      NULL,
-	                                      GTK_FILE_CHOOSER_ACTION_SAVE,
-	                                      GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
-	                                      GTK_STOCK_SAVE, GTK_RESPONSE_ACCEPT,
-	                                      NULL);
-
-	plugin = vpn_get_plugin_by_service (service_type);
-	if (plugin) {
-		char *suggested = NULL;
-
-		suggested = nm_vpn_plugin_ui_interface_get_suggested_name (plugin, connection);
-		if (suggested) {
-			gtk_file_chooser_set_current_name (GTK_FILE_CHOOSER (dialog), suggested);
-			g_free (suggested);
-		}
-	}
-
-	g_signal_connect (G_OBJECT (dialog), "close", G_CALLBACK (gtk_widget_destroy), NULL);
-	g_signal_connect (G_OBJECT (dialog), "response", G_CALLBACK (export_vpn_to_file_cb), g_object_ref (connection));
-	gtk_widget_show_all (dialog);
-	gtk_window_present (GTK_WINDOW (dialog));
-}
diff --git a/network-manager-applet-0.8.1/src/connection-editor/vpn-helpers.h b/network-manager-applet-0.8.1/src/connection-editor/vpn-helpers.h
deleted file mode 100644
index 41fe3df..0000000
--- a/network-manager-applet-0.8.1/src/connection-editor/vpn-helpers.h
+++ /dev/null
@@ -1,42 +0,0 @@
-/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
-/* NetworkManager Connection editor -- Connection editor for NetworkManager
- *
- * Dan Williams <dcbw@redhat.com>
- *
- * This program is free software; you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation; either version 2 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License along
- * with this program; if not, write to the Free Software Foundation, Inc.,
- * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
- *
- * (C) Copyright 2008 Red Hat, Inc.
- */
-
-#ifndef _VPN_HELPERS_H_
-#define _VPN_HELPERS_H_
-
-#include <glib.h>
-#include <gtk/gtk.h>
-#include <nm-connection.h>
-
-#define NM_VPN_API_SUBJECT_TO_CHANGE
-#include <nm-vpn-plugin-ui-interface.h>
-
-GHashTable *vpn_get_plugins (GError **error);
-
-NMVpnPluginUiInterface *vpn_get_plugin_by_service (const char *service);
-
-typedef void (*VpnImportSuccessCallback) (NMConnection *connection, gpointer user_data);
-void vpn_import (VpnImportSuccessCallback callback, gpointer user_data);
-
-void vpn_export (NMConnection *connection);
-
-#endif  /* _VPN_HELPERS_H_ */
diff --git a/network-manager-applet-0.8.1/src/vpn-helpers/Makefile.am b/network-manager-applet-0.8.1/src/vpn-helpers/Makefile.am
new file mode 100644
index 0000000..79f6910
--- /dev/null
+++ b/network-manager-applet-0.8.1/src/vpn-helpers/Makefile.am
@@ -0,0 +1,25 @@
+INCLUDES = -I${top_srcdir}/../include \
+           -I${top_srcdir}/../libnm-util \
+           -I${top_srcdir}/../libnm-glib
+
+noinst_LTLIBRARIES = libvpn-helpers.la
+
+libvpn_helpers_la_SOURCES =	\
+	vpn-helpers.h		\
+	vpn-helpers.c
+
+libvpn_helpers_la_CPPFLAGS = \
+	$(NMA_CFLAGS) \
+	$(DISABLE_DEPRECATED) \
+	-DSYSCONFDIR=\"$(sysconfdir)\" \
+	-DLIBDIR=\""$(libdir)"\" \
+	-I${top_srcdir}/src \
+	-I${top_srcdir}/src/utils
+
+libvpn_helpers_la_LIBADD = \
+	$(NMA_LIBS) \
+	${top_builddir}/src/utils/libutils.la \
+	-L${top_builddir}/../libnm-util $(top_builddir)/../libnm-util/libnm-util.la \
+	-L${top_builddir}/../libnm-glib $(top_builddir)/../libnm-glib/libnm-glib.la \
+	-L${top_builddir}/../libnm-glib $(top_builddir)/../libnm-glib/libnm-glib-vpn.la
+
diff --git a/network-manager-applet-0.8.1/src/vpn-helpers/vpn-helpers.c b/network-manager-applet-0.8.1/src/vpn-helpers/vpn-helpers.c
new file mode 100644
index 0000000..908c94e
--- /dev/null
+++ b/network-manager-applet-0.8.1/src/vpn-helpers/vpn-helpers.c
@@ -0,0 +1,386 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager Connection editor -- Connection editor for NetworkManager
+ *
+ * Dan Williams <dcbw@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2008 Red Hat, Inc.
+ */
+
+#include <string.h>
+#include <glib.h>
+#include <gmodule.h>
+#include <gtk/gtk.h>
+#include <glib/gi18n.h>
+
+#include <nm-connection.h>
+#include <nm-setting-connection.h>
+#include <nm-setting-vpn.h>
+
+#include "vpn-helpers.h"
+#include "utils.h"
+
+#define NM_VPN_API_SUBJECT_TO_CHANGE
+#include "nm-vpn-plugin-ui-interface.h"
+
+#define VPN_NAME_FILES_DIR SYSCONFDIR"/NetworkManager/VPN"
+
+static GHashTable *plugins = NULL;
+
+NMVpnPluginUiInterface *
+vpn_get_plugin_by_service (const char *service)
+{
+	g_return_val_if_fail (service != NULL, NULL);
+
+	return g_hash_table_lookup (plugins, service);
+}
+
+GHashTable *
+vpn_get_plugins (GError **error)
+{
+	GDir *dir;
+	const char *f;
+
+	if (error)
+		g_return_val_if_fail (*error == NULL, NULL);
+
+	if (plugins)
+		return plugins;
+
+	dir = g_dir_open (VPN_NAME_FILES_DIR, 0, NULL);
+	if (!dir) {
+		g_set_error (error, NMA_ERROR, NMA_ERROR_GENERIC, "Couldn't read VPN .name files directory " VPN_NAME_FILES_DIR ".");
+		return NULL;
+	}
+
+	plugins = g_hash_table_new_full (g_str_hash, g_str_equal,
+	                                 (GDestroyNotify) g_free, (GDestroyNotify) g_object_unref);
+
+	while ((f = g_dir_read_name (dir))) {
+		char *path = NULL, *service = NULL;
+		char *so_path = NULL, *so_name = NULL;
+		GKeyFile *keyfile = NULL;
+		GModule *module;
+		NMVpnPluginUiFactory factory = NULL;
+
+		if (!g_str_has_suffix (f, ".name"))
+			continue;
+
+		path = g_strdup_printf ("%s/%s", VPN_NAME_FILES_DIR, f);
+
+		keyfile = g_key_file_new ();
+		if (!g_key_file_load_from_file (keyfile, path, 0, NULL))
+			goto next;
+
+		service = g_key_file_get_string (keyfile, "VPN Connection", "service", NULL);
+		if (!service)
+			goto next;
+
+		so_path = g_key_file_get_string (keyfile,  "GNOME", "properties", NULL);
+		if (!so_path)
+			goto next;
+
+		/* Remove any path and extension components, then reconstruct path
+		 * to the SO in LIBDIR
+		 */
+		so_name = g_path_get_basename (so_path);
+		g_free (so_path);
+		so_path = g_strdup_printf ("%s/NetworkManager/%s", LIBDIR, so_name);
+		g_free (so_name);
+
+		module = g_module_open (so_path, G_MODULE_BIND_LAZY | G_MODULE_BIND_LOCAL);
+		if (!module) {
+			g_set_error (error, NMA_ERROR, NMA_ERROR_GENERIC, "Cannot load the VPN plugin which provides the "
+			             "service '%s'.", service);
+			goto next;
+		}
+
+		if (g_module_symbol (module, "nm_vpn_plugin_ui_factory", (gpointer) &factory)) {
+			NMVpnPluginUiInterface *plugin;
+			GError *factory_error = NULL;
+			gboolean success = FALSE;
+
+			plugin = factory (&factory_error);
+			if (plugin) {
+				char *plug_name = NULL, *plug_service = NULL;
+
+				/* Validate plugin properties */
+				g_object_get (G_OBJECT (plugin),
+				              NM_VPN_PLUGIN_UI_INTERFACE_NAME, &plug_name,
+				              NM_VPN_PLUGIN_UI_INTERFACE_SERVICE, &plug_service,
+				              NULL);
+				if (!plug_name || !strlen (plug_name)) {
+					g_set_error (error, NMA_ERROR, NMA_ERROR_GENERIC, "cannot load VPN plugin in '%s': missing plugin name", 
+					             g_module_name (module));
+				} else if (!plug_service || strcmp (plug_service, service)) {
+					g_set_error (error, NMA_ERROR, NMA_ERROR_GENERIC, "cannot load VPN plugin in '%s': invalid service name", 
+					             g_module_name (module));
+				} else {
+					/* Success! */
+					g_object_set_data_full (G_OBJECT (plugin), "gmodule", module,
+					                        (GDestroyNotify) g_module_close);
+					g_hash_table_insert (plugins, g_strdup (service), plugin);
+					success = TRUE;
+				}
+				g_free (plug_name);
+				g_free (plug_service);
+			} else {
+				g_set_error (error, NMA_ERROR, NMA_ERROR_GENERIC, "cannot load VPN plugin in '%s': %s", 
+				             g_module_name (module), g_module_error ());
+			}
+
+			if (!success)
+				g_module_close (module);
+		} else {
+			g_set_error (error, NMA_ERROR, NMA_ERROR_GENERIC, "cannot locate nm_vpn_plugin_ui_factory() in '%s': %s", 
+			             g_module_name (module), g_module_error ());
+			g_module_close (module);
+		}
+
+	next:
+		g_free (so_path);
+		g_free (service);
+		g_key_file_free (keyfile);
+		g_free (path);
+	}
+	g_dir_close (dir);
+
+	return plugins;
+}
+
+typedef struct {
+	VpnImportSuccessCallback callback;
+	gpointer user_data;
+} ActionInfo;
+
+static void
+import_vpn_from_file_cb (GtkWidget *dialog, gint response, gpointer user_data)
+{
+	char *filename = NULL;
+	ActionInfo *info = (ActionInfo *) user_data;
+	GHashTableIter iter;
+	gpointer key;
+	NMVpnPluginUiInterface *plugin;
+	NMConnection *connection = NULL;
+	GError *error = NULL;
+
+	if (response != GTK_RESPONSE_ACCEPT)
+		goto out;
+
+	filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (dialog));
+	if (!filename) {
+		g_warning ("%s: didn't get a filename back from the chooser!", __func__);
+		goto out;
+	}
+
+	g_hash_table_iter_init (&iter, plugins);
+	while (!connection && g_hash_table_iter_next (&iter, &key, (gpointer *)&plugin)) {
+		g_clear_error (&error);
+		connection = nm_vpn_plugin_ui_interface_import (plugin, filename, &error);
+	}
+
+	if (connection) {
+		if (nm_connection_get_scope (connection) == NM_CONNECTION_SCOPE_UNKNOWN)
+			nm_connection_set_scope (connection, NM_CONNECTION_SCOPE_USER);
+		info->callback (connection, info->user_data);
+	} else {
+		GtkWidget *err_dialog;
+		char *basename = g_path_get_basename (filename);
+
+		err_dialog = gtk_message_dialog_new (NULL,
+		                                     GTK_DIALOG_DESTROY_WITH_PARENT,
+		                                     GTK_MESSAGE_ERROR,
+		                                     GTK_BUTTONS_OK,
+		                                     _("Cannot import VPN connection"));
+		gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (err_dialog),
+		                                 _("The file '%s' could not be read or does not contain recognized VPN connection information\n\nError: %s."),
+		                                 basename, error ? error->message : "unknown error");
+		g_free (basename);
+		g_signal_connect (err_dialog, "delete-event", G_CALLBACK (gtk_widget_destroy), NULL);
+		g_signal_connect (err_dialog, "response", G_CALLBACK (gtk_widget_destroy), NULL);
+		gtk_widget_show_all (err_dialog);
+		gtk_window_present (GTK_WINDOW (err_dialog));
+	}
+
+	g_clear_error (&error);
+	g_free (filename);
+
+out:
+	gtk_widget_hide (dialog);
+	gtk_widget_destroy (dialog);
+	g_free (info);
+}
+
+static void
+destroy_import_chooser (GtkWidget *dialog, gpointer user_data)
+{
+	g_free (user_data);
+	gtk_widget_destroy (dialog);
+}
+
+void
+vpn_import (VpnImportSuccessCallback callback, gpointer user_data)
+{
+	GtkWidget *dialog;
+	ActionInfo *info;
+
+	dialog = gtk_file_chooser_dialog_new (_("Select file to import"),
+	                                      NULL,
+	                                      GTK_FILE_CHOOSER_ACTION_OPEN,
+	                                      GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+	                                      GTK_STOCK_OPEN, GTK_RESPONSE_ACCEPT,
+	                                      NULL);
+	info = g_malloc0 (sizeof (ActionInfo));
+	info->callback = callback;
+	info->user_data = user_data;
+
+	g_signal_connect (G_OBJECT (dialog), "close", G_CALLBACK (destroy_import_chooser), info);
+	g_signal_connect (G_OBJECT (dialog), "response", G_CALLBACK (import_vpn_from_file_cb), info);
+	gtk_widget_show_all (dialog);
+	gtk_window_present (GTK_WINDOW (dialog));
+}
+
+static void
+export_vpn_to_file_cb (GtkWidget *dialog, gint response, gpointer user_data)
+{
+	NMConnection *connection = NM_CONNECTION (user_data);
+	char *filename = NULL;
+	GError *error = NULL;
+	NMVpnPluginUiInterface *plugin;
+	NMSettingConnection *s_con = NULL;
+	NMSettingVPN *s_vpn = NULL;
+	const char *service_type;
+	const char *id = NULL;
+	gboolean success = FALSE;
+
+	if (response != GTK_RESPONSE_ACCEPT)
+		goto out;
+
+	filename = gtk_file_chooser_get_filename (GTK_FILE_CHOOSER (dialog));
+	if (!filename) {
+		g_set_error (&error, NMA_ERROR, NMA_ERROR_GENERIC, "no filename");
+		goto done;
+	}
+
+	if (g_file_test (filename, G_FILE_TEST_EXISTS)) {
+		int replace_response;
+		GtkWidget *replace_dialog;
+		char *basename;
+
+		basename = g_path_get_basename (filename);
+		replace_dialog = gtk_message_dialog_new (NULL,
+		                                         GTK_DIALOG_DESTROY_WITH_PARENT,
+		                                         GTK_MESSAGE_QUESTION,
+		                                         GTK_BUTTONS_CANCEL,
+		                                         _("A file named \"%s\" already exists."),
+		                                         basename);
+		gtk_dialog_add_buttons (GTK_DIALOG (replace_dialog), _("_Replace"), GTK_RESPONSE_OK, NULL);
+		gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (replace_dialog),
+							  _("Do you want to replace %s with the VPN connection you are saving?"), basename);
+		g_free (basename);
+		replace_response = gtk_dialog_run (GTK_DIALOG (replace_dialog));
+		gtk_widget_destroy (replace_dialog);
+		if (replace_response != GTK_RESPONSE_OK)
+			goto out;
+	}
+
+	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
+	id = s_con ? nm_setting_connection_get_id (s_con) : NULL;
+	if (!id) {
+		g_set_error (&error, NMA_ERROR, NMA_ERROR_GENERIC, "connection setting invalid");
+		goto done;
+	}
+
+	s_vpn = (NMSettingVPN *) nm_connection_get_setting (connection, NM_TYPE_SETTING_VPN);
+	service_type = s_vpn ? nm_setting_vpn_get_service_type (s_vpn) : NULL;
+
+	if (!service_type) {
+		g_set_error (&error, NMA_ERROR, NMA_ERROR_GENERIC, "VPN setting invalid");
+		goto done;
+	}
+
+	plugin = vpn_get_plugin_by_service (service_type);
+	if (plugin)
+		success = nm_vpn_plugin_ui_interface_export (plugin, filename, connection, &error);
+
+done:
+	if (!success) {
+		GtkWidget *err_dialog;
+		char *basename = filename ? g_path_get_basename (filename) : g_strdup ("(none)");
+
+		err_dialog = gtk_message_dialog_new (NULL,
+		                                     GTK_DIALOG_DESTROY_WITH_PARENT,
+		                                     GTK_MESSAGE_ERROR,
+		                                     GTK_BUTTONS_OK,
+		                                     _("Cannot export VPN connection"));
+		gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (err_dialog),
+		                                 _("The VPN connection '%s' could not be exported to %s.\n\nError: %s."),
+		                                 id ? id : "(unknown)", basename, error ? error->message : "unknown error");
+		g_free (basename);
+		g_signal_connect (err_dialog, "delete-event", G_CALLBACK (gtk_widget_destroy), NULL);
+		g_signal_connect (err_dialog, "response", G_CALLBACK (gtk_widget_destroy), NULL);
+		gtk_widget_show_all (err_dialog);
+		gtk_window_present (GTK_WINDOW (err_dialog));
+	}
+
+out:
+	if (error)
+		g_error_free (error);
+	g_object_unref (connection);
+
+	gtk_widget_hide (dialog);
+	gtk_widget_destroy (dialog);
+}
+
+void
+vpn_export (NMConnection *connection)
+{
+	GtkWidget *dialog;
+	NMVpnPluginUiInterface *plugin;
+	NMSettingVPN *s_vpn = NULL;
+	const char *service_type;
+
+	s_vpn = NM_SETTING_VPN (nm_connection_get_setting (connection, NM_TYPE_SETTING_VPN));
+	service_type = s_vpn ? nm_setting_vpn_get_service_type (s_vpn) : NULL;
+
+	if (!service_type) {
+		g_warning ("%s: invalid VPN connection!", __func__);
+		return;
+	}
+
+	dialog = gtk_file_chooser_dialog_new (_("Export VPN connection..."),
+	                                      NULL,
+	                                      GTK_FILE_CHOOSER_ACTION_SAVE,
+	                                      GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+	                                      GTK_STOCK_SAVE, GTK_RESPONSE_ACCEPT,
+	                                      NULL);
+
+	plugin = vpn_get_plugin_by_service (service_type);
+	if (plugin) {
+		char *suggested = NULL;
+
+		suggested = nm_vpn_plugin_ui_interface_get_suggested_name (plugin, connection);
+		if (suggested) {
+			gtk_file_chooser_set_current_name (GTK_FILE_CHOOSER (dialog), suggested);
+			g_free (suggested);
+		}
+	}
+
+	g_signal_connect (G_OBJECT (dialog), "close", G_CALLBACK (gtk_widget_destroy), NULL);
+	g_signal_connect (G_OBJECT (dialog), "response", G_CALLBACK (export_vpn_to_file_cb), g_object_ref (connection));
+	gtk_widget_show_all (dialog);
+	gtk_window_present (GTK_WINDOW (dialog));
+}
diff --git a/network-manager-applet-0.8.1/src/vpn-helpers/vpn-helpers.h b/network-manager-applet-0.8.1/src/vpn-helpers/vpn-helpers.h
new file mode 100644
index 0000000..41fe3df
--- /dev/null
+++ b/network-manager-applet-0.8.1/src/vpn-helpers/vpn-helpers.h
@@ -0,0 +1,42 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager Connection editor -- Connection editor for NetworkManager
+ *
+ * Dan Williams <dcbw@redhat.com>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2008 Red Hat, Inc.
+ */
+
+#ifndef _VPN_HELPERS_H_
+#define _VPN_HELPERS_H_
+
+#include <glib.h>
+#include <gtk/gtk.h>
+#include <nm-connection.h>
+
+#define NM_VPN_API_SUBJECT_TO_CHANGE
+#include <nm-vpn-plugin-ui-interface.h>
+
+GHashTable *vpn_get_plugins (GError **error);
+
+NMVpnPluginUiInterface *vpn_get_plugin_by_service (const char *service);
+
+typedef void (*VpnImportSuccessCallback) (NMConnection *connection, gpointer user_data);
+void vpn_import (VpnImportSuccessCallback callback, gpointer user_data);
+
+void vpn_export (NMConnection *connection);
+
+#endif  /* _VPN_HELPERS_H_ */
-- 
1.7.11.7

--- a/network-manager-applet-0.8.1/src/applet.c	2014-05-06 09:50:20.530110353 +0200
+++ b/network-manager-applet-0.8.1/src/applet.c	2014-05-06 10:06:06.279286861 +0200
@@ -77,6 +77,7 @@
 #include "applet-dbus-manager.h"
 #include "utils.h"
 #include "gconf-helpers.h"
+#include "vpn-helpers.h"
 
 #define NOTIFY_CAPS_ACTIONS_KEY "actions"
 
--- a/network-manager-applet-0.8.1/src/applet.c	2014-05-06 09:28:56.898157961 +0200
+++ b/network-manager-applet-0.8.1/src/applet.c	2014-05-06 09:46:02.244339369 +0200
@@ -1590,16 +1590,27 @@ nma_menu_add_vpn_submenu (GtkWidget *men
 	GtkMenu *vpn_menu;
 	GtkMenuItem *item;
 	GSList *list, *iter;
+	GHashTable *vpn_plugins;
+	gboolean have_plugins;
 	int num_vpn_active = 0;
 
+	vpn_plugins = vpn_get_plugins (NULL);
+	have_plugins = vpn_plugins && g_hash_table_size (vpn_plugins);
+
 	nma_menu_add_separator_item (menu);
 
 	vpn_menu = GTK_MENU (gtk_menu_new ());
 
-	item = GTK_MENU_ITEM (gtk_menu_item_new_with_mnemonic (_("_VPN Connections")));
+	item = GTK_MENU_ITEM (gtk_menu_item_new_with_mnemonic (have_plugins ? _("_VPN Connections") :
+	                                                                      _("_VPN Connections (no plugin installed)")));
 	gtk_menu_item_set_submenu (item, GTK_WIDGET (vpn_menu));
 	gtk_menu_shell_append (GTK_MENU_SHELL (menu), GTK_WIDGET (item));
 
+	if (!have_plugins) {
+		gtk_widget_set_sensitive (GTK_WIDGET (item), FALSE);
+		return;
+	}
+
 	list = get_vpn_connections (applet);
 	for (iter = list; iter; iter = g_slist_next (iter)) {
 		NMConnection *connection = NM_CONNECTION (iter->data);
--- a/network-manager-applet-0.8.1/src/connection-editor/new-connection.c	2014-05-05 17:49:14.859030448 +0200
+++ b/network-manager-applet-0.8.1/src/connection-editor/new-connection.c	2014-05-05 17:41:48.887605858 +0200
@@ -236,6 +236,7 @@ set_up_connection_type_combo (GtkComboBo
 	gboolean import_supported = FALSE;
 	gboolean added_virtual_header = FALSE;
 	gboolean show_headers = (type_filter_func == NULL);
+	gboolean vpn_not_available = FALSE;
 	char *markup;
 
 	gtk_combo_box_set_row_separator_func (combo, combo_row_separator_func, NULL, NULL);
@@ -286,13 +287,11 @@ set_up_connection_type_combo (GtkComboBo
 		added++;
 	}
 
-	if (!vpn_plugins || vpn_index == -1) {
-		gtk_combo_box_set_active (combo, show_headers ? active + 1 : active);
-		return;
-	}
+	vpn_not_available = !vpn_plugins || vpn_index == -1;
 
 	if (show_headers) {
-		markup = g_strdup_printf ("<b><big>%s</big></b>", _("VPN"));
+		markup = g_strdup_printf ("<b><big>%s</big></b>",
+		                          !vpn_not_available ? _("VPN") : _("VPN (no plugin installed)"));
 		gtk_list_store_append (model, &iter);
 		gtk_list_store_set (model, &iter,
 		                    COL_MARKUP, markup,
@@ -301,6 +300,11 @@ set_up_connection_type_combo (GtkComboBo
 		g_free (markup);
 	}
 
+	if (vpn_not_available) {
+		gtk_combo_box_set_active (combo, show_headers ? active + 1 : active);
+		return;
+	}
+
 	for (p = vpn_plugins; p; p = p->next) {
 		NMVpnPluginUiInterface *plugin = NM_VPN_PLUGIN_UI_INTERFACE (p->data);
 		char *desc;
--- a/network-manager-applet-0.8.1/src/connection-editor/ce-new-connection.ui	2014-01-21 16:09:03.034959298 +0100
+++ b/network-manager-applet-0.8.1/src/connection-editor/ce-new-connection.ui	2014-05-05 17:14:57.710748341 +0200
@@ -58,9 +58,7 @@
                   <object class="GtkLabel" id="new_connection_secondary_label">
                     <property name="visible">True</property>
                     <property name="xalign">0</property>
-                    <property name="label" translatable="yes">Select the type of connection you wish to create.
-
-If you are creating a VPN, and the VPN connection you wish to create does not appear in the list, you may not have the correct VPN plugin installed.</property>
+                    <property name="label" translatable="yes">Select the type of connection you wish to create.</property>
                     <property name="wrap">True</property>
                   </object>
                   <packing>
