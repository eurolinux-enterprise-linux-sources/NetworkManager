From 29fd52fbae13eea03657636b6c731eb2a64a6d76 Mon Sep 17 00:00:00 2001
From: Dan Williams <dcbw@redhat.com>
Date: Thu, 28 Mar 2013 17:20:14 -0500
Subject: [PATCH] ethernet: add reconnect delay for PPPoE connections (rh #602265)

Attempting an immediate reconnect if the peer terminates the connection
sometimes results in the peer not being ready to negotiate a new
connection, while a short delay allows the peer to correctly tear
down the old connection and get listen for a new one.  Introduce
a short delay when activating a PPPoE connection if a PPPoE
connection was recently deactivated.
---
 src/nm-device-ethernet.c |   58 ++++++++++++++++++++++++++++++++++++++++++++++
 1 files changed, 58 insertions(+), 0 deletions(-)

diff --git a/src/nm-device-ethernet.c b/src/nm-device-ethernet.c
index 34e9b94..bd0b3e7 100644
--- a/src/nm-device-ethernet.c
+++ b/src/nm-device-ethernet.c
@@ -65,6 +65,8 @@ G_DEFINE_TYPE (NMDeviceEthernet, nm_device_ethernet, NM_TYPE_DEVICE_WIRED)
 
 #define WIRED_SECRETS_TRIES "wired-secrets-tries"
 
+#define PPPOE_RECONNECT_DELAY 7
+
 typedef enum
 {
 	NM_ETHERNET_ERROR_CONNECTION_NOT_WIRED = 0,
@@ -118,6 +120,8 @@ typedef struct {
 	/* PPPoE */
 	NMPPPManager *ppp_manager;
 	NMIP4Config  *pending_ip4_config;
+	time_t        last_pppoe_time;
+	guint         pppoe_wait_id;
 } NMDeviceEthernetPrivate;
 
 enum {
@@ -141,6 +145,7 @@ enum {
 
 static gboolean supports_mii_carrier_detect (NMDeviceEthernet *dev);
 static gboolean supports_ethtool_carrier_detect (NMDeviceEthernet *dev);
+static NMSetting *device_get_setting (NMDevice *device, GType setting_type);
 
 static GQuark
 nm_ethernet_error_quark (void)
@@ -175,6 +180,21 @@ nm_ethernet_error_get_type (void)
 }
 
 static void
+device_state_changed (NMDevice *device,
+                      NMDeviceState new_state,
+                      NMDeviceState old_state,
+                      NMDeviceStateReason reason,
+                      gpointer user_data)
+{
+	if (   new_state == NM_DEVICE_STATE_FAILED 
+	    || (   new_state == NM_DEVICE_STATE_DISCONNECTED
+            && old_state > NM_DEVICE_STATE_DISCONNECTED)) {
+		if (device_get_setting (device, NM_TYPE_SETTING_PPPOE))
+			NM_DEVICE_ETHERNET_GET_PRIVATE (device)->last_pppoe_time = time (NULL);
+	}
+}
+
+static void
 _update_s390_subchannels (NMDeviceEthernet *self)
 {
 	NMDeviceEthernetPrivate *priv = NM_DEVICE_ETHERNET_GET_PRIVATE (self);
@@ -308,6 +328,7 @@ constructor (GType type,
 static void
 nm_device_ethernet_init (NMDeviceEthernet * self)
 {
+	g_signal_connect (self, "state-changed", G_CALLBACK (device_state_changed), NULL);
 }
 
 static gboolean
@@ -1215,10 +1236,24 @@ supplicant_interface_init (NMDeviceEthernet *self)
 	return TRUE;
 }
 
+static gboolean
+pppoe_reconnect_delay (gpointer user_data)
+{
+	NMDevice *device = NM_DEVICE (user_data);
+	NMDeviceEthernetPrivate *priv = NM_DEVICE_ETHERNET_GET_PRIVATE (device);
+
+	priv->pppoe_wait_id = 0;
+	nm_device_activate_schedule_stage2_device_config (device);
+	nm_log_info (LOGD_DEVICE, "(%s) PPPoE reconnect delay complete, resuming connection...",
+	             nm_device_get_iface (device));
+	return FALSE;
+}
+
 static NMActStageReturn
 real_act_stage1_prepare (NMDevice *dev, NMDeviceStateReason *reason)
 {
 	NMDeviceEthernet *self = NM_DEVICE_ETHERNET (dev);
+	NMDeviceEthernetPrivate *priv = NM_DEVICE_ETHERNET_GET_PRIVATE (self);
 	NMActRequest *req;
 	NMSettingWired *s_wired;
 	const GByteArray *cloned_mac;
@@ -1238,6 +1273,24 @@ real_act_stage1_prepare (NMDevice *dev, NMDeviceStateReason *reason)
 		cloned_mac = nm_setting_wired_get_cloned_mac_address (s_wired);
 		if (cloned_mac && (cloned_mac->len == ETH_ALEN))
 			_set_hw_addr (self, (const guint8 *) cloned_mac->data, "set");
+
+		/* If we're re-activating a PPPoE connection a short while after
+		 * a previous PPPoE connection was torn down, wait a bit to allow the
+		 * remote side to handle the disconnection.  Otherwise the peer may
+		 * get confused and fail to negotiate the new connection. (rh #602265)
+		 */
+		 if (   device_get_setting (dev, NM_TYPE_SETTING_PPPOE)
+		     && (time (NULL) - priv->last_pppoe_time < PPPOE_RECONNECT_DELAY)) {
+			nm_log_info (LOGD_DEVICE, "(%s) delaying PPPoE reconnect to ensure peer is ready...",
+			             nm_device_get_iface (dev));
+			g_warn_if_fail (priv->pppoe_wait_id == 0);
+			if (priv->pppoe_wait_id)
+				g_source_remove (priv->pppoe_wait_id);
+			priv->pppoe_wait_id = g_timeout_add_seconds (PPPOE_RECONNECT_DELAY,
+			                                             pppoe_reconnect_delay,
+			                                             self);
+			ret = NM_ACT_STAGE_RETURN_POSTPONE;
+		 }
 	}
 
 	return ret;
@@ -1474,6 +1527,11 @@ real_deactivate_quickly (NMDevice *device)
 	NMDeviceEthernet *self = NM_DEVICE_ETHERNET (device);
 	NMDeviceEthernetPrivate *priv = NM_DEVICE_ETHERNET_GET_PRIVATE (self);
 
+	if (priv->pppoe_wait_id) {
+		g_source_remove (priv->pppoe_wait_id);
+		priv->pppoe_wait_id = 0;
+	}
+
 	if (priv->pending_ip4_config) {
 		g_object_unref (priv->pending_ip4_config);
 		priv->pending_ip4_config = NULL;
-- 
1.7.1

