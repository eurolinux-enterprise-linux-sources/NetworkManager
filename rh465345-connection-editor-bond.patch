diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/po/POTFILES.in.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/po/POTFILES.in
index 80cc3cb..886a980 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/po/POTFILES.in.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/po/POTFILES.in
@@ -15,6 +15,7 @@ src/applet.c
 src/applet.glade
 src/applet.h
 src/connection-editor/ce-page.c
+[type: gettext/glade]src/connection-editor/ce-page-bond.ui
 [type: gettext/glade]src/connection-editor/ce-page-dsl.ui
 [type: gettext/glade]src/connection-editor/ce-page-infiniband.ui
 [type: gettext/glade]src/connection-editor/ce-page-ip4.ui
@@ -28,6 +29,7 @@ src/connection-editor/ce-page.c
 src/connection-editor/ip4-routes-dialog.c
 src/connection-editor/ip6-routes-dialog.c
 src/connection-editor/new-connection.c
+src/connection-editor/page-bond.c
 src/connection-editor/page-dsl.c
 src/connection-editor/page-infiniband.c
 src/connection-editor/page-ip4.c
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/Makefile.am.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/Makefile.am
index 6bec432..2f3011e 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/Makefile.am.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/Makefile.am
@@ -47,6 +47,8 @@ nm_connection_editor_SOURCES = \
 	page-ppp.c \
 	page-vpn.h \
 	page-vpn.c \
+	page-bond.h \
+	page-bond.c \
 	vpn-helpers.h \
 	vpn-helpers.c \
 	ip4-routes-dialog.h \
@@ -81,6 +83,7 @@ ui_DATA = \
 	ce-page-wireless.ui \
 	ce-page-wireless-security.ui \
 	ce-page-infiniband.ui \
+	ce-page-bond.ui \
 	ce-page-ip4.ui \
 	ce-page-ip6.ui \
 	ce-page-dsl.ui \
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/ce-page-bond.ui.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/ce-page-bond.ui
new file mode 100644
index 0000000..bbe27a0
--- /dev/null
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/ce-page-bond.ui
@@ -0,0 +1,460 @@
+<?xml version="1.0"?>
+<interface>
+  <requires lib="gtk+" version="2.16"/>
+  <!-- interface-naming-policy toplevel-contextual -->
+  <object class="GtkAdjustment" id="bond_frequency_adjustment">
+    <property name="value">100</property>
+    <property name="lower">1</property>
+    <property name="upper">10000</property>
+    <property name="step_increment">1</property>
+    <property name="page_increment">10</property>
+  </object>
+  <object class="GtkAdjustment" id="bond_updelay_adjustment">
+    <property name="upper">10000</property>
+    <property name="step_increment">100</property>
+    <property name="page_increment">100</property>
+  </object>
+  <object class="GtkAdjustment" id="bond_downdelay_adjustment">
+    <property name="upper">10000</property>
+    <property name="step_increment">100</property>
+    <property name="page_increment">100</property>
+  </object>
+  <object class="GtkListStore" id="bond_connections_model">
+    <columns>
+      <!-- column-name connection -->
+      <column type="GObject"/>
+      <!-- column-name name -->
+      <column type="gchararray"/>
+    </columns>
+  </object>
+  <object class="GtkListStore" id="bond_mode_model">
+    <columns>
+      <!-- column-name gchararray -->
+      <column type="gchararray"/>
+    </columns>
+    <data>
+      <row>
+        <col id="0" translatable="yes">Round-robin</col>
+      </row>
+      <row>
+        <col id="0" translatable="yes">Active backup</col>
+      </row>
+      <row>
+        <col id="0" translatable="yes">XOR</col>
+      </row>
+      <row>
+        <col id="0" translatable="yes">Broadcast</col>
+      </row>
+      <row>
+        <col id="0" translatable="yes">802.3ad</col>
+      </row>
+      <row>
+        <col id="0" translatable="yes">Adaptive transmit load balancing</col>
+      </row>
+      <row>
+        <col id="0" translatable="yes">Adaptive load balancing</col>
+      </row>
+    </data>
+  </object>
+  <object class="GtkListStore" id="bond_monitoring_model">
+    <columns>
+      <!-- column-name type -->
+      <column type="gchararray"/>
+    </columns>
+    <data>
+      <row>
+        <col id="0" translatable="yes">MII (recommended)</col>
+      </row>
+      <row>
+        <col id="0" translatable="yes">ARP</col>
+      </row>
+    </data>
+  </object>
+  <object class="GtkTable" id="BondPage">
+    <property name="visible">True</property>
+    <property name="border_width">12</property>
+    <property name="n_rows">9</property>
+    <property name="n_columns">2</property>
+    <property name="column_spacing">12</property>
+    <property name="row_spacing">6</property>
+    <child>
+      <object class="GtkLabel" id="bond_connections_label">
+        <property name="visible">True</property>
+        <property name="xalign">0</property>
+        <property name="label" translatable="yes">Bonded _connections:</property>
+        <property name="use_underline">True</property>
+      </object>
+      <packing>
+        <property name="right_attach">2</property>
+        <property name="top_attach">1</property>
+        <property name="bottom_attach">2</property>
+        <property name="x_options">GTK_FILL</property>
+        <property name="y_options"></property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkLabel" id="bond_mode_label">
+        <property name="visible">True</property>
+        <property name="xalign">0</property>
+        <property name="label" translatable="yes">_Mode:</property>
+        <property name="use_underline">True</property>
+        <property name="mnemonic_widget">bond_mode</property>
+      </object>
+      <packing>
+        <property name="top_attach">3</property>
+        <property name="bottom_attach">4</property>
+        <property name="x_options">GTK_FILL</property>
+        <property name="y_options"></property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkComboBox" id="bond_mode">
+        <property name="visible">True</property>
+        <property name="model">bond_mode_model</property>
+        <child>
+          <object class="GtkCellRendererText" id="renderer2"/>
+          <attributes>
+            <attribute name="text">0</attribute>
+          </attributes>
+        </child>
+      </object>
+      <packing>
+        <property name="left_attach">1</property>
+        <property name="right_attach">2</property>
+        <property name="top_attach">3</property>
+        <property name="bottom_attach">4</property>
+        <property name="y_options"></property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkHBox" id="hbox2">
+        <property name="visible">True</property>
+        <property name="spacing">10</property>
+        <child>
+          <object class="GtkScrolledWindow" id="scrolledwindow1">
+            <property name="visible">True</property>
+            <property name="can_focus">True</property>
+            <property name="hscrollbar_policy">never</property>
+            <property name="vscrollbar_policy">automatic</property>
+            <property name="shadow_type">in</property>
+            <child>
+              <object class="GtkTreeView" id="bond_connections">
+                <property name="visible">True</property>
+                <property name="can_focus">True</property>
+                <property name="model">bond_connections_model</property>
+                <property name="headers_visible">False</property>
+                <child>
+                  <object class="GtkTreeViewColumn" id="bond_connection_name">
+                    <child>
+                      <object class="GtkCellRendererText" id="bond_connection_renderer"/>
+                      <attributes>
+                        <attribute name="text">1</attribute>
+                      </attributes>
+                    </child>
+                  </object>
+                </child>
+              </object>
+            </child>
+          </object>
+          <packing>
+            <property name="position">0</property>
+          </packing>
+        </child>
+        <child>
+          <object class="GtkVButtonBox" id="buttonbox1">
+            <property name="visible">True</property>
+            <property name="orientation">vertical</property>
+            <property name="spacing">10</property>
+            <property name="layout_style">start</property>
+            <child>
+              <object class="GtkButton" id="bond_connection_add">
+                <property name="label">gtk-add</property>
+                <property name="visible">True</property>
+                <property name="can_focus">True</property>
+                <property name="receives_default">True</property>
+                <property name="use_stock">True</property>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+                <property name="position">0</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkButton" id="bond_connection_edit">
+                <property name="label" translatable="yes">_Edit</property>
+                <property name="visible">True</property>
+                <property name="can_focus">True</property>
+                <property name="receives_default">True</property>
+                <property name="use_underline">True</property>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+                <property name="position">1</property>
+              </packing>
+            </child>
+            <child>
+              <object class="GtkButton" id="bond_connection_delete">
+                <property name="label" translatable="yes">_Delete</property>
+                <property name="visible">True</property>
+                <property name="can_focus">True</property>
+                <property name="receives_default">True</property>
+                <property name="use_underline">True</property>
+              </object>
+              <packing>
+                <property name="expand">False</property>
+                <property name="position">2</property>
+              </packing>
+            </child>
+          </object>
+          <packing>
+            <property name="expand">False</property>
+            <property name="fill">False</property>
+            <property name="position">1</property>
+          </packing>
+        </child>
+      </object>
+      <packing>
+        <property name="right_attach">2</property>
+        <property name="top_attach">2</property>
+        <property name="bottom_attach">3</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkLabel" id="bond_frequency_label">
+        <property name="visible">True</property>
+        <property name="xalign">0</property>
+        <property name="label" translatable="yes">Monitoring _frequency:</property>
+        <property name="use_underline">True</property>
+        <property name="mnemonic_widget">bond_frequency</property>
+      </object>
+      <packing>
+        <property name="top_attach">5</property>
+        <property name="bottom_attach">6</property>
+        <property name="y_options">GTK_FILL</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkHBox" id="hbox1">
+        <property name="visible">True</property>
+        <property name="spacing">4</property>
+        <child>
+          <object class="GtkSpinButton" id="bond_frequency">
+            <property name="visible">True</property>
+            <property name="can_focus">True</property>
+            <property name="invisible_char">&#x25CF;</property>
+            <property name="adjustment">bond_frequency_adjustment</property>
+            <property name="numeric">True</property>
+          </object>
+          <packing>
+            <property name="position">0</property>
+          </packing>
+        </child>
+        <child>
+          <object class="GtkLabel" id="label1">
+            <property name="visible">True</property>
+            <property name="xalign">0</property>
+            <property name="label" translatable="yes">ms</property>
+          </object>
+          <packing>
+            <property name="position">1</property>
+          </packing>
+        </child>
+      </object>
+      <packing>
+        <property name="left_attach">1</property>
+        <property name="right_attach">2</property>
+        <property name="top_attach">5</property>
+        <property name="bottom_attach">6</property>
+        <property name="y_options">GTK_FILL</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkLabel" id="bond_interface_label">
+        <property name="visible">True</property>
+        <property name="xalign">0</property>
+        <property name="label" translatable="yes">_Interface name:</property>
+        <property name="use_underline">True</property>
+        <property name="mnemonic_widget">bond_interface</property>
+      </object>
+      <packing>
+        <property name="y_options">GTK_FILL</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkEntry" id="bond_interface">
+        <property name="visible">True</property>
+        <property name="can_focus">True</property>
+        <property name="invisible_char">&#x25CF;</property>
+      </object>
+      <packing>
+        <property name="left_attach">1</property>
+        <property name="right_attach">2</property>
+        <property name="y_options">GTK_FILL</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkLabel" id="bond_monitoring_label">
+        <property name="visible">True</property>
+        <property name="xalign">0</property>
+        <property name="label" translatable="yes">_Link Monitoring:</property>
+        <property name="use_underline">True</property>
+        <property name="mnemonic_widget">bond_monitoring</property>
+      </object>
+      <packing>
+        <property name="top_attach">4</property>
+        <property name="bottom_attach">5</property>
+        <property name="y_options">GTK_FILL</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkComboBox" id="bond_monitoring">
+        <property name="visible">True</property>
+        <property name="model">bond_monitoring_model</property>
+        <child>
+          <object class="GtkCellRendererText" id="renderer1"/>
+          <attributes>
+            <attribute name="text">0</attribute>
+          </attributes>
+        </child>
+      </object>
+      <packing>
+        <property name="left_attach">1</property>
+        <property name="right_attach">2</property>
+        <property name="top_attach">4</property>
+        <property name="bottom_attach">5</property>
+        <property name="y_options">GTK_FILL</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkLabel" id="bond_arp_targets_label">
+        <property name="visible">True</property>
+        <property name="xalign">0</property>
+        <property name="label" translatable="yes">ARP _targets:</property>
+        <property name="use_underline">True</property>
+        <property name="mnemonic_widget">bond_arp_targets</property>
+      </object>
+      <packing>
+        <property name="top_attach">8</property>
+        <property name="bottom_attach">9</property>
+        <property name="y_options">GTK_FILL</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkEntry" id="bond_arp_targets">
+        <property name="visible">True</property>
+        <property name="can_focus">True</property>
+        <property name="tooltip_text" translatable="yes">An IP address, or a comma-separated list of IP addresses, to look for when checking the link status.</property>
+        <property name="invisible_char">&#x25CF;</property>
+      </object>
+      <packing>
+        <property name="left_attach">1</property>
+        <property name="right_attach">2</property>
+        <property name="top_attach">8</property>
+        <property name="bottom_attach">9</property>
+        <property name="y_options">GTK_FILL</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkLabel" id="bond_updelay_label">
+        <property name="visible">True</property>
+        <property name="xalign">0</property>
+        <property name="label" translatable="yes">Link _up delay:</property>
+        <property name="use_underline">True</property>
+        <property name="mnemonic_widget">bond_updelay</property>
+      </object>
+      <packing>
+        <property name="top_attach">6</property>
+        <property name="bottom_attach">7</property>
+        <property name="y_options">GTK_FILL</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkLabel" id="bond_downdelay_label">
+        <property name="visible">True</property>
+        <property name="xalign">0</property>
+        <property name="label" translatable="yes">Link _down delay:</property>
+        <property name="use_underline">True</property>
+        <property name="mnemonic_widget">bond_downdelay</property>
+      </object>
+      <packing>
+        <property name="top_attach">7</property>
+        <property name="bottom_attach">8</property>
+        <property name="y_options">GTK_FILL</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkHBox" id="bond_updelay_box">
+        <property name="visible">True</property>
+        <property name="spacing">4</property>
+        <child>
+          <object class="GtkSpinButton" id="bond_updelay">
+            <property name="visible">True</property>
+            <property name="can_focus">True</property>
+            <property name="invisible_char">&#x25CF;</property>
+            <property name="invisible_char_set">True</property>
+            <property name="adjustment">bond_updelay_adjustment</property>
+            <property name="snap_to_ticks">True</property>
+            <property name="numeric">True</property>
+          </object>
+          <packing>
+            <property name="position">0</property>
+          </packing>
+        </child>
+        <child>
+          <object class="GtkLabel" id="label2">
+            <property name="visible">True</property>
+            <property name="xalign">0</property>
+            <property name="label" translatable="yes">ms</property>
+          </object>
+          <packing>
+            <property name="position">1</property>
+          </packing>
+        </child>
+      </object>
+      <packing>
+        <property name="left_attach">1</property>
+        <property name="right_attach">2</property>
+        <property name="top_attach">6</property>
+        <property name="bottom_attach">7</property>
+        <property name="y_options">GTK_FILL</property>
+      </packing>
+    </child>
+    <child>
+      <object class="GtkHBox" id="bond_downdelay_box">
+        <property name="visible">True</property>
+        <property name="spacing">4</property>
+        <child>
+          <object class="GtkSpinButton" id="bond_downdelay">
+            <property name="visible">True</property>
+            <property name="can_focus">True</property>
+            <property name="invisible_char">&#x25CF;</property>
+            <property name="invisible_char_set">True</property>
+            <property name="adjustment">bond_downdelay_adjustment</property>
+            <property name="snap_to_ticks">True</property>
+            <property name="numeric">True</property>
+          </object>
+          <packing>
+            <property name="position">0</property>
+          </packing>
+        </child>
+        <child>
+          <object class="GtkLabel" id="label3">
+            <property name="visible">True</property>
+            <property name="xalign">0</property>
+            <property name="label" translatable="yes">ms</property>
+          </object>
+          <packing>
+            <property name="position">1</property>
+          </packing>
+        </child>
+      </object>
+      <packing>
+        <property name="left_attach">1</property>
+        <property name="right_attach">2</property>
+        <property name="top_attach">7</property>
+        <property name="bottom_attach">8</property>
+        <property name="y_options">GTK_FILL</property>
+      </packing>
+    </child>
+  </object>
+</interface>
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/ce-page.h.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/ce-page.h
index a1e0bc3..f6930f1 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/ce-page.h.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/ce-page.h
@@ -97,6 +97,8 @@ typedef struct {
 
 typedef CEPage* (*CEPageNewFunc)(NMConnection *connection,
                                  GtkWindow *parent,
+                                 NMRemoteSettingsSystem *system_settings,
+                                 NMAGConfSettings *gconf_settings,
                                  const char **out_secrets_setting_name,
                                  GError **error);
 
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/new-connection.c.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/new-connection.c
index 06fbc85..2bdc0bf 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/new-connection.c.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/new-connection.c
@@ -24,11 +24,13 @@
 
 #include "new-connection.h"
 #include "nm-connection-list.h"
+#include "nm-connection-editor.h"
 #include "page-wired.h"
 #include "page-wireless.h"
 #include "page-mobile.h"
 #include "page-dsl.h"
 #include "page-infiniband.h"
+#include "page-bond.h"
 #include "page-vpn.h"
 #include "vpn-helpers.h"
 
@@ -130,6 +132,12 @@ get_connection_type_list (void)
 	data.virtual = FALSE;
 	g_array_append_val (array, data);
 
+	data.name = _("Bond");
+	data.new_connection_func = bond_connection_new;
+	data.setting_type = NM_TYPE_SETTING_BOND;
+	data.virtual = TRUE;
+	g_array_append_val (array, data);
+
 	/* Add "VPN" only if there are plugins */
 	vpn_plugins_hash = vpn_get_plugins (NULL);
 	have_vpn_plugins  = vpn_plugins_hash && g_hash_table_size (vpn_plugins_hash);
@@ -331,7 +339,7 @@ set_up_connection_type_combo (GtkComboBox *combo,
 
 typedef struct {
 	GtkWindow *parent_window;
-	PageNewConnectionResultFunc result_func;
+	NewConnectionResultFunc result_func;
 	gpointer user_data;
 } NewConnectionData;
 
@@ -342,13 +350,23 @@ new_connection_result (NMConnection *connection,
                        gpointer user_data)
 {
 	NewConnectionData *ncd = user_data;
-	PageNewConnectionResultFunc result_func;
+	NewConnectionResultFunc result_func;
+	GtkWindow *parent_window;
+	const char *default_message = _("The connection editor dialog could not be initialized due to an unknown error.");
 
 	result_func = ncd->result_func;
 	user_data = ncd->user_data;
+	parent_window = ncd->parent_window;
 	g_slice_free (NewConnectionData, ncd);
 
-	result_func (connection, canceled, error, user_data);
+	if (!connection) {
+		nm_connection_editor_error (parent_window,
+		                            _("Could not create new connection"),
+		                            "%s",
+		                            (error && error->message) ? error->message : default_message);
+	}
+
+	result_func (connection, user_data);
 }
 
 void
@@ -357,7 +375,7 @@ new_connection_of_type (GtkWindow *parent_window,
                         NMRemoteSettingsSystem *system_settings,
                         NMAGConfSettings *gconf_settings,
                         PageNewConnectionFunc new_func,
-                        PageNewConnectionResultFunc result_func,
+                        NewConnectionResultFunc result_func,
                         gpointer user_data)
 {
 	NewConnectionData *ncd;
@@ -380,7 +398,7 @@ new_connection_dialog (GtkWindow *parent_window,
                        NMRemoteSettingsSystem *system_settings,
                        NMAGConfSettings *gconf_settings,
                        NewConnectionTypeFilterFunc type_filter_func,
-                       PageNewConnectionResultFunc result_func,
+                       NewConnectionResultFunc result_func,
                        gpointer user_data)
 {
 	new_connection_dialog_full (parent_window,
@@ -399,7 +417,7 @@ new_connection_dialog_full (GtkWindow *parent_window,
                             const char *primary_label,
                             const char *secondary_label,
                             NewConnectionTypeFilterFunc type_filter_func,
-                            PageNewConnectionResultFunc result_func,
+                            NewConnectionResultFunc result_func,
                             gpointer user_data)
 {
 	GtkBuilder *gui;
@@ -461,7 +479,134 @@ new_connection_dialog_full (GtkWindow *parent_window,
 		new_connection_of_type (parent_window, vpn_type, system_settings, gconf_settings,
 		                        new_func, result_func, user_data);
 	} else
-		result_func (NULL, TRUE, NULL, user_data);
+		result_func (NULL, user_data);
 
 	g_free (vpn_type);
 }
+
+typedef struct {
+	GtkWindow *parent_window;
+	NMConnectionEditor *editor;
+	DeleteConnectionResultFunc result_func;
+	gpointer user_data;
+} DeleteInfo;
+
+static void
+delete_cb (NMSettingsConnectionInterface *connection_iface,
+           GError *error,
+           gpointer user_data)
+{
+	DeleteInfo *info = user_data;
+	NMConnection *connection = NM_CONNECTION (connection_iface);
+	DeleteConnectionResultFunc result_func;
+	NMConnectionScope scope;
+
+	scope = nm_connection_get_scope (connection);
+
+	if (error) {
+		nm_connection_editor_error (info->parent_window,
+		                            _("Connection delete failed"),
+		                            "%s", error->message);
+	} else if (scope == NM_CONNECTION_SCOPE_USER) {
+		NMSettingConnection *s_con;
+		NMSettingVPN *s_vpn;
+		NMVpnPluginUiInterface *plugin;
+		GError *vpn_error = NULL;
+
+		s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
+		g_assert (s_con);
+
+		/* Clean up VPN secrets and any plugin-specific data */
+		if (strcmp (nm_setting_connection_get_connection_type (s_con), NM_SETTING_VPN_SETTING_NAME))
+			goto done;
+
+		s_vpn = (NMSettingVPN *) nm_connection_get_setting (connection, NM_TYPE_SETTING_VPN);
+		if (!s_vpn)
+			goto done;
+
+		plugin = vpn_get_plugin_by_service (nm_setting_vpn_get_service_type (s_vpn));
+		if (!plugin)
+			goto done;
+
+		if (!nm_vpn_plugin_ui_interface_delete_connection (plugin, connection, &vpn_error)) {
+			g_warning ("%s: couldn't clean up VPN connection on delete: (%d) %s",
+			           __func__,
+			           vpn_error ? vpn_error->code : -1,
+			           (vpn_error && vpn_error->message) ? vpn_error->message : "unknown");
+			g_clear_error (&vpn_error);
+		}
+	done:
+		;
+	}
+
+	if (info->editor) {
+		nm_connection_editor_set_busy (info->editor, FALSE);
+		g_object_unref (info->editor);
+	}
+	if (info->parent_window)
+		g_object_unref (info->parent_window);
+
+	result_func = info->result_func;
+	user_data = info->user_data;
+	g_free (info);
+
+	if (result_func)
+		(*result_func) (connection_iface, error == NULL, user_data);
+}
+
+void
+delete_connection (GtkWindow *parent_window,
+                   NMSettingsConnectionInterface *connection,
+                   gboolean ask_confirmation,
+                   DeleteConnectionResultFunc result_func,
+                   gpointer user_data)
+{
+	NMConnectionEditor *editor;
+	NMSettingConnection *s_con;
+	GtkWidget *dialog;
+	const char *id;
+	guint result;
+	DeleteInfo *info;
+
+	editor = nm_connection_editor_get (NM_CONNECTION (connection));
+
+	if (ask_confirmation) {
+		if (editor && nm_connection_editor_get_busy (editor)) {
+			/* Editor already has an operation in progress, raise it */
+			nm_connection_editor_present (editor);
+			return;
+		}
+
+		s_con = nm_connection_get_setting_connection (NM_CONNECTION (connection));
+		g_assert (s_con);
+		id = nm_setting_connection_get_id (s_con);
+
+		dialog = gtk_message_dialog_new (parent_window,
+		                                 GTK_DIALOG_DESTROY_WITH_PARENT,
+		                                 GTK_MESSAGE_QUESTION,
+		                                 GTK_BUTTONS_NONE,
+		                                 _("Are you sure you wish to delete the connection %s?"),
+		                                 id);
+		gtk_dialog_add_buttons (GTK_DIALOG (dialog),
+		                        GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
+		                        GTK_STOCK_DELETE, GTK_RESPONSE_YES,
+		                        NULL);
+
+		result = gtk_dialog_run (GTK_DIALOG (dialog));
+		gtk_widget_destroy (dialog);
+
+		if (result != GTK_RESPONSE_YES)
+			return;
+	}
+
+	info = g_malloc0 (sizeof (DeleteInfo));
+	info->editor = editor ? g_object_ref (editor) : NULL;
+	info->parent_window = parent_window ? g_object_ref (parent_window) : NULL;
+	info->result_func = result_func;
+	info->user_data = user_data;
+
+	if (editor)
+		nm_connection_editor_set_busy (editor, TRUE);
+
+	nm_settings_connection_interface_delete (connection, delete_cb, info);
+}
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/new-connection.h.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/new-connection.h
index f5616de..0950e48 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/new-connection.h.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/new-connection.h
@@ -34,12 +34,14 @@ ConnectionTypeData *get_connection_type_list (void);
 
 typedef gboolean (*NewConnectionTypeFilterFunc) (GType type,
                                                  gpointer user_data);
+typedef void (*NewConnectionResultFunc) (NMConnection *connection,
+                                         gpointer user_data);
 
 void new_connection_dialog      (GtkWindow *parent_window,
                                  NMRemoteSettingsSystem *system_settings,
                                  NMAGConfSettings *gconf_settings,
                                  NewConnectionTypeFilterFunc type_filter_func,
-                                 PageNewConnectionResultFunc result_func,
+                                 NewConnectionResultFunc result_func,
                                  gpointer user_data);
 
 void new_connection_dialog_full (GtkWindow *parent_window,
@@ -48,7 +50,7 @@ void new_connection_dialog_full (GtkWindow *parent_window,
                                  const char *primary_label,
                                  const char *secondary_label,
                                  NewConnectionTypeFilterFunc type_filter_func,
-                                 PageNewConnectionResultFunc result_func,
+                                 NewConnectionResultFunc result_func,
                                  gpointer user_data);
 
 void new_connection_of_type (GtkWindow *parent_window,
@@ -56,8 +58,18 @@ void new_connection_of_type (GtkWindow *parent_window,
                              NMRemoteSettingsSystem *system_settings,
                              NMAGConfSettings *gconf_settings,
                              PageNewConnectionFunc new_func,
-                             PageNewConnectionResultFunc result_func,
+                             NewConnectionResultFunc result_func,
                              gpointer user_data);
 
+typedef void (*DeleteConnectionResultFunc) (NMSettingsConnectionInterface *connection,
+                                            gboolean deleted,
+                                            gpointer user_data);
+
+void delete_connection (GtkWindow *parent_window,
+                        NMSettingsConnectionInterface *connection,
+                        gboolean ask_confirmation,
+                        DeleteConnectionResultFunc result_func,
+                        gpointer user_data);
+
 #endif  /* __CONNECTION_HELPERS_H__ */
 
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/nm-connection-editor.c.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/nm-connection-editor.c
index 945df75..967b85b 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/nm-connection-editor.c.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/nm-connection-editor.c
@@ -46,6 +46,7 @@
 #include <nm-setting-gsm.h>
 #include <nm-setting-cdma.h>
 #include <nm-setting-infiniband.h>
+#include <nm-setting-bond.h>
 #include <nm-utils.h>
 
 #include "nm-connection-editor.h"
@@ -64,8 +65,10 @@
 #include "page-ppp.h"
 #include "page-vpn.h"
 #include "page-infiniband.h"
+#include "page-bond.h"
 #include "ce-polkit-button.h"
 #include "vpn-helpers.h"
+#include "new-connection.h"
 
 G_DEFINE_TYPE (NMConnectionEditor, nm_connection_editor, G_TYPE_OBJECT)
 
@@ -76,6 +79,8 @@ enum {
 
 static guint editor_signals[EDITOR_LAST_SIGNAL] = { 0 };
 
+static GHashTable *active_editors;
+
 static gboolean nm_connection_editor_set_connection (NMConnectionEditor *editor,
                                                      NMConnection *connection,
                                                      GError **error);
@@ -180,7 +185,16 @@ update_sensitivity (NMConnectionEditor *editor)
 		}
 	}
 
-	gtk_widget_set_sensitive (GTK_WIDGET (editor->system_checkbutton), actionable && authorized);
+	if (   !g_strcmp0 (nm_setting_connection_get_connection_type (s_con),
+	                   NM_SETTING_BOND_SETTING_NAME)
+	    || !g_strcmp0 (nm_setting_connection_get_slave_type (s_con),
+	                   NM_SETTING_BOND_SETTING_NAME)) {
+		/* Bond connections and their slaves must be system connections */
+		gtk_widget_set_sensitive (GTK_WIDGET (editor->system_checkbutton), FALSE);
+	} else {
+		gtk_widget_set_sensitive (GTK_WIDGET (editor->system_checkbutton),
+		                          actionable && authorized);
+	}
 
 	/* Cancel button is always sensitive */
 	gtk_widget_set_sensitive (GTK_WIDGET (editor->cancel_button), TRUE);
@@ -192,7 +206,7 @@ update_sensitivity (NMConnectionEditor *editor)
 	gtk_widget_set_sensitive (widget, sensitive);
 
 	widget = GTK_WIDGET (gtk_builder_get_object (editor->builder, "connection_autoconnect"));
-	gtk_widget_set_sensitive (widget, sensitive);
+	gtk_widget_set_sensitive (widget, sensitive && !nm_setting_connection_get_master (s_con));
 
 	widget = GTK_WIDGET (gtk_builder_get_object (editor->builder, "connection_name"));
 	gtk_widget_set_sensitive (widget, sensitive);
@@ -335,6 +349,8 @@ dispose (GObject *object)
 
 	editor->disposed = TRUE;
 
+	g_hash_table_remove (active_editors, editor->orig_connection);
+
 	g_slist_foreach (editor->initializing_pages, (GFunc) g_object_unref, NULL);
 	g_slist_free (editor->initializing_pages);
 	editor->initializing_pages = NULL;
@@ -366,10 +382,22 @@ dispose (GObject *object)
 		gtk_widget_destroy (editor->window);
 		editor->window = NULL;
 	}
+	if (editor->parent_window) {
+		g_object_unref (editor->parent_window);
+		editor->parent_window = NULL;
+	}
 	if (editor->builder) {
 		g_object_unref (editor->builder);
 		editor->builder = NULL;
 	}
+	if (editor->system_settings) {
+		g_object_unref (editor->system_settings);
+		editor->system_settings = NULL;
+	}
+	if (editor->gconf_settings) {
+		g_object_unref (editor->gconf_settings);
+		editor->gconf_settings = NULL;
+	}
 
 	G_OBJECT_CLASS (nm_connection_editor_parent_class)->dispose (object);
 }
@@ -389,32 +417,37 @@ nm_connection_editor_class_init (NMConnectionEditorClass *klass)
 		              G_SIGNAL_RUN_FIRST,
 		              G_STRUCT_OFFSET (NMConnectionEditorClass, done),
 		              NULL, NULL,
-		              nma_marshal_VOID__INT_POINTER,
-		              G_TYPE_NONE, 2, G_TYPE_INT, G_TYPE_POINTER);
+		              nma_marshal_VOID__ENUM,
+		              G_TYPE_NONE, 1, GTK_TYPE_RESPONSE_TYPE);
 }
 
 NMConnectionEditor *
-nm_connection_editor_new (NMConnection *connection,
-                          NMRemoteSettingsSystem *settings,
-                          GError **error)
+nm_connection_editor_new (GtkWindow *parent_window,
+                          NMConnection *connection,
+                          NMRemoteSettingsSystem *system_settings,
+                          NMAGConfSettings *gconf_settings)
 {
 	NMConnectionEditor *editor;
 	GtkWidget *hbox;
+	gboolean is_new;
 	gboolean sensitive = TRUE, use_polkit = FALSE;
+	GError *error = NULL;
 
 	g_return_val_if_fail (NM_IS_CONNECTION (connection), NULL);
 
+	is_new = !NM_IS_SETTINGS_CONNECTION_INTERFACE (connection);
+
 	editor = g_object_new (NM_TYPE_CONNECTION_EDITOR, NULL);
-	if (!editor) {
-		g_set_error (error, NMA_ERROR, NMA_ERROR_GENERIC, "%s", _("Error creating connection editor dialog."));
-		return NULL;
-	}
+	editor->parent_window = parent_window ? g_object_ref (parent_window) : NULL;
+	editor->system_settings = g_object_ref (system_settings);
+	editor->gconf_settings = g_object_ref (gconf_settings);
+	editor->is_new_connection = is_new;
 
-	g_object_get (settings,
+	g_object_get (system_settings,
 	              NM_SETTINGS_SYSTEM_INTERFACE_CAN_MODIFY,
 	              &editor->system_settings_can_modify,
 	              NULL);
-	g_signal_connect (settings,
+	g_signal_connect (system_settings,
 	                  "notify::" NM_SETTINGS_SYSTEM_INTERFACE_CAN_MODIFY,
 	                  G_CALLBACK (can_modify_changed_cb),
 	                  editor);
@@ -432,7 +465,7 @@ nm_connection_editor_new (NMConnection *connection,
 	                                          _("Apply..."),
 	                                          _("Authenticate to save this connection for all users of this machine."),
 	                                          GTK_STOCK_APPLY,
-	                                          settings,
+	                                          system_settings,
 	                                          NM_SETTINGS_SYSTEM_PERMISSION_CONNECTION_MODIFY);
 	ce_polkit_button_set_use_polkit (CE_POLKIT_BUTTON (editor->ok_button), use_polkit);
 
@@ -444,14 +477,60 @@ nm_connection_editor_new (NMConnection *connection,
 	gtk_box_pack_end (GTK_BOX (hbox), editor->ok_button, TRUE, TRUE, 0);
 	gtk_widget_show_all (editor->ok_button);
 
-	if (!nm_connection_editor_set_connection (editor, connection, error)) {
+	if (!nm_connection_editor_set_connection (editor, connection, &error)) {
+		nm_connection_editor_error (parent_window,
+		                            is_new ? _("Could not create connection") : _("Could not edit connection"),
+		                            "%s",
+		                            error ? error->message : _("Unknown error creating connection editor dialog."));
+		g_clear_error (&error);
 		g_object_unref (editor);
 		return NULL;
 	}
 
+	if (!active_editors)
+		active_editors = g_hash_table_new (NULL, NULL);
+	g_hash_table_insert (active_editors, connection, editor);
+
 	return editor;
 }
 
+NMConnectionEditor *
+nm_connection_editor_get (NMConnection *connection)
+{
+	if (!active_editors)
+		return NULL;
+
+	return g_hash_table_lookup (active_editors, connection);
+}
+
+/* Returns an editor for @slave's master, if any */
+NMConnectionEditor *
+nm_connection_editor_get_master (NMConnection *slave)
+{
+	GHashTableIter iter;
+	gpointer connection, editor;
+	NMSettingConnection *s_con;
+	const char *master;
+
+	if (!active_editors)
+		return NULL;
+
+	s_con = nm_connection_get_setting_connection (slave);
+	master = nm_setting_connection_get_master (s_con);
+	if (!master)
+		return NULL;
+
+	g_hash_table_iter_init (&iter, active_editors);
+	while (g_hash_table_iter_next (&iter, &connection, &editor)) {
+		if (!g_strcmp0 (master, nm_connection_get_uuid (connection)))
+			return editor;
+		if (!g_strcmp0 (master, nm_connection_get_virtual_iface_name (connection)))
+			return editor;
+	}
+
+	return NULL;
+}
+
 NMConnection *
 nm_connection_editor_get_connection (NMConnectionEditor *editor)
 {
@@ -461,14 +540,25 @@ nm_connection_editor_get_connection (NMConnectionEditor *editor)
 }
 
 gboolean
-nm_connection_editor_update_connection (NMConnectionEditor *editor, GError **error)
+nm_connection_editor_update_connection (NMConnectionEditor *editor)
 {
 	GHashTable *settings;
+	GError *error = NULL;
 
 	g_return_val_if_fail (NM_IS_CONNECTION_EDITOR (editor), FALSE);
 
-	if (!nm_connection_verify (editor->connection, error))
+	if (!nm_connection_verify (editor->connection, &error)) {
+		/* In theory, this cannot happen: the "Save..." button should only
+		 * be sensitive if the connection is valid.
+		 */
+		nm_connection_editor_error (GTK_WINDOW (editor->window),
+		                            _("Error saving connection"),
+		                            _("The property '%s' / '%s' is invalid: %d"),
+		                            g_type_name (nm_connection_lookup_setting_type_by_quark (error->domain)),
+		                            error->message, error->code);
+		g_error_free (error);
 		return FALSE;
+	}
 
 	/* Copy the modified connection to the original connection */
 	settings = nm_connection_to_hash (editor->connection);
@@ -554,7 +644,11 @@ page_initialized (CEPage *page, gpointer unused, GError *error, gpointer user_da
 
 	if (error) {
 		gtk_widget_hide (editor->window);
-		g_signal_emit (editor, editor_signals[EDITOR_DONE], 0, GTK_RESPONSE_NONE, error);
+		nm_connection_editor_error (editor->parent_window,
+		                            _("Error initializing editor"),
+		                            "%s", error->message);
+		g_error_free (error);
+		g_signal_emit (editor, editor_signals[EDITOR_DONE], 0, GTK_RESPONSE_NONE);
 		return;
 	}
 
@@ -702,7 +796,9 @@ add_page (NMConnectionEditor *editor,
 	g_return_val_if_fail (func != NULL, FALSE);
 	g_return_val_if_fail (connection != NULL, FALSE);
 
-	page = (*func) (connection, GTK_WINDOW (editor->window), &secrets_setting_name, error);
+	page = (*func) (connection, GTK_WINDOW (editor->window),
+	                editor->system_settings, editor->gconf_settings,
+	                &secrets_setting_name, error);
 	if (!page)
 		return FALSE;
 
@@ -725,7 +821,9 @@ nm_connection_editor_set_connection (NMConnectionEditor *editor,
 {
 	NMSettingConnection *s_con;
 	const char *connection_type;
+	const char *slave_type;
 	gboolean success = FALSE;
+	gboolean add_ip4 = TRUE, add_ip6 = TRUE;
 
 	g_return_val_if_fail (NM_IS_CONNECTION_EDITOR (editor), FALSE);
 	g_return_val_if_fail (NM_IS_CONNECTION (orig_connection), FALSE);
@@ -749,24 +847,15 @@ nm_connection_editor_set_connection (NMConnectionEditor *editor,
 			goto out;
 		if (!add_page (editor, ce_page_wired_security_new, editor->connection, error))
 			goto out;
-		if (!add_page (editor, ce_page_ip4_new, editor->connection, error))
-			goto out;
-		if (!add_page (editor, ce_page_ip6_new, editor->connection, error))
-			goto out;
 	} else if (!strcmp (connection_type, NM_SETTING_WIRELESS_SETTING_NAME)) {
 		if (!add_page (editor, ce_page_wireless_new, editor->connection, error))
 			goto out;
 		if (!add_page (editor, ce_page_wireless_security_new, editor->connection, error))
 			goto out;
-		if (!add_page (editor, ce_page_ip4_new, editor->connection, error))
-			goto out;
-		if (!add_page (editor, ce_page_ip6_new, editor->connection, error))
-			goto out;
 	} else if (!strcmp (connection_type, NM_SETTING_VPN_SETTING_NAME)) {
 		if (!add_page (editor, ce_page_vpn_new, editor->connection, error))
 			goto out;
-		if (!add_page (editor, ce_page_ip4_new, editor->connection, error))
-			goto out;
+		add_ip6 = FALSE;
 	} else if (!strcmp (connection_type, NM_SETTING_PPPOE_SETTING_NAME)) {
 		if (!add_page (editor, ce_page_dsl_new, editor->connection, error))
 			goto out;
@@ -774,27 +863,33 @@ nm_connection_editor_set_connection (NMConnectionEditor *editor,
 			goto out;
 		if (!add_page (editor, ce_page_ppp_new, editor->connection, error))
 			goto out;
-		if (!add_page (editor, ce_page_ip4_new, editor->connection, error))
-			goto out;
+		add_ip6 = FALSE;
 	} else if (!strcmp (connection_type, NM_SETTING_GSM_SETTING_NAME) || 
 	           !strcmp (connection_type, NM_SETTING_CDMA_SETTING_NAME)) {
 		if (!add_page (editor, ce_page_mobile_new, editor->connection, error))
 			goto out;
 		if (!add_page (editor, ce_page_ppp_new, editor->connection, error))
 			goto out;
-		if (!add_page (editor, ce_page_ip4_new, editor->connection, error))
-			goto out;
+		add_ip6 = FALSE;
 	} else if (!strcmp (connection_type, NM_SETTING_INFINIBAND_SETTING_NAME)) {
 		if (!add_page (editor, ce_page_infiniband_new, editor->connection, error))
 			goto out;
-		if (!add_page (editor, ce_page_ip4_new, editor->connection, error))
-			goto out;
-		if (!add_page (editor, ce_page_ip6_new, editor->connection, error))
+	} else if (!strcmp (connection_type, NM_SETTING_BOND_SETTING_NAME)) {
+		if (!add_page (editor, ce_page_bond_new, editor->connection, error))
 			goto out;
 	} else {
 		g_warning ("Unhandled setting type '%s'", connection_type);
 	}
 
+	slave_type = nm_setting_connection_get_slave_type (s_con);
+	if (!g_strcmp0 (slave_type, NM_SETTING_BOND_SETTING_NAME))
+		add_ip4 = add_ip6 = FALSE;
+
+	if (add_ip4 && !add_page (editor, ce_page_ip4_new, editor->connection, error))
+		goto out;
+	if (add_ip6 && !add_page (editor, ce_page_ip6_new, editor->connection, error))
+		goto out;
+
 	/* set the UI */
 	recheck_initialization (editor);
 	success = TRUE;
@@ -816,7 +911,13 @@ cancel_button_clicked_cb (GtkWidget *widget, gpointer user_data)
 {
 	NMConnectionEditor *self = NM_CONNECTION_EDITOR (user_data);
 
-	g_signal_emit (self, editor_signals[EDITOR_DONE], 0, GTK_RESPONSE_CANCEL, NULL);
+	/* If the dialog is busy waiting for authorization or something,
+	 * don't destroy it until authorization returns.
+	 */
+	if (self->busy)
+		return;
+
+	g_signal_emit (self, editor_signals[EDITOR_DONE], 0, GTK_RESPONSE_CANCEL);
 }
 
 static void
@@ -826,11 +927,147 @@ editor_closed_cb (GtkWidget *widget, GdkEvent *event, gpointer user_data)
 }
 
 static void
+update_complete (NMConnectionEditor *self, GError *error)
+{
+	nm_connection_editor_set_busy (self, FALSE);
+
+	if (error) {
+		nm_connection_editor_error (self->parent_window, _("Connection update failed"),
+		                            "%s", error->message);
+
+		/* Leave the editor open */
+		return;
+	}
+
+	g_signal_emit (self, editor_signals[EDITOR_DONE], 0, GTK_RESPONSE_OK);
+}
+
+static void
+update_remove_result_cb (NMSettingsConnectionInterface *connection,
+                         gboolean deleted,
+                         gpointer user_data)
+{
+	NMConnectionEditor *self = NM_CONNECTION_EDITOR (user_data);
+
+	update_complete (self, NULL);
+}
+
+static void
+update_add_result_cb (NMSettingsInterface *settings,
+                      GError *error,
+                      gpointer user_data)
+{
+	NMConnectionEditor *self = NM_CONNECTION_EDITOR (user_data);
+
+	if (error) {
+		/* set the old scope back on the connection */
+		NMConnectionScope scope;
+
+		scope = nm_connection_get_scope (self->connection);
+		if (scope == NM_CONNECTION_SCOPE_SYSTEM)
+			scope = NM_CONNECTION_SCOPE_USER;
+		else if (scope == NM_CONNECTION_SCOPE_USER)
+			scope = NM_CONNECTION_SCOPE_SYSTEM;
+		else
+			g_assert_not_reached ();
+
+		nm_connection_set_scope (self->connection, scope);
+		update_complete (self, error);
+		return;
+	}
+
+	/* Now try to remove the original connection */
+	delete_connection (self->parent_window,
+	                   NM_SETTINGS_CONNECTION_INTERFACE (self->orig_connection),
+	                   FALSE, update_remove_result_cb, self);
+}
+
+static void
+added_connection_cb (NMSettingsInterface *settings,
+                     GError *error,
+                     gpointer user_data)
+{
+	NMConnectionEditor *self = user_data;
+
+	nm_connection_editor_set_busy (self, FALSE);
+
+	if (error) {
+		nm_connection_editor_error (self->parent_window, _("Connection add failed"),
+		                            "%s", error->message);
+
+		/* Leave the editor open */
+		return;
+	}
+
+	g_signal_emit (self, editor_signals[EDITOR_DONE], 0, GTK_RESPONSE_OK);
+}
+
+static void
+update_cb (NMSettingsConnectionInterface *connection, GError *error, gpointer user_data)
+{
+	NMConnectionEditor *self = NM_CONNECTION_EDITOR (user_data);
+
+	/* Clear secrets so they don't lay around in memory; they'll get requested
+	 * again anyway next time the connection is edited.
+	 */
+	nm_connection_clear_secrets (NM_CONNECTION (connection));
+
+	update_complete (self, error);
+}
+
+static void
 ok_button_clicked_cb (GtkWidget *widget, gpointer user_data)
 {
 	NMConnectionEditor *self = NM_CONNECTION_EDITOR (user_data);
+	NMConnectionScope orig_scope, new_scope;
+	NMSettingsInterface *settings;
 
-	g_signal_emit (self, editor_signals[EDITOR_DONE], 0, GTK_RESPONSE_OK, NULL);
+	/* If the dialog is busy waiting for authorization or something,
+	 * don't destroy it until authorization returns.
+	 */
+	if (self->busy)
+		return;
+
+	orig_scope = nm_connection_get_scope (self->orig_connection);
+
+	if (!nm_connection_editor_update_connection (self))
+		return;
+
+	new_scope = nm_connection_get_scope (self->connection);
+	if (new_scope == NM_CONNECTION_SCOPE_SYSTEM)
+		settings = NM_SETTINGS_INTERFACE (self->system_settings);
+	else if (new_scope == NM_CONNECTION_SCOPE_USER)
+		settings = NM_SETTINGS_INTERFACE (self->gconf_settings);
+	else
+		g_assert_not_reached ();
+
+	nm_connection_editor_set_busy (self, TRUE);
+
+	if (self->is_new_connection) {
+		nm_settings_interface_add_connection (settings,
+		                                      self->orig_connection,
+		                                      added_connection_cb,
+		                                      self);
+		return;
+	}
+
+	if (new_scope == orig_scope) {
+		/* The easy part: Connection is just updated and has the same scope.
+		 * Update() actually saves the connection settings to backing storage,
+		 * either GConf or over D-Bus.
+		 */
+		nm_settings_connection_interface_update (NM_SETTINGS_CONNECTION_INTERFACE (self->orig_connection),
+		                                         update_cb, self);
+      } else {
+		/* The hard part: Connection scope changed:
+		 * Add the modified connection to the new settings service, then delete
+		 * the original connection from the old settings service.
+		 */
+		nm_settings_interface_add_connection (settings,
+		                                      self->orig_connection,
+		                                      update_add_result_cb,
+		                                      self);
+	}
 }
 
 static void
@@ -904,3 +1141,29 @@ nm_connection_editor_set_busy (NMConnectionEditor *editor, gboolean busy)
 	}
 }
 
+void
+nm_connection_editor_error (GtkWindow *parent, const char *heading, const char *format, ...)
+{
+	GtkWidget *dialog;
+	va_list args;
+	char *message;
+
+	dialog = gtk_message_dialog_new (parent,
+	                                 GTK_DIALOG_DESTROY_WITH_PARENT,
+	                                 GTK_MESSAGE_ERROR,
+	                                 GTK_BUTTONS_CLOSE,
+	                                 "%s", heading);
+
+	va_start (args, format);
+	message = g_strdup_vprintf (format, args);
+	va_end (args);
+
+	gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog), "%s", message);
+	g_free (message);
+
+	gtk_widget_show_all (dialog);
+	gtk_window_present (GTK_WINDOW (dialog));
+	gtk_dialog_run (GTK_DIALOG (dialog));
+	gtk_widget_destroy (dialog);
+}
+
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/nm-connection-editor.h.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/nm-connection-editor.h
index 6580f8f..7964dad 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/nm-connection-editor.h.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/nm-connection-editor.h
@@ -27,6 +27,7 @@
 #include <glib-object.h>
 
 #include "nm-remote-settings-system.h"
+#include "nma-gconf-settings.h"
 #include "utils.h"
 
 #define NM_TYPE_CONNECTION_EDITOR    (nm_connection_editor_get_type ())
@@ -39,9 +40,14 @@ typedef struct {
 	GObject parent;
 	gboolean disposed;
 
+	GtkWindow *parent_window;
+	NMRemoteSettingsSystem *system_settings;
+	NMAGConfSettings *gconf_settings;
+
 	/* private data */
 	NMConnection *connection;
 	NMConnection *orig_connection;
+	gboolean is_new_connection;
 
 	NMConnectionScope orig_scope;
 
@@ -70,17 +76,25 @@ typedef struct {
 } NMConnectionEditorClass;
 
 GType               nm_connection_editor_get_type (void);
-NMConnectionEditor *nm_connection_editor_new (NMConnection *connection,
-                                              NMRemoteSettingsSystem *settings,
-                                              GError **error);
+NMConnectionEditor *nm_connection_editor_new (GtkWindow *parent_window,
+                                              NMConnection *connection,
+                                              NMRemoteSettingsSystem *system_settings,
+                                              NMAGConfSettings *gconf_settings);
+NMConnectionEditor *nm_connection_editor_get (NMConnection *connection);
+NMConnectionEditor *nm_connection_editor_get_master (NMConnection *slave);
 
 void                nm_connection_editor_present (NMConnectionEditor *editor);
 void                nm_connection_editor_run (NMConnectionEditor *editor);
 void                nm_connection_editor_save_vpn_secrets (NMConnectionEditor *editor);
 NMConnection *      nm_connection_editor_get_connection (NMConnectionEditor *editor);
-gboolean            nm_connection_editor_update_connection (NMConnectionEditor *editor, GError **error);
+gboolean            nm_connection_editor_update_connection (NMConnectionEditor *editor);
 GtkWindow *         nm_connection_editor_get_window (NMConnectionEditor *editor);
 gboolean            nm_connection_editor_get_busy (NMConnectionEditor *editor);
 void                nm_connection_editor_set_busy (NMConnectionEditor *editor, gboolean busy);
 
+void                nm_connection_editor_error (GtkWindow *parent,
+                                                const char *heading,
+                                                const char *format,
+                                                ...);
+
 #endif
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/nm-connection-list.c.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/nm-connection-list.c
index bdcd87a..027ae4d 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/nm-connection-list.c.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/nm-connection-list.c
@@ -77,32 +77,6 @@ static guint list_signals[LIST_LAST_SIGNAL] = { 0 };
 #define COL_GTYPE      4
 #define COL_ORDER      5
 
-static void
-error_dialog (GtkWindow *parent, const char *heading, const char *format, ...)
-{
-	GtkWidget *dialog;
-	va_list args;
-	char *message;
-
-	dialog = gtk_message_dialog_new (parent,
-	                                 GTK_DIALOG_DESTROY_WITH_PARENT,
-	                                 GTK_MESSAGE_ERROR,
-	                                 GTK_BUTTONS_CLOSE,
-	                                 "%s", heading);
-
-	va_start (args, format);
-	message = g_strdup_vprintf (format, args);
-	va_end (args);
-
-	gtk_message_dialog_format_secondary_text (GTK_MESSAGE_DIALOG (dialog), "%s", message);
-	g_free (message);
-
-	gtk_widget_show_all (dialog);
-	gtk_window_present (GTK_WINDOW (dialog));
-	gtk_dialog_run (GTK_DIALOG (dialog));
-	gtk_widget_destroy (dialog);
-}
-
 static NMSettingsConnectionInterface *
 get_active_connection (GtkTreeView *treeview)
 {
@@ -255,383 +229,75 @@ update_connection_row (NMConnectionList *self,
 	gtk_tree_model_filter_refilter (self->filter);
 }
 
-
-/**********************************************/
-/* Connection deleting */
-
-typedef void (*DeleteResultFunc) (NMConnectionList *list,
-                                  GError *error,
-                                  gpointer user_data);
-
-typedef struct {
-	NMConnectionList *list;
-	NMSettingsConnectionInterface *original;
-	NMConnectionEditor *editor;
-	DeleteResultFunc callback;
-	gpointer callback_data;
-} DeleteInfo;
-
-static void
-delete_cb (NMSettingsConnectionInterface *connection_iface,
-           GError *error,
-           gpointer user_data)
-{
-	DeleteInfo *info = user_data;
-	NMConnection *connection = NM_CONNECTION (connection_iface);
-	NMConnectionScope scope;
-
-	if (info->editor)
-		nm_connection_editor_set_busy (info->editor, FALSE);
-
-	scope = nm_connection_get_scope (connection);
-	if (!error && (scope == NM_CONNECTION_SCOPE_USER)) {
-		NMSettingConnection *s_con;
-		NMSettingVPN *s_vpn;
-		NMVpnPluginUiInterface *plugin;
-		GError *vpn_error = NULL;
-
-		s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
-		g_assert (s_con);
-
-		/* Clean up VPN secrets and any plugin-specific data */
-		if (strcmp (nm_setting_connection_get_connection_type (s_con), NM_SETTING_VPN_SETTING_NAME))
-			goto done;
-
-		s_vpn = (NMSettingVPN *) nm_connection_get_setting (connection, NM_TYPE_SETTING_VPN);
-		if (!s_vpn)
-			goto done;
-
-		plugin = vpn_get_plugin_by_service (nm_setting_vpn_get_service_type (s_vpn));
-		if (!plugin)
-			goto done;
-
-		if (!nm_vpn_plugin_ui_interface_delete_connection (plugin, connection, &vpn_error)) {
-			g_warning ("%s: couldn't clean up VPN connection on delete: (%d) %s",
-			           __func__,
-			           vpn_error ? vpn_error->code : -1,
-			           (vpn_error && vpn_error->message) ? vpn_error->message : "unknown");
-			g_clear_error (&vpn_error);
-		}
-	}
-
-done:
-	info->callback (info->list, error, info->callback_data);
-	g_free (info);
-}
-
-static void
-delete_connection (NMConnectionList *list,
-                   NMSettingsConnectionInterface *connection,
-                   DeleteResultFunc callback,
-                   gpointer user_data)
-{
-	DeleteInfo *info;
-	NMConnectionEditor *editor;
-
-	editor = g_hash_table_lookup (list->editors, connection);
-
-	info = g_malloc0 (sizeof (DeleteInfo));
-	info->list = list;
-	info->callback = callback;
-	info->callback_data = user_data;
-	info->editor = editor;
-
-	if (editor)
-		nm_connection_editor_set_busy (editor, TRUE);
-
-	nm_settings_connection_interface_delete (connection, delete_cb, info);
-}
-
-/**********************************************/
-/* Connection adding */
-
-typedef void (*AddResultFunc) (NMConnectionList *list,
-                               GError *error,
-                               gpointer user_data);
-
-typedef struct {
-	NMConnectionList *list;
-	NMConnectionEditor *editor;
-	AddResultFunc callback;
-	gpointer callback_data;
-} AddInfo;
-
-static void
-add_cb (NMSettingsInterface *settings,
-        GError *error,
-        gpointer user_data)
-{
-	AddInfo *info = user_data;
-	NMConnection *connection;
-
-	nm_connection_editor_set_busy (info->editor, FALSE);
-
-	if (!error) {
-		/* Let the VPN plugin save its secrets */
-		connection = nm_connection_editor_get_connection (info->editor);
-		if (nm_connection_get_scope (connection) == NM_CONNECTION_SCOPE_USER)
-			nm_connection_editor_save_vpn_secrets (info->editor);
-	}
-
-	info->callback (info->list, error, info->callback_data);
-	g_free (info);
-}
-
-static void
-add_connection (NMConnectionList *self,
-                NMConnectionEditor *editor,
-                AddResultFunc callback,
-                gpointer callback_data)
-{
-	NMSettingsInterface *settings = NULL;
-	NMConnection *connection;
-	NMConnectionScope scope;
-	AddInfo *info;
-
-	info = g_malloc0 (sizeof (AddInfo));
-	info->list = self;
-	info->editor = editor;
-	info->callback = callback;
-	info->callback_data = callback_data;
-
-	connection = nm_connection_editor_get_connection (editor);
-	g_assert (connection);
-	scope = nm_connection_get_scope (connection);
-	if (scope == NM_CONNECTION_SCOPE_SYSTEM)
-		settings = NM_SETTINGS_INTERFACE (self->system_settings);
-	else if (scope == NM_CONNECTION_SCOPE_USER)
-		settings = NM_SETTINGS_INTERFACE (self->gconf_settings);
-	else
-		g_assert_not_reached ();
-
-	nm_connection_editor_set_busy (editor, TRUE);
-	nm_settings_interface_add_connection (settings, connection, add_cb, info);
-}
-
-/**********************************************/
-/* Connection updating */
-
-typedef void (*UpdateResultFunc) (NMConnectionList *list,
-                                  NMSettingsConnectionInterface *connection,
-                                  GError *error,
-                                  gpointer user_data);
-
-typedef struct {
-	NMConnectionList *list;
-	NMConnectionEditor *editor;
-	NMSettingsConnectionInterface *connection;
-	NMConnectionScope orig_scope;
-	UpdateResultFunc callback;
-	gpointer callback_data;
-} UpdateInfo;
-
-static void
-update_complete (UpdateInfo *info, GError *error)
-{
-	info->callback (info->list, info->connection, error, info->callback_data);
-	g_object_unref (info->connection);
-	g_free (info);
-}
-
-static void
-update_remove_result_cb (NMConnectionList *list,
-                         GError *error,
-                         gpointer user_data)
-{
-	UpdateInfo *info = user_data;
-
-	update_complete (info, error);
-}
-
 static void
-update_add_result_cb (NMConnectionList *list, GError *error, gpointer user_data)
+delete_slaves_of_connection (NMConnectionList *list, NMConnection *connection)
 {
-	UpdateInfo *info = user_data;
+	const char *uuid, *iface;
+	GtkTreeIter iter, types_iter;
 
-	if (error) {
-		/* set the old scope back on the connection */
-		nm_connection_set_scope (NM_CONNECTION (info->connection), info->orig_scope);
-		update_complete (info, error);
+	if (!gtk_tree_model_get_iter_first (list->model, &types_iter))
 		return;
-	}
-
-	/* Now try to remove the original connection */
-	delete_connection (list, info->connection, update_remove_result_cb, info);
-}
-
-static void
-update_cb (NMSettingsConnectionInterface *connection,
-           GError *error,
-           gpointer user_data)
-{
-	UpdateInfo *info = user_data;
 
-	nm_connection_editor_set_busy (info->editor, FALSE);
+	uuid = nm_connection_get_uuid (connection);
+	iface = nm_connection_get_virtual_iface_name (connection);
 
-	if (!error) {
-		/* Save user-connection vpn secrets */
-		if (nm_connection_get_scope (NM_CONNECTION (connection)) == NM_CONNECTION_SCOPE_USER)
-			nm_connection_editor_save_vpn_secrets (info->editor);
-	}
-
-	/* Clear secrets so they don't lay around in memory; they'll get requested
-	 * again anyway next time the connection is edited.
-	 */
-	nm_connection_clear_secrets (NM_CONNECTION (connection));
+	do {
+		if (!gtk_tree_model_iter_children (list->model, &iter, &types_iter))
+			continue;
 
-	update_complete (info, error);
-}
+		do {
+			NMSettingsConnectionInterface *candidate = NULL;
+			NMSettingConnection *s_con;
+			const char *master;
 
-static void
-update_connection (NMConnectionList *list,
-                   NMConnectionEditor *editor,
-                   NMSettingsConnectionInterface *connection,
-                   NMConnectionScope orig_scope,
-                   UpdateResultFunc callback,
-                   gpointer user_data)
-{
-	NMConnectionScope new_scope;
-	UpdateInfo *info;
-
-	info = g_malloc0 (sizeof (UpdateInfo));
-	info->list = list;
-	info->editor = editor;
-	info->connection = g_object_ref (connection);
-	info->orig_scope = orig_scope;
-	info->callback = callback;
-	info->callback_data = user_data;
-
-	new_scope = nm_connection_get_scope (NM_CONNECTION (connection));
-	if (new_scope == orig_scope) {
-		/* The easy part: Connection is just updated and has the same scope */
-		GHashTable *new_settings;
-		GError *error = NULL;
-
-		/* System connections need the certificates filled because the
-		 * applet private values that we use to store the path to certificates
-		 * and private keys don't go through D-Bus; they are private of course!
-		 */
-		if (new_scope == NM_CONNECTION_SCOPE_SYSTEM) {
-			new_settings = nm_connection_to_hash (NM_CONNECTION (connection));
-			if (!nm_connection_replace_settings (NM_CONNECTION (connection),
-			                                     new_settings,
-			                                     &error)) {
-				update_complete (info, error);
-				g_error_free (error);
-				return;
+			gtk_tree_model_get (list->model, &iter,
+			                    COL_CONNECTION, &candidate,
+			                    -1);
+			s_con = nm_connection_get_setting_connection (NM_CONNECTION (candidate));
+			master = nm_setting_connection_get_master (s_con);
+			if (master) {
+				if (!g_strcmp0 (master, uuid) || !g_strcmp0 (master, iface))
+					delete_connection (NULL, candidate, FALSE, NULL, NULL);
 			}
-		}
 
-		/* Update() actually saves the connection settings to backing storage,
-		 * either GConf or over D-Bus.
-		 */
-		nm_connection_editor_set_busy (editor, TRUE);
-		nm_settings_connection_interface_update (connection, update_cb, info);
-	} else {
-		/* The hard part: Connection scope changed:
-		 * Add the modified connection to the new settings service, then delete
-		 * the original connection from the old settings service.
-		 */
-		add_connection (list, editor, update_add_result_cb, info);
-	}
+			g_object_unref (candidate);
+		} while (gtk_tree_model_iter_next (list->model, &iter));
+	} while (gtk_tree_model_iter_next (list->model, &types_iter));
 }
 
+
 /**********************************************/
 /* dialog/UI handling stuff */
 
 static void
-add_finished_cb (NMConnectionList *list, GError *error, gpointer user_data)
-{
-	NMConnectionEditor *editor = NM_CONNECTION_EDITOR (user_data);
-	GtkWindow *parent;
-
-	if (error) {
-		parent = nm_connection_editor_get_window (editor);
-		error_dialog (parent, _("Connection add failed"), "%s", error->message);
-	}
-
-	g_hash_table_remove (list->editors, nm_connection_editor_get_connection (editor));
-}
-
-
-static void
-add_response_cb (NMConnectionEditor *editor, gint response, GError *error, gpointer user_data)
+add_response_cb (NMConnectionEditor *editor, GtkResponseType response, gpointer user_data)
 {
 	NMConnectionList *list = user_data;
-	GError *add_error = NULL;
-
-	/* if the dialog is busy waiting for authorization or something,
-	 * don't destroy it until authorization returns.
-	 */
-	if (nm_connection_editor_get_busy (editor))
-		return;
 
-	if (response == GTK_RESPONSE_OK) {
-		/* Verify and commit user changes */
-		if (nm_connection_editor_update_connection (editor, &add_error)) {
-			/* Yay we can try to add the connection; it'll get removed from
-			 * list->editors when the add finishes.
-			 */
-			add_connection (list, editor, add_finished_cb, editor);
-			return;
-		} else {
-			error_dialog (GTK_WINDOW (editor->window),
-			              _("Error editing connection: property '%s' / '%s' invalid: %d"),
-			              g_type_name (nm_connection_lookup_setting_type_by_quark (add_error->domain)),
-			              (add_error && add_error->message) ? add_error->message : "(unknown)",
-			              add_error ? add_error->code : -1);
-			g_clear_error (&add_error);
-		}
-	} else if (response == GTK_RESPONSE_NONE) {
-		const char *message = _("An unknown error occurred.");
-
-		if (error && error->message)
-			message = error->message;
-		error_dialog (GTK_WINDOW (editor->window),
-		              _("Error initializing editor"),
-		              "%s", message);
-	}
+	if (response == GTK_RESPONSE_CANCEL)
+		delete_slaves_of_connection (list, nm_connection_editor_get_connection (editor));
 
-	g_hash_table_remove (list->editors, nm_connection_editor_get_connection (editor));
+	g_object_unref (editor);
 }
 
 static void
 really_add_connection (NMConnection *connection,
-                       gboolean canceled,
-                       GError *error,
                        gpointer user_data)
 {
 	NMConnectionList *list = user_data;
 	NMConnectionEditor *editor;
-	GError *editor_error = NULL;
-	const char *message = _("The connection editor dialog could not be initialized due to an unknown error.");
 
-	if (canceled)
-		return;
-
-	if (!connection) {
-		error_dialog (GTK_WINDOW (list->dialog),
-		              _("Could not create new connection"),
-		              "%s",
-		              (error && error->message) ? error->message : message);
+	if (!connection)
 		return;
-	}
 
-	editor = nm_connection_editor_new (connection, list->system_settings, &error);
+	editor = nm_connection_editor_new (GTK_WINDOW (list->dialog), connection,
+	                                   list->system_settings, list->gconf_settings);
 	if (!editor) {
 		g_object_unref (connection);
-
-		error_dialog (GTK_WINDOW (list->dialog),
-		              _("Could not edit new connection"),
-		              "%s",
-		              (editor_error && editor_error->message) ? editor_error->message : message);
-		g_clear_error (&editor_error);
 		return;
 	}
 
 	g_signal_connect (editor, "done", G_CALLBACK (add_response_cb), list);
-	g_hash_table_insert (list->editors, connection, editor);
-
 	nm_connection_editor_run (editor);
 }
 
@@ -648,131 +314,40 @@ add_clicked (GtkButton *button, gpointer user_data)
 	                       list);
 }
 
-typedef struct {
-	NMConnectionList *list;
-	NMConnectionEditor *editor;
-	NMConnectionScope orig_scope;
-} EditInfo;
-
-static void
-connection_updated_cb (NMConnectionList *list,
-                       NMSettingsConnectionInterface *connection,
-                       GError *error,
-                       gpointer user_data)
-{
-	EditInfo *info = user_data;
-	GtkTreeIter iter;
-
-	if (error) {
-		/* Log the error and do nothing.  We don't want to destroy the dialog
-		 * because that's not really useful.  If there's a hard error, the user
-		 * will just have to cancel.  This better handles the case where
-		 * PolicyKit authentication is required, but the user accidentally gets
-		 * their password wrong.  Which used to close the dialog, and that's
-		 * completely unhelpful.  Instead just let them hit 'Save' again.
-		 */
-		g_warning ("Error updating connection '%s': (%d) %s",
-		           nm_connection_get_id (NM_CONNECTION (connection)),
-		           error->code,
-		           error->message);
-		return;
-	}
-
-	/* Success */
-	if (get_iter_for_connection (list, connection, &iter))
-		update_connection_row (list, &iter, connection);
-
-	g_hash_table_remove (list->editors, connection);
-	g_free (info);
-}
-
 static void
-edit_done_cb (NMConnectionEditor *editor, gint response, GError *error, gpointer user_data)
+edit_done_cb (NMConnectionEditor *editor, GtkResponseType response, gpointer user_data)
 {
-	EditInfo *info = user_data;
-	const char *message = _("An unknown error occurred.");
-	NMConnection *connection;
-	GError *edit_error = NULL;
+	NMConnectionList *list = user_data;
 
-	/* if the dialog is busy waiting for authorization or something,
-	 * don't destroy it until authorization returns.
-	 */
-	if (nm_connection_editor_get_busy (editor))
-		return;
+	if (response == GTK_RESPONSE_OK) {
+		NMSettingsConnectionInterface *connection =
+			NM_SETTINGS_CONNECTION_INTERFACE (nm_connection_editor_get_connection (editor));
+		GtkTreeIter iter;
 
-	connection = nm_connection_editor_get_connection (editor);
-	g_assert (connection);
-
-	switch (response) {
-	case GTK_RESPONSE_OK:
-		/* Verify and commit user changes */
-		if (nm_connection_editor_update_connection (editor, &edit_error)) {
-			/* Save the connection to backing storage */
-			update_connection (info->list,
-			                   editor,
-			                   NM_SETTINGS_CONNECTION_INTERFACE (connection),
-			                   info->orig_scope,
-			                   connection_updated_cb,
-			                   info);
-		} else {
-			g_warning ("%s: invalid connection after update: bug in the "
-			           "'%s' / '%s' invalid: %d",
-			           __func__,
-			           g_type_name (nm_connection_lookup_setting_type_by_quark (edit_error->domain)),
-			           edit_error->message, edit_error->code);
-			connection_updated_cb (info->list,
-			                       NM_SETTINGS_CONNECTION_INTERFACE (connection),
-			                       edit_error,
-			                       info);
-			g_error_free (edit_error);
-		}
-		break;
-	case GTK_RESPONSE_NONE:
-		/* Show an error dialog if the editor initialization failed */
-		if (error && error->message)
-			message = error->message;
-		error_dialog (GTK_WINDOW (editor->window), _("Error initializing editor"), "%s", message);
-		/* fall through */
-	case GTK_RESPONSE_CANCEL:
-	default:
-		g_hash_table_remove (info->list->editors, connection);
-		g_free (info);
-		break;
+		if (get_iter_for_connection (list, connection, &iter))
+			update_connection_row (list, &iter, connection);
 	}
+
+	g_object_unref (editor);
 }
 
 static void
 edit_connection (NMConnectionList *list, NMSettingsConnectionInterface *connection)
 {
 	NMConnectionEditor *editor;
-	EditInfo *edit_info;
-	GError *error = NULL;
-	const char *message = _("The connection editor dialog could not be initialized due to an unknown error.");
 
 	/* Don't allow two editors for the same connection */
-	editor = (NMConnectionEditor *) g_hash_table_lookup (list->editors, connection);
+	editor = nm_connection_editor_get (NM_CONNECTION (connection));
 	if (editor) {
 		nm_connection_editor_present (editor);
 		return;
 	}
 
-	editor = nm_connection_editor_new (NM_CONNECTION (connection), list->system_settings, &error);
-	if (!editor) {
-		error_dialog (GTK_WINDOW (list->dialog),
-		              _("Could not edit connection"),
-		              "%s",
-		              (error && error->message) ? error->message : message);
-		return;
-	}
-
-	edit_info = g_malloc0 (sizeof (EditInfo));
-	edit_info->list = list;
-	edit_info->editor = editor;
-	edit_info->orig_scope = nm_connection_get_scope (NM_CONNECTION (connection));
-
-	g_signal_connect (editor, "done", G_CALLBACK (edit_done_cb), edit_info);
-	g_hash_table_insert (list->editors, connection, editor);
-
+	editor = nm_connection_editor_new (GTK_WINDOW (list->dialog),
+	                                   NM_CONNECTION (connection),
+	                                   list->system_settings,
+	                                   list->gconf_settings);
+	g_signal_connect (editor, "done", G_CALLBACK (edit_done_cb), list);
 	nm_connection_editor_run (editor);
 }
 
@@ -783,14 +358,12 @@ do_edit (NMConnectionList *list)
 }
 
 static void
-delete_result_cb (NMConnectionList *list,
-                  GError *error,
-                  gpointer user_data)
+delete_connection_cb (NMSettingsConnectionInterface *connection, gboolean deleted, gpointer user_data)
 {
-	GtkWindow *parent = GTK_WINDOW (user_data);
+	NMConnectionList *list = user_data;
 
-	if (error)
-		error_dialog (parent, _("Connection delete failed"), "%s", error->message);
+	if (deleted)
+		delete_slaves_of_connection (list, NM_CONNECTION (connection));
 }
 
 static void
@@ -798,47 +371,12 @@ delete_clicked (GtkButton *button, gpointer user_data)
 {
 	NMConnectionList *list = user_data;
 	NMSettingsConnectionInterface *connection;
-	NMConnectionEditor *editor;
-	NMSettingConnection *s_con;
-	GtkWidget *dialog;
-	const char *id;
-	guint result;
 
 	connection = get_active_connection (list->connection_list);
 	g_return_if_fail (connection != NULL);
 
-	editor = g_hash_table_lookup (list->editors, connection);
-	if (editor && nm_connection_editor_get_busy (editor)) {
-		/* Editor already has an operation in progress, raise it */
-		nm_connection_editor_present (editor);
-		return;
-	}
-
-	s_con = (NMSettingConnection *) nm_connection_get_setting (NM_CONNECTION (connection), NM_TYPE_SETTING_CONNECTION);
-	g_assert (s_con);
-	id = nm_setting_connection_get_id (s_con);
-
-	dialog = gtk_message_dialog_new (GTK_WINDOW (list->dialog),
-	                                 GTK_DIALOG_DESTROY_WITH_PARENT,
-	                                 GTK_MESSAGE_QUESTION,
-	                                 GTK_BUTTONS_NONE,
-	                                 _("Are you sure you wish to delete the connection %s?"),
-	                                 id);
-	gtk_dialog_add_buttons (GTK_DIALOG (dialog),
-	                        GTK_STOCK_CANCEL, GTK_RESPONSE_CANCEL,
-	                        GTK_STOCK_DELETE, GTK_RESPONSE_YES,
-	                        NULL);
-	gtk_window_set_transient_for (GTK_WINDOW (dialog), GTK_WINDOW (list->dialog));
-
-	result = gtk_dialog_run (GTK_DIALOG (dialog));
-	gtk_widget_destroy (dialog);
-
-	if (result == GTK_RESPONSE_YES) {
-		delete_connection (list,
-		                   connection,
-		                   delete_result_cb,
-		                   GTK_WINDOW (list->dialog));
-	}
+	delete_connection (GTK_WINDOW (list->dialog), connection,
+	                   TRUE, delete_connection_cb, list);
 }
 
 static void
@@ -906,9 +444,6 @@ dispose (GObject *object)
 	if (list->dialog)
 		gtk_widget_hide (list->dialog);
 
-	if (list->editors)
-		g_hash_table_destroy (list->editors);
-
 	if (list->gui)
 		g_object_unref (list->gui);
 	if (list->client)
@@ -942,6 +477,37 @@ nm_connection_list_class_init (NMConnectionListClass *klass)
 					  G_TYPE_NONE, 1, G_TYPE_INT);
 }
 
+static gboolean
+model_contains_master (GtkTreeModel *model, const char *master)
+{
+	GtkTreeIter parent_iter, iter;
+	NMConnection *candidate;
+	const char *uuid, *iface;
+
+	if (!gtk_tree_model_get_iter_first (model, &parent_iter))
+		return FALSE;
+
+	do {
+		if (!gtk_tree_model_iter_children (model, &iter, &parent_iter))
+			continue;
+
+		do {
+			gtk_tree_model_get (model, &iter,
+			                    COL_CONNECTION, &candidate,
+			                    -1);
+			g_object_unref (candidate);
+			uuid = nm_connection_get_uuid (candidate);
+			if (!g_strcmp0 (uuid, master))
+				return TRUE;
+			iface = nm_connection_get_virtual_iface_name (candidate);
+			if (!g_strcmp0 (iface, master))
+				return TRUE;
+		} while (gtk_tree_model_iter_next (model, &iter));
+	} while (gtk_tree_model_iter_next (model, &parent_iter));
+
+	return FALSE;
+}
+
 static gint
 sort_connection_types (GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer user_data)
 {
@@ -994,15 +560,34 @@ tree_model_visible_func (GtkTreeModel *model,
                          gpointer user_data)
 {
 	NMConnection *connection;
+	NMSettingConnection *s_con;
+	const char *master;
+	const char *slave_type;
 
 	gtk_tree_model_get (model, iter, COL_CONNECTION, &connection, -1);
-	if (connection) {
-		g_object_unref (connection);
-		return TRUE;
-	} else {
+	if (!connection) {
 		/* Top-level type nodes are visible iff they have children */
 		return gtk_tree_model_iter_has_child  (model, iter);
 	}
+
+	/* A connection node is visible unless it is a bond slave to
+	 * another known connection.
+	 */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_object_unref (connection);
+	g_return_val_if_fail (s_con != NULL, FALSE);
+
+	master = nm_setting_connection_get_master (s_con);
+	slave_type = nm_setting_connection_get_slave_type (s_con);
+	if (!master || g_strcmp0 (slave_type, NM_SETTING_BOND_SETTING_NAME) != 0)
+		return TRUE;
+
+	if (model_contains_master (model, master))
+		return FALSE;
+	if (nm_connection_editor_get_master (connection))
+		return FALSE;
+
+	return TRUE;
 }
 
 static void
@@ -1278,8 +863,6 @@ nm_connection_list_new (GType def_type)
 	                  G_CALLBACK (connection_added),
 	                  list);
 
-	list->editors = g_hash_table_new_full (g_direct_hash, g_direct_equal, NULL, g_object_unref);
-
 	list->connection_list = GTK_TREE_VIEW (gtk_builder_get_object (list->gui, "connection_list"));
 	initialize_treeview (list);
 	add_connection_buttons (list);
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/nm-connection-list.h.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/nm-connection-list.h
index c554a86..c341e7f 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/nm-connection-list.h.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/nm-connection-list.h
@@ -38,8 +38,6 @@ typedef struct {
 	GObject parent;
 
 	/* private data */
-	GHashTable *editors;
-
 	GtkTreeView *connection_list;
 	GtkTreeModel *model;
 	GtkTreeModelFilter *filter;
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-bond.c.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-bond.c
new file mode 100644
index 0000000..56ca366
--- /dev/null
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-bond.c
@@ -0,0 +1,972 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager Connection editor -- Connection editor for NetworkManager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2012 Red Hat, Inc.
+ */
+
+#include "config.h"
+
+#include <stdlib.h>
+#include <gtk/gtk.h>
+#include <glib/gi18n.h>
+
+#include <nm-setting-connection.h>
+#include <nm-setting-bond.h>
+#include <nm-setting-infiniband.h>
+#include <nm-setting-wired.h>
+
+#include "page-bond.h"
+#include "page-wired.h"
+#include "page-infiniband.h"
+#include "nm-connection-editor.h"
+#include "new-connection.h"
+
+G_DEFINE_TYPE (CEPageBond, ce_page_bond, CE_TYPE_PAGE)
+
+#define CE_PAGE_BOND_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), CE_TYPE_PAGE_BOND, CEPageBondPrivate))
+
+typedef struct {
+	NMRemoteConnection *connection;
+	NMRemoteSettingsSystem *system_settings;
+	NMAGConfSettings *gconf_settings;
+
+	NMSettingBond *setting;
+	const char *uuid;
+
+	GType slave_type;
+	PageNewConnectionFunc new_slave_func;
+
+	GtkWindow *toplevel;
+
+	GtkEntry *interface_name;
+	GtkComboBox *mode;
+	GtkComboBox *monitoring;
+	GtkSpinButton *frequency;
+	GtkSpinButton *updelay;
+	GtkWidget *updelay_label;
+	GtkWidget *updelay_box;
+	GtkSpinButton *downdelay;
+	GtkWidget *downdelay_label;
+	GtkWidget *downdelay_box;
+	GtkEntry *arp_targets;
+	GtkWidget *arp_targets_label;
+
+	GtkTable *table;
+	int table_row_spacing;
+	int updelay_row;
+	int downdelay_row;
+	int arp_targets_row;
+
+	GtkTreeView *connections;
+	GtkTreeModel *connections_model;
+	GtkButton *add, *edit, *delete;
+
+} CEPageBondPrivate;
+
+#define MODE_BALANCE_RR    0
+#define MODE_ACTIVE_BACKUP 1
+#define MODE_BALANCE_XOR   2
+#define MODE_BROADCAST     3
+#define MODE_802_3AD       4
+#define MODE_BALANCE_TLB   5
+#define MODE_BALANCE_ALB   6
+
+#define MONITORING_MII 0
+#define MONITORING_ARP 1
+
+enum {
+	COL_CONNECTION,
+	COL_NAME
+};
+
+static int
+name_sort_func (GtkTreeModel *model, GtkTreeIter *a, GtkTreeIter *b, gpointer user_data)
+{
+	NMConnection *conn_a, *conn_b;
+	int ret;
+
+	/* We fetch COL_CONNECTION rather than COL_NAME to avoid a strdup/free. */
+	gtk_tree_model_get (model, a, COL_CONNECTION, &conn_a, -1);
+	gtk_tree_model_get (model, b, COL_CONNECTION, &conn_b, -1);
+	ret = strcmp (nm_connection_get_id (conn_a), nm_connection_get_id (conn_b));
+	g_object_unref (conn_a);
+	g_object_unref (conn_b);
+
+	return ret;
+}
+
+static void
+bond_private_init (CEPageBond *self)
+{
+	CEPageBondPrivate *priv = CE_PAGE_BOND_GET_PRIVATE (self);
+	GtkBuilder *builder;
+
+	builder = CE_PAGE (self)->builder;
+
+	priv->interface_name = GTK_ENTRY (gtk_builder_get_object (builder, "bond_interface"));
+	priv->connections = GTK_TREE_VIEW (gtk_builder_get_object (builder, "bond_connections"));
+	priv->connections_model = GTK_TREE_MODEL (gtk_builder_get_object (builder, "bond_connections_model"));
+	gtk_tree_sortable_set_sort_func (GTK_TREE_SORTABLE (priv->connections_model),
+	                                 COL_NAME, name_sort_func,
+	                                 NULL, NULL);
+	gtk_tree_sortable_set_sort_column_id (GTK_TREE_SORTABLE (priv->connections_model),
+	                                      COL_NAME, GTK_SORT_ASCENDING);
+
+	priv->mode = GTK_COMBO_BOX (gtk_builder_get_object (builder, "bond_mode"));
+	priv->monitoring = GTK_COMBO_BOX (gtk_builder_get_object (builder, "bond_monitoring"));
+	priv->frequency = GTK_SPIN_BUTTON (gtk_builder_get_object (builder, "bond_frequency"));
+	priv->updelay = GTK_SPIN_BUTTON (gtk_builder_get_object (builder, "bond_updelay"));
+	priv->updelay_label = GTK_WIDGET (gtk_builder_get_object (builder, "bond_updelay_label"));
+	priv->updelay_box = GTK_WIDGET (gtk_builder_get_object (builder, "bond_updelay_box"));
+	priv->downdelay = GTK_SPIN_BUTTON (gtk_builder_get_object (builder, "bond_downdelay"));
+	priv->downdelay_label = GTK_WIDGET (gtk_builder_get_object (builder, "bond_downdelay_label"));
+	priv->downdelay_box = GTK_WIDGET (gtk_builder_get_object (builder, "bond_downdelay_box"));
+	priv->arp_targets = GTK_ENTRY (gtk_builder_get_object (builder, "bond_arp_targets"));
+	priv->arp_targets_label = GTK_WIDGET (gtk_builder_get_object (builder, "bond_arp_targets_label"));
+	priv->add = GTK_BUTTON (gtk_builder_get_object (builder, "bond_connection_add"));
+	priv->edit = GTK_BUTTON (gtk_builder_get_object (builder, "bond_connection_edit"));
+	priv->delete = GTK_BUTTON (gtk_builder_get_object (builder, "bond_connection_delete"));
+
+	priv->toplevel = GTK_WINDOW (gtk_widget_get_ancestor (GTK_WIDGET (priv->connections),
+	                                                      GTK_TYPE_WINDOW));
+
+	priv->table = GTK_TABLE (gtk_builder_get_object (builder, "BondPage"));
+	priv->table_row_spacing = gtk_table_get_default_row_spacing (priv->table);
+	gtk_container_child_get (GTK_CONTAINER (priv->table), priv->updelay_label,
+	                         "top-attach", &priv->updelay_row,
+	                         NULL);
+	gtk_container_child_get (GTK_CONTAINER (priv->table), priv->downdelay_label,
+	                         "top-attach", &priv->downdelay_row,
+	                         NULL);
+	gtk_container_child_get (GTK_CONTAINER (priv->table), priv->arp_targets_label,
+	                         "top-attach", &priv->arp_targets_row,
+	                         NULL);
+}
+
+static void
+dispose (GObject *object)
+{
+	CEPageBond *self = CE_PAGE_BOND (object);
+	CEPageBondPrivate *priv = CE_PAGE_BOND_GET_PRIVATE (self);
+	GtkTreeIter iter;
+
+	if (priv->system_settings) {
+		g_signal_handlers_disconnect_matched (priv->system_settings, G_SIGNAL_MATCH_DATA,
+		                                      0, 0, NULL, NULL, self);
+		g_object_unref (priv->system_settings);
+		priv->system_settings = NULL;
+	}
+	if (priv->gconf_settings) {
+		g_signal_handlers_disconnect_matched (priv->gconf_settings, G_SIGNAL_MATCH_DATA,
+		                                      0, 0, NULL, NULL, self);
+		g_object_unref (priv->gconf_settings);
+		priv->gconf_settings = NULL;
+	}
+	if (priv->connection) {
+		g_object_unref (priv->connection);
+		priv->connection = NULL;
+	}
+
+	if (gtk_tree_model_get_iter_first (priv->connections_model, &iter)) {
+		do {
+			NMRemoteConnection *connection = NULL;
+
+			gtk_tree_model_get (priv->connections_model, &iter,
+			                    COL_CONNECTION, &connection,
+			                    -1);
+			g_signal_handlers_disconnect_matched (connection, G_SIGNAL_MATCH_DATA,
+			                                      0, 0, NULL, NULL, self);
+			g_object_unref (connection);
+		} while (gtk_tree_model_iter_next (priv->connections_model, &iter));
+	}
+
+	G_OBJECT_CLASS (ce_page_bond_parent_class)->dispose (object);
+}
+
+static void
+stuff_changed (GtkWidget *w, gpointer user_data)
+{
+	ce_page_changed (CE_PAGE (user_data));
+}
+
+static void
+connection_removed (NMRemoteConnection *connection, gpointer user_data)
+{
+	CEPageBond *self = CE_PAGE_BOND (user_data);
+	CEPageBondPrivate *priv = CE_PAGE_BOND_GET_PRIVATE (self);
+	GtkTreeIter iter;
+
+	if (!gtk_tree_model_get_iter_first (priv->connections_model, &iter))
+		return;
+
+	do {
+		NMRemoteConnection *candidate = NULL;
+
+		gtk_tree_model_get (priv->connections_model, &iter,
+		                    COL_CONNECTION, &candidate,
+		                    -1);
+		if (candidate == connection) {
+			gtk_list_store_remove (GTK_LIST_STORE (priv->connections_model), &iter);
+			stuff_changed (NULL, self);
+
+			if (!gtk_tree_model_get_iter_first (priv->connections_model, &iter)) {
+				priv->slave_type = G_TYPE_INVALID;
+				priv->new_slave_func = NULL;
+			}
+			return;
+		}
+	} while (gtk_tree_model_iter_next (priv->connections_model, &iter));
+}
+
+static void
+connection_added (NMSettingsInterface *settings,
+                  NMSettingsConnectionInterface *connection,
+                  gpointer user_data)
+{
+	CEPageBond *self = CE_PAGE_BOND (user_data);
+	CEPageBondPrivate *priv = CE_PAGE_BOND_GET_PRIVATE (self);
+	NMSettingConnection *s_con;
+	const char *slave_type, *master;
+	const char *interface_name;
+	GtkTreeIter iter;
+
+	s_con = nm_connection_get_setting_connection (NM_CONNECTION (connection));
+	if (!s_con)
+		return;
+
+	slave_type = nm_setting_connection_get_slave_type (s_con);
+	if (!slave_type || strcmp (slave_type, NM_SETTING_BOND_SETTING_NAME) != 0)
+		return;
+
+	master = nm_setting_connection_get_master (s_con);
+	if (!master)
+		return;
+
+	interface_name = nm_setting_bond_get_interface_name (priv->setting);
+	if (   strcmp (master, interface_name) != 0
+	    && strcmp (master, priv->uuid) != 0)
+		return;
+
+	gtk_list_store_append (GTK_LIST_STORE (priv->connections_model), &iter);
+	gtk_list_store_set (GTK_LIST_STORE (priv->connections_model), &iter,
+	                    COL_CONNECTION, connection,
+	                    COL_NAME, nm_setting_connection_get_id (s_con),
+	                    -1);
+	stuff_changed (NULL, self);
+
+	/* FIXME: a bit kludgy */
+	if (nm_connection_is_type (NM_CONNECTION (connection), NM_SETTING_INFINIBAND_SETTING_NAME)) {
+		priv->slave_type = NM_TYPE_SETTING_INFINIBAND;
+		priv->new_slave_func = infiniband_connection_new;
+		gtk_combo_box_set_active (priv->mode, MODE_ACTIVE_BACKUP);
+		gtk_widget_set_sensitive (GTK_WIDGET (priv->mode), FALSE);
+	} else {
+		priv->slave_type = NM_TYPE_SETTING_WIRED;
+		priv->new_slave_func = wired_connection_new;
+		gtk_widget_set_sensitive (GTK_WIDGET (priv->mode), TRUE);
+	}
+
+	g_signal_connect (connection, "removed",
+	                  G_CALLBACK (connection_removed), self);
+}
+
+static void
+monitoring_mode_changed (GtkComboBox *combo, gpointer user_data)
+{
+	CEPageBond *self = user_data;
+	CEPageBondPrivate *priv = CE_PAGE_BOND_GET_PRIVATE (self);
+
+	if (gtk_combo_box_get_active (combo) == MONITORING_MII) {
+		gtk_widget_show (GTK_WIDGET (priv->updelay));
+		gtk_widget_show (priv->updelay_label);
+		gtk_widget_show (priv->updelay_box);
+		gtk_widget_show (GTK_WIDGET (priv->downdelay));
+		gtk_widget_show (priv->downdelay_label);
+		gtk_widget_show (priv->downdelay_box);
+		gtk_widget_hide (GTK_WIDGET (priv->arp_targets));
+		gtk_widget_hide (priv->arp_targets_label);
+
+		gtk_table_set_row_spacing (priv->table, priv->updelay_row, priv->table_row_spacing);
+		gtk_table_set_row_spacing (priv->table, priv->downdelay_row, priv->table_row_spacing);
+		gtk_table_set_row_spacing (priv->table, priv->arp_targets_row, 0);
+	} else {
+		gtk_widget_hide (GTK_WIDGET (priv->updelay));
+		gtk_widget_hide (priv->updelay_label);
+		gtk_widget_hide (priv->updelay_box);
+		gtk_widget_hide (GTK_WIDGET (priv->downdelay));
+		gtk_widget_hide (priv->downdelay_label);
+		gtk_widget_hide (priv->downdelay_box);
+		gtk_widget_show (GTK_WIDGET (priv->arp_targets));
+		gtk_widget_show (priv->arp_targets_label);
+
+		gtk_table_set_row_spacing (priv->table, priv->updelay_row, 0);
+		gtk_table_set_row_spacing (priv->table, priv->downdelay_row, 0);
+		gtk_table_set_row_spacing (priv->table, priv->arp_targets_row, priv->table_row_spacing);
+	}
+}
+
+static void
+frequency_changed (GtkSpinButton *button, gpointer user_data)
+{
+	CEPageBond *self = user_data;
+	CEPageBondPrivate *priv = CE_PAGE_BOND_GET_PRIVATE (self);
+	int frequency, delay;
+
+	frequency = gtk_spin_button_get_value_as_int (priv->frequency);
+
+	/* Round updelay and downdelay up to a multiple of frequency */
+
+	delay = gtk_spin_button_get_value_as_int (priv->updelay);
+	if (frequency == 0) {
+		if (delay != 0)
+			gtk_spin_button_set_value (priv->updelay, 0.0);
+	} else if (delay % frequency) {
+		delay += frequency - (delay % frequency);
+		gtk_spin_button_set_value (priv->updelay, delay);
+	}
+	gtk_spin_button_set_increments (priv->updelay, frequency, frequency);
+
+	delay = gtk_spin_button_get_value_as_int (priv->downdelay);
+	if (frequency == 0) {
+		if (delay != 0)
+			gtk_spin_button_set_value (priv->downdelay, 0.0);
+	} else if (delay % frequency) {
+		delay += frequency - (delay % frequency);
+		gtk_spin_button_set_value (priv->downdelay, (gdouble)delay);
+	}
+	gtk_spin_button_set_increments (priv->downdelay, frequency, frequency);
+}
+
+static void
+delay_changed (GtkSpinButton *button, gpointer user_data)
+{
+	CEPageBond *self = user_data;
+	CEPageBondPrivate *priv = CE_PAGE_BOND_GET_PRIVATE (self);
+	int frequency, delay;
+
+	/* Clamp to nearest multiple of frequency */
+
+	frequency = gtk_spin_button_get_value_as_int (priv->frequency);
+	delay = gtk_spin_button_get_value_as_int (button);
+	if (frequency == 0) {
+		if (delay != 0)
+			gtk_spin_button_set_value (button, 0.0);
+	} else if (delay % frequency) {
+		if (delay % frequency < frequency / 2)
+			delay -= delay % frequency;
+		else
+			delay += frequency - (delay % frequency);
+		gtk_spin_button_set_value (button, (gdouble)delay);
+	}
+}
+
+static char *
+prettify_targets (const char *text)
+{
+	char **addrs, *targets;
+
+	if (!text || !*text)
+		return NULL;
+
+	addrs = g_strsplit (text, ",", -1);
+	targets = g_strjoinv (", ", addrs);
+	g_strfreev (addrs);
+
+	return targets;
+}
+
+static char *
+uglify_targets (const char *text)
+{
+	char **addrs, *targets;
+	int i;
+
+	if (!text || !*text)
+		return NULL;
+
+	addrs = g_strsplit (text, ",", -1);
+	for (i = 0; addrs[i]; i++)
+		g_strstrip (addrs[i]);
+	targets = g_strjoinv (",", addrs);
+	g_strfreev (addrs);
+
+	return targets;
+}
+
+static void
+populate_ui (CEPageBond *self)
+{
+	CEPageBondPrivate *priv = CE_PAGE_BOND_GET_PRIVATE (self);
+	NMSettingBond *setting = priv->setting;
+	NMSettingConnection *s_con;
+	const char *iface;
+	GSList *connections, *c;
+	const char *mode, *frequency, *updelay, *downdelay, *raw_targets;
+	char *targets;
+	int mode_idx = MODE_BALANCE_RR;
+
+	s_con = nm_connection_get_setting_connection (NM_CONNECTION (priv->connection));
+	g_return_if_fail (s_con != NULL);
+
+	/* Interface name */
+	iface = nm_setting_bond_get_interface_name (setting);
+	gtk_entry_set_text (priv->interface_name, iface ? iface : "");
+
+	/* Bonded connections */
+	connections = nm_settings_interface_list_connections (NM_SETTINGS_INTERFACE (priv->system_settings));
+	for (c = connections; c; c = c->next)
+		connection_added (NM_SETTINGS_INTERFACE (priv->system_settings), c->data, self);
+	g_slist_free (connections);
+
+	/* Mode */
+	mode = nm_setting_bond_get_option_by_name (setting, NM_SETTING_BOND_OPTION_MODE);
+	if (mode) {
+		if (!strcmp (mode, "balance-rr"))
+			mode_idx = MODE_BALANCE_RR;
+		else if (!strcmp (mode, "active-backup"))
+			mode_idx = MODE_ACTIVE_BACKUP;
+		else if (!strcmp (mode, "balance-xor"))
+			mode_idx = MODE_BALANCE_XOR;
+		else if (!strcmp (mode, "broadcast"))
+			mode_idx = MODE_BROADCAST;
+		else if (!strcmp (mode, "802.3ad"))
+			mode_idx = MODE_802_3AD;
+		else if (!strcmp (mode, "balance-tlb"))
+			mode_idx = MODE_BALANCE_TLB;
+		else if (!strcmp (mode, "balance-alb"))
+			mode_idx = MODE_BALANCE_ALB;
+	}
+	gtk_combo_box_set_active (priv->mode, mode_idx);
+
+	/* Monitoring mode/frequency */
+	frequency = nm_setting_bond_get_option_by_name (setting, NM_SETTING_BOND_OPTION_ARP_INTERVAL);
+	if (frequency) {
+		gtk_combo_box_set_active (priv->monitoring, MONITORING_ARP);
+	} else {
+		gtk_combo_box_set_active (priv->monitoring, MONITORING_MII);
+		frequency = nm_setting_bond_get_option_by_name (setting, NM_SETTING_BOND_OPTION_MIIMON);
+	}
+	g_signal_connect (priv->monitoring, "changed",
+	                  G_CALLBACK (monitoring_mode_changed),
+	                  self);
+	monitoring_mode_changed (priv->monitoring, self);
+
+	if (frequency)
+		gtk_spin_button_set_value (priv->frequency, (gdouble) atoi (frequency));
+	else
+		gtk_spin_button_set_value (priv->frequency, 0.0);
+	g_signal_connect (priv->frequency, "value-changed",
+	                  G_CALLBACK (frequency_changed),
+	                  self);
+
+	updelay = nm_setting_bond_get_option_by_name (setting, NM_SETTING_BOND_OPTION_UPDELAY);
+	if (updelay)
+		gtk_spin_button_set_value (priv->updelay, (gdouble) atoi (updelay));
+	else
+		gtk_spin_button_set_value (priv->updelay, 0.0);
+	g_signal_connect (priv->updelay, "value-changed",
+	                  G_CALLBACK (delay_changed),
+	                  self);
+	downdelay = nm_setting_bond_get_option_by_name (setting, NM_SETTING_BOND_OPTION_DOWNDELAY);
+	if (downdelay)
+		gtk_spin_button_set_value (priv->downdelay, (gdouble) atoi (downdelay));
+	else
+		gtk_spin_button_set_value (priv->downdelay, 0.0);
+	g_signal_connect (priv->downdelay, "value-changed",
+	                  G_CALLBACK (delay_changed),
+	                  self);
+
+	/* ARP targets */
+	raw_targets = nm_setting_bond_get_option_by_name (setting, NM_SETTING_BOND_OPTION_ARP_IP_TARGET);
+	targets = prettify_targets (raw_targets);
+	if (targets) {
+		gtk_entry_set_text (priv->arp_targets, targets);
+		g_free (targets);
+	}
+}
+
+static void
+connections_selection_changed_cb (GtkTreeSelection *selection, gpointer user_data)
+{
+	CEPageBond *self = user_data;
+	CEPageBondPrivate *priv = CE_PAGE_BOND_GET_PRIVATE (self);
+	GtkTreeIter iter;
+	GtkTreeModel *model;
+	NMRemoteConnection *connection;
+	NMSettingConnection *s_con;
+	gboolean sensitive = FALSE;
+
+	if (gtk_tree_selection_get_selected (selection, &model, &iter)) {
+		gtk_tree_model_get (model, &iter,
+		                    0, &connection,
+		                    -1);
+		s_con = nm_connection_get_setting_connection (NM_CONNECTION (connection));
+		g_assert (s_con);
+	
+		sensitive = !nm_setting_connection_get_read_only (s_con);
+	}
+
+	gtk_widget_set_sensitive (GTK_WIDGET (priv->edit), sensitive);
+	gtk_widget_set_sensitive (GTK_WIDGET (priv->delete), sensitive);
+}
+
+static void
+add_response_cb (NMConnectionEditor *editor, NMRemoteConnection *connection,
+                 gboolean added, gpointer user_data)
+{
+	g_object_unref (editor);
+}
+
+static void
+add_bond_connection (NMConnection *connection,
+                     gpointer user_data)
+{
+	CEPageBond *self = user_data;
+	CEPageBondPrivate *priv = CE_PAGE_BOND_GET_PRIVATE (self);
+	NMSettingConnection *s_con;
+	NMConnectionEditor *editor;
+	const char *iface_name;
+	char *name;
+
+	if (!connection)
+		return;
+
+	/* Mark the connection as a bond slave so that the editor knows not
+	 * to add IPv4 and IPv6 pages, and rename it.
+	 */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con != NULL);
+
+	iface_name = gtk_entry_get_text (priv->interface_name);
+	if (!*iface_name)
+		iface_name = nm_setting_bond_get_interface_name (priv->setting);
+	if (!*iface_name)
+		iface_name = "bond";
+	name = g_strdup_printf (_("%s slave %d"), iface_name,
+	                        gtk_tree_model_iter_n_children (priv->connections_model, NULL) + 1);
+
+	g_object_set (G_OBJECT (s_con),
+	              NM_SETTING_CONNECTION_ID, name,
+	              NM_SETTING_CONNECTION_MASTER, priv->uuid,
+	              NM_SETTING_CONNECTION_SLAVE_TYPE, NM_SETTING_BOND_SETTING_NAME,
+	              NM_SETTING_CONNECTION_AUTOCONNECT, FALSE,
+	              NULL);
+	g_free (name);
+
+	nm_connection_set_scope (connection, NM_CONNECTION_SCOPE_SYSTEM);
+
+	editor = nm_connection_editor_new (priv->toplevel,
+	                                   connection,
+	                                   priv->system_settings,
+	                                   priv->gconf_settings);
+	if (!editor) {
+		g_object_unref (connection);
+		return;
+	}
+
+	g_signal_connect (editor, "done", G_CALLBACK (add_response_cb), self);
+	nm_connection_editor_run (editor);
+}
+
+static gboolean
+connection_type_filter (GType type, gpointer user_data)
+{
+	if (type == NM_TYPE_SETTING_WIRED ||
+	    type == NM_TYPE_SETTING_INFINIBAND)
+		return TRUE;
+	else
+		return FALSE;
+}
+
+#define BOND_NEW_CONNECTION_SECONDARY_LABEL _("Select the type of connection that will be used for the slaves of this bond.")
+
+static void
+add_clicked (GtkButton *button, gpointer user_data)
+{
+	CEPageBond *self = user_data;
+	CEPageBondPrivate *priv = CE_PAGE_BOND_GET_PRIVATE (self);
+
+	if (priv->new_slave_func) {
+		new_connection_of_type (priv->toplevel,
+		                        NULL,
+		                        priv->system_settings,
+		                        priv->gconf_settings,
+		                        priv->new_slave_func,
+		                        add_bond_connection,
+		                        self);
+	} else {
+		new_connection_dialog_full (priv->toplevel,
+		                            priv->system_settings,
+		                            priv->gconf_settings,
+		                            NULL,
+		                            BOND_NEW_CONNECTION_SECONDARY_LABEL,
+		                            connection_type_filter,
+		                            add_bond_connection,
+		                            self);
+	}
+}
+
+static NMSettingsConnectionInterface *
+get_selected_connection (CEPageBond *self)
+{
+	CEPageBondPrivate *priv = CE_PAGE_BOND_GET_PRIVATE (self);
+	GtkTreeSelection *selection;
+	GList *selected_rows;
+	GtkTreeModel *model = NULL;
+	GtkTreeIter iter;
+	NMSettingsConnectionInterface *connection = NULL;
+
+	selection = gtk_tree_view_get_selection (priv->connections);
+	selected_rows = gtk_tree_selection_get_selected_rows (selection, &model);
+	if (!selected_rows)
+		return NULL;
+
+	if (gtk_tree_model_get_iter (model, &iter, (GtkTreePath *) selected_rows->data))
+		gtk_tree_model_get (model, &iter, 0, &connection, -1);
+
+	/* free memory */
+	g_list_foreach (selected_rows, (GFunc) gtk_tree_path_free, NULL);
+	g_list_free (selected_rows);
+
+	return connection;
+}
+
+static void
+edit_done_cb (NMConnectionEditor *editor, GtkResponseType response, gpointer user_data)
+{
+	g_object_unref (editor);
+}
+
+static void
+edit_clicked (GtkButton *button, gpointer user_data)
+{
+	CEPageBond *self = user_data;
+	CEPageBondPrivate *priv = CE_PAGE_BOND_GET_PRIVATE (self);
+	NMConnectionEditor *editor;
+	NMSettingsConnectionInterface *connection;
+
+	connection = get_selected_connection (self);
+	if (!connection)
+		return;
+
+	editor = nm_connection_editor_get (NM_CONNECTION (connection));
+	if (editor) {
+		nm_connection_editor_present (editor);
+		return;
+	}
+
+	editor = nm_connection_editor_new (priv->toplevel,
+	                                   NM_CONNECTION (connection),
+	                                   priv->system_settings,
+	                                   priv->gconf_settings);
+	if (!editor)
+		return;
+
+	g_signal_connect (editor, "done", G_CALLBACK (edit_done_cb), self);
+	nm_connection_editor_run (editor);
+}
+
+static void
+connection_double_clicked_cb (GtkTreeView *tree_view,
+                              GtkTreePath *path,
+                              GtkTreeViewColumn *column,
+                              gpointer user_data)
+{
+	edit_clicked (NULL, user_data);
+}
+
+static void
+delete_clicked (GtkButton *button, gpointer user_data)
+{
+	CEPageBond *self = user_data;
+	CEPageBondPrivate *priv = CE_PAGE_BOND_GET_PRIVATE (self);
+	NMSettingsConnectionInterface *connection;
+
+	connection = get_selected_connection (self);
+	if (!connection)
+		return;
+
+	delete_connection (priv->toplevel, connection, TRUE, NULL, NULL);
+}
+
+static void
+finish_setup (CEPageBond *self, gpointer unused, GError *error, gpointer user_data)
+{
+	CEPageBondPrivate *priv = CE_PAGE_BOND_GET_PRIVATE (self);
+	GtkTreeSelection *selection;
+
+	if (error)
+		return;
+
+	populate_ui (self);
+
+	g_signal_connect (priv->interface_name, "changed", G_CALLBACK (stuff_changed), self);
+	g_signal_connect (priv->mode, "changed", G_CALLBACK (stuff_changed), self);
+	g_signal_connect (priv->monitoring, "changed", G_CALLBACK (stuff_changed), self);
+	g_signal_connect (priv->frequency, "value-changed", G_CALLBACK (stuff_changed), self);
+	g_signal_connect (priv->updelay, "value-changed", G_CALLBACK (stuff_changed), self);
+	g_signal_connect (priv->downdelay, "value-changed", G_CALLBACK (stuff_changed), self);
+	g_signal_connect (priv->arp_targets, "changed", G_CALLBACK (stuff_changed), self);
+
+	g_signal_connect (priv->add, "clicked", G_CALLBACK (add_clicked), self);
+	g_signal_connect (priv->edit, "clicked", G_CALLBACK (edit_clicked), self);
+	g_signal_connect (priv->delete, "clicked", G_CALLBACK (delete_clicked), self);
+
+	g_signal_connect (priv->connections, "row-activated", G_CALLBACK (connection_double_clicked_cb), self);
+
+	selection = gtk_tree_view_get_selection (priv->connections);
+	g_signal_connect (selection, "changed", G_CALLBACK (connections_selection_changed_cb), self);
+	connections_selection_changed_cb (selection, self);
+}
+
+CEPage *
+ce_page_bond_new (NMConnection *connection,
+                  GtkWindow *parent_window,
+                  NMRemoteSettingsSystem *system_settings,
+                  NMAGConfSettings *gconf_settings,
+                  const char **out_secrets_setting_name,
+                  GError **error)
+{
+	CEPageBond *self;
+	CEPageBondPrivate *priv;
+	CEPage *parent;
+	NMSettingConnection *s_con;
+
+	self = CE_PAGE_BOND (g_object_new (CE_TYPE_PAGE_BOND,
+	                                   CE_PAGE_CONNECTION, connection,
+	                                   CE_PAGE_PARENT_WINDOW, parent_window,
+	                                   NULL));
+	parent = CE_PAGE (self);
+
+	parent->builder = gtk_builder_new ();
+
+	if (!gtk_builder_add_from_file (parent->builder, UIDIR "/ce-page-bond.ui", error)) {
+		g_warning ("Couldn't load builder file: %s", (*error)->message);
+		g_set_error_literal (error, NMA_ERROR, NMA_ERROR_GENERIC, _("Could not load bond user interface."));
+		g_object_unref (self);
+		return NULL;
+	}
+
+	parent->page = GTK_WIDGET (gtk_builder_get_object (parent->builder, "BondPage"));
+	if (!parent->page) {
+		g_set_error_literal (error, NMA_ERROR, NMA_ERROR_GENERIC, _("Could not load bond user interface."));
+		g_object_unref (self);
+		return NULL;
+	}
+	g_object_ref_sink (parent->page);
+
+	parent->title = g_strdup (_("Bond"));
+
+	bond_private_init (self);
+	priv = CE_PAGE_BOND_GET_PRIVATE (self);
+
+	priv->connection = g_object_ref (connection);
+	priv->system_settings = g_object_ref (system_settings);
+	priv->gconf_settings = g_object_ref (gconf_settings);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	priv->uuid = nm_setting_connection_get_uuid (s_con);
+
+	g_signal_connect (system_settings, "new-connection",
+	                  G_CALLBACK (connection_added), self);
+
+	priv->setting = (NMSettingBond *) nm_connection_get_setting (connection, NM_TYPE_SETTING_BOND);
+	if (!priv->setting) {
+		priv->setting = NM_SETTING_BOND (nm_setting_bond_new ());
+		nm_connection_add_setting (connection, NM_SETTING (priv->setting));
+	}
+
+	g_signal_connect (self, "initialized", G_CALLBACK (finish_setup), NULL);
+
+	return CE_PAGE (self);
+}
+
+static void
+ui_to_setting (CEPageBond *self)
+{
+	CEPageBondPrivate *priv = CE_PAGE_BOND_GET_PRIVATE (self);
+	const char *interface_name;
+	const char *mode;
+	const char *frequency;
+	const char *updelay;
+	const char *downdelay;
+	char *targets;
+
+	/* Interface name */
+	interface_name = gtk_entry_get_text (priv->interface_name);
+	g_object_set (priv->setting,
+	              NM_SETTING_BOND_INTERFACE_NAME, interface_name,
+	              NULL);
+
+	/* Mode */
+	switch (gtk_combo_box_get_active (priv->mode)) {
+	case MODE_BALANCE_RR:
+		mode = "balance-rr";
+		break;
+	case MODE_ACTIVE_BACKUP:
+		mode = "active-backup";
+		break;
+	case MODE_BALANCE_XOR:
+		mode = "balance-xor";
+		break;
+	case MODE_BROADCAST:
+		mode = "broadcast";
+		break;
+	case MODE_802_3AD:
+		mode = "802.3ad";
+		break;
+	case MODE_BALANCE_TLB:
+		mode = "balance-tlb";
+		break;
+	case MODE_BALANCE_ALB:
+		mode = "balance-alb";
+		break;
+	default:
+		g_assert_not_reached ();
+		break;
+	}
+
+	/* Monitoring mode/frequency */
+	frequency = gtk_entry_get_text (GTK_ENTRY (priv->frequency));
+	updelay = gtk_entry_get_text (GTK_ENTRY (priv->updelay));
+	downdelay = gtk_entry_get_text (GTK_ENTRY (priv->downdelay));
+	targets = uglify_targets (gtk_entry_get_text (priv->arp_targets));
+
+	switch (gtk_combo_box_get_active (priv->monitoring)) {
+	case MONITORING_MII:
+		nm_setting_bond_add_option (priv->setting, NM_SETTING_BOND_OPTION_MIIMON, frequency);
+		nm_setting_bond_add_option (priv->setting, NM_SETTING_BOND_OPTION_UPDELAY, updelay);
+		nm_setting_bond_add_option (priv->setting, NM_SETTING_BOND_OPTION_DOWNDELAY, downdelay);
+		nm_setting_bond_remove_option (priv->setting, NM_SETTING_BOND_OPTION_ARP_INTERVAL);
+		nm_setting_bond_remove_option (priv->setting, NM_SETTING_BOND_OPTION_ARP_IP_TARGET);
+		break;
+	case MONITORING_ARP:
+		nm_setting_bond_add_option (priv->setting, NM_SETTING_BOND_OPTION_ARP_INTERVAL, frequency);
+		if (targets)
+			nm_setting_bond_add_option (priv->setting, NM_SETTING_BOND_OPTION_ARP_IP_TARGET, targets);
+		else
+			nm_setting_bond_remove_option (priv->setting, NM_SETTING_BOND_OPTION_ARP_IP_TARGET);
+		nm_setting_bond_remove_option (priv->setting, NM_SETTING_BOND_OPTION_MIIMON);
+		nm_setting_bond_remove_option (priv->setting, NM_SETTING_BOND_OPTION_UPDELAY);
+		nm_setting_bond_remove_option (priv->setting, NM_SETTING_BOND_OPTION_DOWNDELAY);
+		break;
+	default:
+		g_assert_not_reached ();
+		break;
+	}
+
+	g_free (targets);
+
+	/* Slaves are updated as they're edited, so nothing to do */
+}
+
+static gboolean
+validate (CEPage *page, NMConnection *connection, GError **error)
+{
+	CEPageBond *self = CE_PAGE_BOND (page);
+	CEPageBondPrivate *priv = CE_PAGE_BOND_GET_PRIVATE (self);
+	GtkTreeIter iter;
+
+	/* Need at least one slave connection; we don't need to
+	 * recursively check that the connections are valid because they
+	 * can't end up in the table if they're not.
+	 */
+	if (!gtk_tree_model_get_iter_first (priv->connections_model, &iter))
+		return FALSE;
+
+	ui_to_setting (self);
+	return nm_setting_verify (NM_SETTING (priv->setting), NULL, error);
+}
+
+static void
+ce_page_bond_init (CEPageBond *self)
+{
+}
+
+static void
+ce_page_bond_class_init (CEPageBondClass *bond_class)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (bond_class);
+	CEPageClass *parent_class = CE_PAGE_CLASS (bond_class);
+
+	g_type_class_add_private (object_class, sizeof (CEPageBondPrivate));
+
+	/* virtual methods */
+	object_class->dispose = dispose;
+
+	parent_class->validate = validate;
+}
+
+
+void
+bond_connection_new (GtkWindow *parent,
+                     const char *detail,
+                     NMRemoteSettingsSystem *system_settings,
+                     NMAGConfSettings *gconf_settings,
+                     PageNewConnectionResultFunc result_func,
+                     gpointer user_data)
+{
+	NMConnection *connection;
+	int bond_num, max_bond_num, num;
+	GSList *connections, *iter;
+	NMConnection *conn2;
+	NMSettingBond *s_bond;
+	const char *iface;
+	char *my_iface;
+
+	connection = ce_page_new_connection (_("Bond connection %d"),
+	                                     NM_SETTING_BOND_SETTING_NAME,
+	                                     TRUE,
+	                                     system_settings,
+	                                     gconf_settings,
+	                                     user_data);
+	nm_connection_add_setting (connection, nm_setting_bond_new ());
+	nm_connection_set_scope (connection, NM_CONNECTION_SCOPE_SYSTEM);
+
+	/* Find an available interface name */
+	bond_num = max_bond_num = 0;
+	connections = ce_page_list_connections (system_settings, gconf_settings);
+	for (iter = connections; iter; iter = iter->next) {
+		conn2 = iter->data;
+
+		if (!nm_connection_is_type (conn2, NM_SETTING_BOND_SETTING_NAME))
+			continue;
+		s_bond = nm_connection_get_setting_bond (conn2);
+		if (!s_bond)
+			continue;
+		iface = nm_setting_bond_get_interface_name (s_bond);
+		if (!iface || strncmp (iface, "bond", 4) != 0 || !g_ascii_isdigit (iface[4]))
+			continue;
+
+		num = atoi (iface + 4);
+		if (num > max_bond_num)
+			max_bond_num = num;
+		if (num == bond_num)
+			bond_num = max_bond_num + 1;
+	}
+	g_slist_free (connections);
+
+	my_iface = g_strdup_printf ("bond%d", bond_num);
+	s_bond = nm_connection_get_setting_bond (connection);
+	g_object_set (G_OBJECT (s_bond),
+	              NM_SETTING_BOND_INTERFACE_NAME, my_iface,
+	              NULL);
+	g_free (my_iface);
+
+	(*result_func) (connection, FALSE, NULL, user_data);
+}
+
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-bond.h.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-bond.h
new file mode 100644
index 0000000..b8235c4
--- /dev/null
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-bond.h
@@ -0,0 +1,63 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager Connection editor -- Connection editor for NetworkManager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2012 Red Hat, Inc.
+ */
+
+#ifndef __PAGE_BOND_H__
+#define __PAGE_BOND_H__
+
+#include <nm-connection.h>
+
+#include <glib.h>
+#include <glib-object.h>
+
+#include "ce-page.h"
+
+#define CE_TYPE_PAGE_BOND            (ce_page_bond_get_type ())
+#define CE_PAGE_BOND(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), CE_TYPE_PAGE_BOND, CEPageBond))
+#define CE_PAGE_BOND_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), CE_TYPE_PAGE_BOND, CEPageBondClass))
+#define CE_IS_PAGE_BOND(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), CE_TYPE_PAGE_BOND))
+#define CE_IS_PAGE_BOND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), CE_TYPE_PAGE_BOND))
+#define CE_PAGE_BOND_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), CE_TYPE_PAGE_BOND, CEPageBondClass))
+
+typedef struct {
+	CEPage parent;
+} CEPageBond;
+
+typedef struct {
+	CEPageClass parent;
+} CEPageBondClass;
+
+GType ce_page_bond_get_type (void);
+
+CEPage *ce_page_bond_new (NMConnection *connection,
+                          GtkWindow *parent,
+                          NMRemoteSettingsSystem *system_settings,
+                          NMAGConfSettings *gconf_settings,
+                          const char **out_secrets_setting_name,
+                          GError **error);
+
+void bond_connection_new (GtkWindow *parent,
+                          const char *detail,
+                          NMRemoteSettingsSystem *system_settings,
+                          NMAGConfSettings *gconf_settings,
+                          PageNewConnectionResultFunc result_func,
+                          gpointer user_data);
+
+#endif  /* __PAGE_BOND_H__ */
+
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-dsl.c.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-dsl.c
index e05bdb7..74047eb 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-dsl.c.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-dsl.c
@@ -122,6 +122,8 @@ finish_setup (CEPageDsl *self, gpointer unused, GError *error, gpointer user_dat
 CEPage *
 ce_page_dsl_new (NMConnection *connection,
                  GtkWindow *parent_window,
+                 NMRemoteSettingsSystem *system_settings,
+                 NMAGConfSettings *gconf_settings,
                  const char **out_secrets_setting_name,
                  GError **error)
 {
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-dsl.h.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-dsl.h
index a43b5b4..e132756 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-dsl.h.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-dsl.h
@@ -49,6 +49,8 @@ GType ce_page_dsl_get_type (void);
 
 CEPage *ce_page_dsl_new (NMConnection *connection,
                          GtkWindow *parent,
+                         NMRemoteSettingsSystem *system_settings,
+                         NMAGConfSettings *gconf_settings,
                          const char **out_secrets_setting_name,
                          GError **error);
 
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-infiniband.c.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-infiniband.c
index 793b4ae..58e8c65 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-infiniband.c.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-infiniband.c
@@ -117,6 +117,8 @@ finish_setup (CEPageInfiniband *self, gpointer unused, GError *error, gpointer u
 CEPage *
 ce_page_infiniband_new (NMConnection *connection,
                         GtkWindow *parent_window,
+                        NMRemoteSettingsSystem *system_settings,
+                        NMAGConfSettings *gconf_settings,
                         const char **out_secrets_setting_name,
                         GError **error)
 {
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-infiniband.h.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-infiniband.h
index 95379d7..e3b4c45 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-infiniband.h.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-infiniband.h
@@ -47,6 +47,8 @@ GType ce_page_infiniband_get_type (void);
 
 CEPage *ce_page_infiniband_new (NMConnection *connection,
                                 GtkWindow *parent,
+                                NMRemoteSettingsSystem *system_settings,
+                                NMAGConfSettings *gconf_settings,
                                 const char **out_secrets_setting_name,
                                 GError **error);
 
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
index 3875ae9..5f06169 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
@@ -800,6 +800,8 @@ finish_setup (CEPageIP4 *self, gpointer unused, GError *error, gpointer user_dat
 CEPage *
 ce_page_ip4_new (NMConnection *connection,
                  GtkWindow *parent_window,
+                 NMRemoteSettingsSystem *system_settings,
+                 NMAGConfSettings *gconf_settings,
                  const char **out_secrets_setting_name,
                  GError **error)
 {
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ip4.h.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ip4.h
index 034ec60..7a31054 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ip4.h.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ip4.h
@@ -49,6 +49,8 @@ GType ce_page_ip4_get_type (void);
 
 CEPage *ce_page_ip4_new (NMConnection *connection,
                          GtkWindow *parent,
+                         NMRemoteSettingsSystem *system_settings,
+                         NMAGConfSettings *gconf_settings,
                          const char **out_secrets_setting_name,
                          GError **error);
 
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c
index 2765300..22eebb9 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c
@@ -783,6 +783,8 @@ finish_setup (CEPageIP6 *self, gpointer unused, GError *error, gpointer user_dat
 CEPage *
 ce_page_ip6_new (NMConnection *connection,
                  GtkWindow *parent_window,
+                 NMRemoteSettingsSystem *system_settings,
+                 NMAGConfSettings *gconf_settings,
                  const char **out_secrets_setting_name,
                  GError **error)
 {
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ip6.h.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ip6.h
index fd73a87..8917ddc 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ip6.h.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ip6.h
@@ -49,6 +49,8 @@ GType ce_page_ip6_get_type (void);
 
 CEPage *ce_page_ip6_new (NMConnection *connection,
                          GtkWindow *parent,
+                         NMRemoteSettingsSystem *system_settings,
+                         NMAGConfSettings *gconf_settings,
                          const char **out_secrets_setting_name,
                          GError **error);
 
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-mobile.c.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-mobile.c
index 398ca02..650728b 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-mobile.c.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-mobile.c
@@ -287,6 +287,8 @@ finish_setup (CEPageMobile *self, gpointer unused, GError *error, gpointer user_
 CEPage *
 ce_page_mobile_new (NMConnection *connection,
                     GtkWindow *parent_window,
+                    NMRemoteSettingsSystem *system_settings,
+                    NMAGConfSettings *gconf_settings,
                     const char **out_secrets_setting_name,
                     GError **error)
 {
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-mobile.h.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-mobile.h
index 495f403..fdb93a3 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-mobile.h.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-mobile.h
@@ -49,6 +49,8 @@ GType ce_page_mobile_get_type (void);
 
 CEPage *ce_page_mobile_new (NMConnection *connection,
                             GtkWindow *parent,
+                            NMRemoteSettingsSystem *system_settings,
+                            NMAGConfSettings *gconf_settings,
                             const char **out_secrets_setting_name,
                             GError **error);
 
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ppp.c.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ppp.c
index 281a54f..8ecfefb 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ppp.c.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ppp.c
@@ -264,6 +264,8 @@ finish_setup (CEPagePpp *self, gpointer unused, GError *error, gpointer user_dat
 CEPage *
 ce_page_ppp_new (NMConnection *connection,
                  GtkWindow *parent_window,
+                 NMRemoteSettingsSystem *system_settings,
+                 NMAGConfSettings *gconf_settings,
                  const char **out_secrets_setting_name,
                  GError **error)
 {
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ppp.h.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ppp.h
index 6960a36..56ef48d 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ppp.h.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-ppp.h
@@ -49,6 +49,8 @@ GType ce_page_ppp_get_type (void);
 
 CEPage *ce_page_ppp_new (NMConnection *connection,
                          GtkWindow *parent,
+                         NMRemoteSettingsSystem *system_settings,
+                         NMAGConfSettings *gconf_settings,
                          const char **out_secrets_setting_name,
                          GError **error);
 
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-vpn.c.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-vpn.c
index 50b66b7..a62ff71 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-vpn.c.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-vpn.c
@@ -92,6 +92,8 @@ finish_setup (CEPageVpn *self, gpointer unused, GError *error, gpointer user_dat
 CEPage *
 ce_page_vpn_new (NMConnection *connection,
                  GtkWindow *parent_window,
+                 NMRemoteSettingsSystem *system_settings,
+                 NMAGConfSettings *gconf_settings,
                  const char **out_secrets_setting_name,
                  GError **error)
 {
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-vpn.h.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-vpn.h
index 3a95f13..664a3af 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-vpn.h.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-vpn.h
@@ -49,6 +49,8 @@ GType ce_page_vpn_get_type (void);
 
 CEPage *ce_page_vpn_new (NMConnection *connection,
                          GtkWindow *parent,
+                         NMRemoteSettingsSystem *system_settings,
+                         NMAGConfSettings *gconf_settings,
                          const char **out_secrets_setting_name,
                          GError **error);
 
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wired-security.c.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wired-security.c
index 9f72d07..ec08755 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wired-security.c.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wired-security.c
@@ -102,6 +102,8 @@ finish_setup (CEPageWiredSecurity *self, gpointer unused, GError *error, gpointe
 CEPage *
 ce_page_wired_security_new (NMConnection *connection,
                             GtkWindow *parent_window,
+                            NMRemoteSettingsSystem *system_settings,
+                            NMAGConfSettings *gconf_settings,
                             const char **out_secrets_setting_name,
                             GError **error)
 {
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wired-security.h.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wired-security.h
index 80bce08..0bc0ec4 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wired-security.h.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wired-security.h
@@ -51,6 +51,8 @@ GType ce_page_wired_security_get_type (void);
 
 CEPage *ce_page_wired_security_new (NMConnection *connection,
                                     GtkWindow *parent,
+                                    NMRemoteSettingsSystem *system_settings,
+                                    NMAGConfSettings *gconf_settings,
                                     const char **out_secrets_setting_name,
                                     GError **error);
 
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wired.c.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wired.c
index 97d4317..52107f1 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wired.c.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wired.c
@@ -197,6 +197,8 @@ finish_setup (CEPageWired *self, gpointer unused, GError *error, gpointer user_d
 CEPage *
 ce_page_wired_new (NMConnection *connection,
                    GtkWindow *parent_window,
+                   NMRemoteSettingsSystem *system_settings,
+                   NMAGConfSettings *gconf_settings,
                    const char **out_secrets_setting_name,
                    GError **error)
 {
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wired.h.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wired.h
index 1708c3c..d379a2e 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wired.h.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wired.h
@@ -49,6 +49,8 @@ GType ce_page_wired_get_type (void);
 
 CEPage *ce_page_wired_new (NMConnection *connection,
                            GtkWindow *parent,
+                           NMRemoteSettingsSystem *system_settings,
+                           NMAGConfSettings *gconf_settings,
                            const char **out_secrets_setting_name,
                            GError **error);
 
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wireless-security.c.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wireless-security.c
index b56dde5..f05bfe9 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wireless-security.c.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wireless-security.c
@@ -347,6 +347,8 @@ finish_setup (CEPageWirelessSecurity *self, gpointer unused, GError *error, gpoi
 CEPage *
 ce_page_wireless_security_new (NMConnection *connection,
                                GtkWindow *parent_window,
+                               NMRemoteSettingsSystem *system_settings,
+                               NMAGConfSettings *gconf_settings,
                                const char **out_secrets_setting_name,
                                GError **error)
 {
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wireless-security.h.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wireless-security.h
index d1cc529..d481584 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wireless-security.h.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wireless-security.h
@@ -56,6 +56,8 @@ GType ce_page_wireless_security_get_type (void);
 
 CEPage *ce_page_wireless_security_new (NMConnection *connection,
                                        GtkWindow *parent,
+                                       NMRemoteSettingsSystem *system_settings,
+                                       NMAGConfSettings *gconf_settings,
                                        const char **out_secrets_setting_name,
                                        GError **error);
 
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wireless.c.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wireless.c
index fdd0349..b1935df 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wireless.c.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wireless.c
@@ -382,6 +382,8 @@ finish_setup (CEPageWireless *self, gpointer unused, GError *error, gpointer use
 CEPage *
 ce_page_wireless_new (NMConnection *connection,
                       GtkWindow *parent_window,
+                      NMRemoteSettingsSystem *system_settings,
+                      NMAGConfSettings *gconf_settings,
                       const char **out_secrets_setting_name,
                       GError **error)
 {
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wireless.h.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wireless.h
index 5fb2830..11dfdc9 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wireless.h.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/connection-editor/page-wireless.h
@@ -49,6 +49,8 @@ GType ce_page_wireless_get_type (void);
 
 CEPage *ce_page_wireless_new (NMConnection *connection,
                               GtkWindow *parent,
+                              NMRemoteSettingsSystem *system_settings,
+                              NMAGConfSettings *gconf_settings,
                               const char **out_secrets_setting_name,
                               GError **error);
 
diff --git NetworkManager-0.8.1/network-manager-applet-0.8.1/src/marshallers/nma-marshal.list.ce-bond NetworkManager-0.8.1/network-manager-applet-0.8.1/src/marshallers/nma-marshal.list
index 5aef346..da48bed 100644
--- NetworkManager-0.8.1/network-manager-applet-0.8.1/src/marshallers/nma-marshal.list.ce-bond
+++ NetworkManager-0.8.1/network-manager-applet-0.8.1/src/marshallers/nma-marshal.list
@@ -7,4 +7,4 @@ VOID:INT,POINTER
 VOID:STRING,BOXED
 VOID:UINT,UINT
 VOID:UINT,STRING,STRING
-
+VOID:ENUM
