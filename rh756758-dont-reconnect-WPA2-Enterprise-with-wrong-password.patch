From a27cd8e5d95e4f5a1c54d6dc2515feb2bb861444 Mon Sep 17 00:00:00 2001
From: Dan Williams <dcbw@redhat.com>
Date: Wed, 29 Jun 2011 18:15:05 -0500
Subject: [PATCH] wifi: allow supplicant disconnect request more often

Use a broader range of supplicant interface states to determine
when to tell the supplicant to idle; we want to allow the
disconnect in all of these states, not just some of them.

Second, allow the active network to be removed from the supplicant's
list in most of these states, even when the supplicant interface is
inactive or disconnected.
---
 src/supplicant-manager/nm-supplicant-interface.c |   18 +++++++-----------
 1 files changed, 7 insertions(+), 11 deletions(-)

diff --git a/src/supplicant-manager/nm-supplicant-interface.c b/src/supplicant-manager/nm-supplicant-interface.c
index e9e58f3..2459f58 100644
--- a/src/supplicant-manager/nm-supplicant-interface.c
+++ b/src/supplicant-manager/nm-supplicant-interface.c
@@ -682,17 +682,13 @@ nm_supplicant_interface_disconnect (NMSupplicantInterface * self)
 	if (!priv->iface_proxy)
 		return;
 
-	/* Don't try to disconnect if the supplicant interface is already
-	 * disconnected.
-	 */
-	if (priv->con_state == NM_SUPPLICANT_INTERFACE_CON_STATE_DISCONNECTED
-	    || priv->con_state == NM_SUPPLICANT_INTERFACE_CON_STATE_INACTIVE) {
-		if (priv->net_proxy) {
-			g_object_unref (priv->net_proxy);
-			priv->net_proxy = NULL;
-		}
-
-		return;
+	/* Disconnect from the current AP */
+	if (   (priv->con_state >= NM_SUPPLICANT_INTERFACE_CON_STATE_SCANNING)
+	    && (priv->con_state <= NM_SUPPLICANT_INTERFACE_CON_STATE_COMPLETED)) {
+		dbus_g_proxy_begin_call (priv->iface_proxy, "Disconnect",
+		                         disconnect_cb,
+		                         NULL, NULL,
+		                         G_TYPE_INVALID);
 	}
 
 	/* Remove any network that was added by NetworkManager */
@@ -700,11 +701,6 @@ nm_supplicant_interface_disconnect (NMSupplicantInterface * self)
 		g_object_unref (priv->net_proxy);
 		priv->net_proxy = NULL;
 	}
-
-	dbus_g_proxy_begin_call (priv->iface_proxy, "disconnect",
-	                         disconnect_cb,
-	                         NULL, NULL,
-	                         G_TYPE_INVALID);
 }
 
 static void
-- 
1.7.7.4

From 6187b85052644f212d12ba6f76c60c4c14f70f79 Mon Sep 17 00:00:00 2001
From: Dan Williams <dcbw@redhat.com>
Date: Wed, 29 Jun 2011 18:17:43 -0500
Subject: [PATCH] wifi: immediately request new 802.1x 'always-ask' passwords
 if they fail

Instead of retrying the password a number of times, immediately fail the
connection and ask for a new pasword if (1) the request fails during the
802.1x authentication and (2) the password is an 'always-ask' 802.1x
password.  The password is bad anyway, and in the case of RSA/OTP tokens
the code may have already changed, so it's pointless to keep retrying
the same password when it's already stale.

diff -up NetworkManager-0.8.1/src/nm-device-wifi.c.ask NetworkManager-0.8.1/src/nm-device-wifi.c
--- NetworkManager-0.8.1/src/nm-device-wifi.c.ask	2011-11-08 17:49:03.497972447 -0600
+++ NetworkManager-0.8.1/src/nm-device-wifi.c	2011-11-08 17:49:03.508972310 -0600
@@ -2541,6 +2541,63 @@ supplicant_iface_state_cb (NMSupplicantI
 
 
 static gboolean
+handle_8021x_auth_fail (NMDeviceWifi *self, guint32 new_state, guint32 old_state)
+{
+	NMDevice *device = NM_DEVICE (self);
+	NMSetting8021x *s_8021x;
+	NMActRequest *req;
+	NMConnection *connection;
+	gboolean ask = FALSE;
+	guint32 i;
+
+	g_return_val_if_fail (new_state == NM_SUPPLICANT_INTERFACE_CON_STATE_DISCONNECTED, FALSE);
+
+	/* Only care about ASSOCIATED -> DISCONNECTED transitions since 802.1x stuff
+	 * happens after the ASSOCIATED state during the 4-way handshake.
+	 */
+	if (old_state != NM_SUPPLICANT_INTERFACE_CON_STATE_ASSOCIATED)
+		return FALSE;
+
+	req = nm_device_get_act_request (NM_DEVICE (self));
+	g_return_val_if_fail (req != NULL, FALSE);
+
+	connection = nm_act_request_get_connection (req);
+	g_return_val_if_fail (connection != NULL, FALSE);
+
+	/* If it's an 802.1x connection using GTC, we might need to ask again
+	 * immediately because the token code may have changed.
+	 */
+	s_8021x = (NMSetting8021x *) nm_connection_get_setting (connection, NM_TYPE_SETTING_802_1X);
+	if (s_8021x) {
+		for (i = 0; i < nm_setting_802_1x_get_num_eap_methods (s_8021x); i++) {
+			if (g_strcmp0 (nm_setting_802_1x_get_eap_method (s_8021x, i), "gtc") == 0) {
+				ask = TRUE;
+				break;
+			}
+		}
+	}
+
+	if (ask) {
+		nm_connection_clear_secrets (connection);
+		cleanup_association_attempt (self, TRUE);
+
+		nm_log_info (LOGD_DEVICE | LOGD_WIFI,
+		             "Activation (%s/wireless): disconnected during association,"
+		             " asking for new key.", nm_device_get_iface (device));
+
+		nm_device_state_changed (device, NM_DEVICE_STATE_NEED_AUTH, NM_DEVICE_STATE_REASON_SUPPLICANT_DISCONNECT);
+		nm_act_request_get_secrets (req,
+		                            NM_SETTING_802_1X_SETTING_NAME,
+		                            TRUE,
+		                            SECRETS_CALLER_WIFI,
+		                            NM_SETTING_802_1X_PASSWORD,
+		                            NULL);
+	}
+
+	return ask;
+}
+
+static gboolean
 supplicant_iface_connection_state_cb_handler (gpointer user_data)
 {
 	SupplicantStateTask *task = (SupplicantStateTask *) user_data;
@@ -2581,13 +2662,16 @@ supplicant_iface_connection_state_cb_han
 		}
 	} else if (task->new_state == NM_SUPPLICANT_INTERFACE_CON_STATE_DISCONNECTED) {
 		if (nm_device_get_state (dev) == NM_DEVICE_STATE_ACTIVATED || nm_device_is_activating (dev)) {
-			/* Start the link timeout so we allow some time for reauthentication,
-			 * use a longer timeout if we are scanning since some cards take a
-			 * while to scan.
-			 */
-			if (!priv->link_timeout_id) {
-				priv->link_timeout_id = g_timeout_add_seconds (scanning ? 30 : 15,
-				                                               link_timeout_cb, self);
+			/* Disconnect during authentication may mean the 802.1x password is wrong */
+			if (handle_8021x_auth_fail (self, task->new_state, task->old_state) == FALSE) {
+				/* Otherwise start the link timeout so we allow some time for
+				 * reauthentication, use a longer timeout if we are scanning
+				 * since some cards take a while to scan.
+				 */
+				if (!priv->link_timeout_id) {
+					priv->link_timeout_id = g_timeout_add_seconds (scanning ? 30 : 15,
+						                                           link_timeout_cb, self);
+				}
 			}
 		}
 	}
@@ -3652,6 +3736,10 @@ device_state_changed (NMDevice *device,
 		}
 		clear_aps = TRUE;
 		break;
+	case NM_DEVICE_STATE_NEED_AUTH:
+		if (priv->supplicant.iface)
+			nm_supplicant_interface_disconnect (priv->supplicant.iface);
+		break;
 	case NM_DEVICE_STATE_ACTIVATED:
 		activation_success_handler (device);
 		break;
