From e17663e284eaebecff2dadc198e25b8bc60f24dd Mon Sep 17 00:00:00 2001
From: Lubomir Rintel <lkundrak@v3.sk>
Date: Thu, 8 Dec 2016 15:51:52 +0100
Subject: [PATCH 1/1] ifcfg-rh: give NM_CONTROLLED=no priority over
 BOOTPROTO=ibft

We still want to block management of devices that have NM_CONTROLLED=no even if
they are ibft-configured and we won't configure them anyway.

https://bugzilla.redhat.com/show_bug.cgi?id=1261893
---
 system-settings/plugins/ifcfg-rh/reader.c | 20 +++++++++++---------
 1 file changed, 11 insertions(+), 9 deletions(-)

diff --git a/system-settings/plugins/ifcfg-rh/reader.c b/system-settings/plugins/ifcfg-rh/reader.c
index 384d797..3f24612 100644
--- a/system-settings/plugins/ifcfg-rh/reader.c
+++ b/system-settings/plugins/ifcfg-rh/reader.c
@@ -4189,17 +4189,19 @@ connection_from_file (const char *filename,
 		g_free (lower);
 	}
 
-	/* iBFT is handled by the iBFT settings plugin */
-	bootproto = svGetValue (parsed, "BOOTPROTO", FALSE);
-	if (bootproto && !g_ascii_strcasecmp (bootproto, "ibft")) {
-		if (ignore_error)
-			*ignore_error = TRUE;
-		g_set_error (&error, IFCFG_PLUGIN_ERROR, 0,
-		             "Ignoring iBFT configuration");
+	if (nm_controlled) {
+		/* iBFT is handled by the iBFT settings plugin */
+		bootproto = svGetValue (parsed, "BOOTPROTO", FALSE);
+		if (bootproto && !g_ascii_strcasecmp (bootproto, "ibft")) {
+			if (ignore_error)
+				*ignore_error = TRUE;
+			g_set_error (&error, IFCFG_PLUGIN_ERROR, 0,
+				     "Ignoring iBFT configuration");
+			g_free (bootproto);
+			goto done;
+		}
 		g_free (bootproto);
-		goto done;
 	}
-	g_free (bootproto);
 
 	/* Construct the connection */
 	if (!strcasecmp (type, TYPE_ETHERNET))
-- 
2.9.3
From bedf9f6e38a67f08d8cdccf1b445812a4aae9bdd Mon Sep 17 00:00:00 2001
From: Lubomir Rintel <lkundrak@rhel6-2.local>
Date: Fri, 16 Dec 2016 16:15:47 +0100
Subject: [PATCH 1/2] ibft: pass the known addressing data along too

Even if they come from DHCP we need to assume they're static as the early boot
firmware lost the rest of the lease data and they're about the only way we can
match what initrd configured with what the boot firmware indicates.

They're likely too precious to loose anyway, since getting a different one from
DHCP would result in breakdown of the storage access.
---
 system-settings/plugins/ibft/reader.c |    9 +++------
 1 files changed, 3 insertions(+), 6 deletions(-)

diff --git a/system-settings/plugins/ibft/reader.c b/system-settings/plugins/ibft/reader.c
index 2267267..3b36432 100644
--- a/system-settings/plugins/ibft/reader.c
+++ b/system-settings/plugins/ibft/reader.c
@@ -314,17 +314,15 @@ ip4_setting_add_from_block (const GPtrArray *block,
 
 	if (!g_ascii_strcasecmp (s_method, "dhcp")) {
 		g_object_set (s_ip4, NM_SETTING_IP4_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
-		goto success;
-	} else if (g_ascii_strcasecmp (s_method, "static") != 0) {
+	} else if (!g_ascii_strcasecmp (s_method, "static")) {
+		g_object_set (s_ip4, NM_SETTING_IP4_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL, NULL);
+	} else {
 		g_set_error (error, IBFT_PLUGIN_ERROR, 0,
 		             "iBFT: malformed iscsiadm record: unknown " ISCSI_BOOTPROTO_TAG " '%s'.",
 		             s_method);
 		goto error;
 	}
 
-	/* Static configuration stuff */
-	g_object_set (s_ip4, NM_SETTING_IP4_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL, NULL);
-
 	/* IP address */
 	if (!s_ipaddr || inet_pton (AF_INET, s_ipaddr, &ipaddr) != 1) {
 		g_set_error (error, IBFT_PLUGIN_ERROR, 0,
@@ -376,7 +374,6 @@ ip4_setting_add_from_block (const GPtrArray *block,
 	if (dns2)
 		nm_setting_ip4_config_add_dns (s_ip4, dns2);
 
-success:
 	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
 	return TRUE;
 
-- 
1.7.1

From 305e44a37f567e7483552515b43e9f3209e56654 Mon Sep 17 00:00:00 2001
From: Lubomir Rintel <lkundrak@rhel6-2.local>
Date: Fri, 16 Dec 2016 16:21:28 +0100
Subject: [PATCH 2/2] device: use addresses to match ip4 configuration with method=auto as well

If no leases matched, then perhaps the static configuration is there? This is
useful for matching the iBFT configuration, where the early boot tooling leaves
the addressing in place and the iBFT plugin gets the boot firmware's idea that
we need to match it against.
---
 src/nm-device.c |   13 ++++++++-----
 1 files changed, 8 insertions(+), 5 deletions(-)

diff --git a/src/nm-device.c b/src/nm-device.c
index b59555e..804c5cd 100644
--- a/src/nm-device.c
+++ b/src/nm-device.c
@@ -4814,6 +4814,7 @@ ip4_match_config (NMDevice *self, NMConnection *connection)
 	GSList *leases, *iter;
 	NMDHCPManager *dhcp_mgr;
 	const char *method;
+	gboolean found = FALSE;
 
 	s_ip4 = nm_connection_get_setting_ip4_config (connection);
 	if (!s_ip4)
@@ -4828,8 +4829,6 @@ ip4_match_config (NMDevice *self, NMConnection *connection)
 
 	method = nm_setting_ip4_config_get_method (s_ip4);
 	if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_AUTO)) {
-		gboolean found = FALSE;
-
 		/* Find at least one lease's address on the device */
 		for (iter = leases; iter; iter = g_slist_next (iter)) {
 			NMIP4Config *ip4_config = iter->data;
@@ -4846,7 +4845,8 @@ ip4_match_config (NMDevice *self, NMConnection *connection)
 		}
 		g_slist_foreach (leases, (GFunc) g_object_unref, NULL);
 		g_slist_free (leases);
-		return found;
+		if (found)
+			return TRUE;
 	} else {
 		/* Maybe the connection used to be DHCP and there are stale leases; ignore them */
 		g_slist_foreach (leases, (GFunc) g_object_unref, NULL);
@@ -4863,7 +4863,8 @@ ip4_match_config (NMDevice *self, NMConnection *connection)
 	 * avahi-autoipd isn't smart enough to allow the link-local address to be
 	 * determined at any point other than when it was first assigned.
 	 */
-	if (strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_MANUAL))
+	if (   strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_MANUAL)
+	    && strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_AUTO))
 		return FALSE;
 
 	/* Everything below for static addressing */
@@ -4879,10 +4880,12 @@ ip4_match_config (NMDevice *self, NMConnection *connection)
 		                              &tmp,
 		                              nm_ip4_address_get_prefix (addr)))
 			return FALSE;
+		else
+			found = TRUE;
 	}
 
 	/* Success; all the connection's static IP addresses are assigned to the device */
-	return TRUE;
+	return found;
 }
 
 gboolean
-- 
1.7.1

From 947202d43260c260c70bf7c55c224204359effda Mon Sep 17 00:00:00 2001
From: Lubomir Rintel <lkundrak@v3.sk>
Date: Thu, 12 Jan 2017 19:40:00 +0100
Subject: [PATCH] ibft: don't break down when a dynamic connection doesn't have
 an address

The boot firmware *should* have gotten one already; but let's be forgiving
if it didn't to make the test happy.
---
 system-settings/plugins/ibft/reader.c | 22 +++++++++++++---------
 1 file changed, 13 insertions(+), 9 deletions(-)

diff --git a/system-settings/plugins/ibft/reader.c b/system-settings/plugins/ibft/reader.c
index 3b36432..2d9568b 100644
--- a/system-settings/plugins/ibft/reader.c
+++ b/system-settings/plugins/ibft/reader.c
@@ -291,6 +291,7 @@ ip4_setting_add_from_block (const GPtrArray *block,
 	guint32 dns2 = 0;
 	guint32 netmask = 0;
 	guint32 prefix;
+	gboolean need_static = TRUE;
 
 	g_assert (block);
 
@@ -313,6 +314,7 @@ ip4_setting_add_from_block (const GPtrArray *block,
 	s_ip4 = (NMSettingIP4Config *) nm_setting_ip4_config_new ();
 
 	if (!g_ascii_strcasecmp (s_method, "dhcp")) {
+		need_static = FALSE;
 		g_object_set (s_ip4, NM_SETTING_IP4_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_AUTO, NULL);
 	} else if (!g_ascii_strcasecmp (s_method, "static")) {
 		g_object_set (s_ip4, NM_SETTING_IP4_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL, NULL);
@@ -324,7 +326,7 @@ ip4_setting_add_from_block (const GPtrArray *block,
 	}
 
 	/* IP address */
-	if (!s_ipaddr || inet_pton (AF_INET, s_ipaddr, &ipaddr) != 1) {
+	if ((need_static && !s_ipaddr) || (s_ipaddr && inet_pton (AF_INET, s_ipaddr, &ipaddr) != 1)) {
 		g_set_error (error, IBFT_PLUGIN_ERROR, 0,
 		             "iBFT: malformed iscsiadm record: invalid IP address '%s'.",
 		             s_ipaddr);
@@ -332,7 +334,7 @@ ip4_setting_add_from_block (const GPtrArray *block,
 	}
 
 	/* Subnet/prefix */
-	if (!s_netmask || inet_pton (AF_INET, s_netmask, &netmask) != 1) {
+	if ((need_static && !s_netmask) || (s_netmask && inet_pton (AF_INET, s_netmask, &netmask) != 1)) {
 		g_set_error (error, IBFT_PLUGIN_ERROR, 0,
 		             "iBFT: malformed iscsiadm record: invalid subnet mask '%s'.",
 		             s_netmask);
@@ -361,13 +363,15 @@ ip4_setting_add_from_block (const GPtrArray *block,
 		goto error;
 	}
 
-	addr = nm_ip4_address_new ();
-	g_assert (addr);
-	nm_ip4_address_set_address (addr, ipaddr);
-	nm_ip4_address_set_prefix (addr, prefix);
-	nm_ip4_address_set_gateway (addr, gateway);
-	nm_setting_ip4_config_add_address (s_ip4, addr);
-	nm_ip4_address_unref (addr);
+	if (ipaddr) {
+		addr = nm_ip4_address_new ();
+		g_assert (addr);
+		nm_ip4_address_set_address (addr, ipaddr);
+		nm_ip4_address_set_prefix (addr, prefix);
+		nm_ip4_address_set_gateway (addr, gateway);
+		nm_setting_ip4_config_add_address (s_ip4, addr);
+		nm_ip4_address_unref (addr);
+	}
 
 	if (dns1)
 		nm_setting_ip4_config_add_dns (s_ip4, dns1);
-- 
2.9.3

