--- NetworkManager-0.8.1/libnm-util/libnm-util.ver.vlan-fixes	2012-10-04 14:50:11.864223018 -0400
+++ NetworkManager-0.8.1/libnm-util/libnm-util.ver	2012-10-04 14:51:38.203229889 -0400
@@ -407,6 +407,7 @@
 	nm_utils_hwaddr_len;
 	nm_utils_hwaddr_ntoa;
 	nm_utils_hwaddr_type;
+	nm_utils_iface_valid_name;
 	nm_utils_init;
 	nm_utils_ip4_addresses_from_gvalue;
 	nm_utils_ip4_addresses_to_gvalue;
@@ -420,6 +421,7 @@
 	nm_utils_ip6_routes_from_gvalue;
 	nm_utils_ip6_routes_to_gvalue;
 	nm_utils_is_empty_ssid;
+	nm_utils_is_uuid;
 	nm_utils_same_ssid;
 	nm_utils_security_valid;
 	nm_utils_slist_free;
--- NetworkManager-0.8.1/libnm-util/nm-setting-bond.c.vlan-fixes	2012-10-04 14:50:11.883223018 -0400
+++ NetworkManager-0.8.1/libnm-util/nm-setting-bond.c	2012-10-04 14:52:44.277235204 -0400
@@ -319,31 +319,6 @@
 	g_assert_not_reached ();
 }
 
-/*
- * This function is a 1:1 copy of the kernel's
- * dev_valid_name() in net/core/dev.c
- */
-static gboolean
-dev_valid_name(const char *name)
-{
-	if (*name == '\0')
-		return FALSE;
-
-	if (strlen (name) >= 16)
-		return FALSE;
-
-	if (!strcmp (name, ".") || !strcmp (name, ".."))
-		return FALSE;
-
-	while (*name) {
-		if (*name == '/' || isspace (*name))
-			return FALSE;
-		name++;
-	}
-
-	return TRUE;
-}
-
 static gboolean
 verify (NMSetting *setting, GSList *all_settings, GError **error)
 {
@@ -367,7 +342,7 @@
 		return FALSE;
 	}
 
-	if (!dev_valid_name (priv->interface_name)) {
+	if (!nm_utils_iface_valid_name (priv->interface_name)) {
 		g_set_error (error,
 		             NM_SETTING_BOND_ERROR,
 		             NM_SETTING_BOND_ERROR_INVALID_PROPERTY,
--- NetworkManager-0.8.1/libnm-util/nm-setting-connection.c.vlan-fixes	2012-10-04 14:50:11.868223018 -0400
+++ NetworkManager-0.8.1/libnm-util/nm-setting-connection.c	2012-10-04 14:50:33.945224780 -0400
@@ -29,6 +29,7 @@
 #include "nm-setting-bond.h"
 #include "nm-setting-ip4-config.h"
 #include "nm-setting-ip6-config.h"
+#include "nm-utils.h"
 
 /**
  * SECTION:nm-setting-connection
@@ -277,22 +278,6 @@
 }
 
 static gboolean
-validate_uuid (const char *uuid)
-{
-	int i;
-
-	if (!uuid || !strlen (uuid))
-		return FALSE;
-
-	for (i = 0; i < strlen (uuid); i++) {
-		if (!isxdigit (uuid[i]) && (uuid[i] != '-'))
-			return FALSE;
-	}
-
-	return TRUE;
-}
-
-static gboolean
 verify (NMSetting *setting, GSList *all_settings, GError **error)
 {
 	NMSettingConnectionPrivate *priv = NM_SETTING_CONNECTION_GET_PRIVATE (setting);
@@ -317,7 +302,7 @@
 		             NM_SETTING_CONNECTION_ERROR_MISSING_PROPERTY,
 		             NM_SETTING_CONNECTION_UUID);
 		return FALSE;
-	} else if (!validate_uuid (priv->uuid)) {
+	} else if (!nm_utils_is_uuid (priv->uuid)) {
 		g_set_error (error,
 		             NM_SETTING_CONNECTION_ERROR,
 		             NM_SETTING_CONNECTION_ERROR_INVALID_PROPERTY,
--- NetworkManager-0.8.1/libnm-util/nm-utils.c.vlan-fixes	2012-10-04 14:50:11.870223016 -0400
+++ NetworkManager-0.8.1/libnm-util/nm-utils.c	2012-10-04 14:52:16.348232935 -0400
@@ -2506,3 +2506,58 @@
 
 	return g_string_free (out, FALSE);
 }
+
+/**
+ * nm_utils_is_uuid:
+ * @str: a string that might be a UUID
+ *
+ * Checks if @str is a UUID
+ *
+ * Returns: %TRUE if @str is a UUID, %FALSE if not
+ */
+gboolean
+nm_utils_is_uuid (const char *str)
+{
+	const char *p = str;
+	int num_dashes = 0;
+
+	while (*p) {
+		if (*p == '-')
+			num_dashes++;
+		else if (!isxdigit (*p))
+			return FALSE;
+		p++;
+	}
+
+	return (num_dashes == 4) && (p - str == 36);
+}
+
+/**
+ * nm_utils_iface_valid_name:
+ * @name: Name of interface
+ *
+ * This function is a 1:1 copy of the kernel's interface validation
+ * function in net/core/dev.c.
+ *
+ * Returns: %TRUE if interface name is valid, otherwise %FALSE is returned.
+ */
+gboolean
+nm_utils_iface_valid_name(const char *name)
+{
+	if (*name == '\0')
+		return FALSE;
+
+	if (strlen (name) >= 16)
+		return FALSE;
+
+	if (!strcmp (name, ".") || !strcmp (name, ".."))
+		return FALSE;
+
+	while (*name) {
+		if (*name == '/' || isspace (*name))
+			return FALSE;
+		name++;
+	}
+
+	return TRUE;
+}
--- NetworkManager-0.8.1/libnm-util/nm-setting-vlan.c.vlan-fixes	2012-10-04 15:00:42.768273364 -0400
+++ NetworkManager-0.8.1/libnm-util/nm-setting-vlan.c	2012-10-04 15:04:07.397290117 -0400
@@ -21,7 +21,10 @@
  * (C) Copyright 2011 Red Hat, Inc.
  */
 
+#include <stdlib.h>
+#include <string.h>
 #include <dbus/dbus-glib.h>
+
 #include "nm-setting-vlan.h"
 #include "nm-param-spec-specialized.h"
 #include "nm-utils.h"
@@ -260,7 +263,6 @@
                                   NMVlanPriorityMap map,
                                   const char *str)
 {
-	NMSettingVlanPrivate *priv = NULL;
 	GSList *list = NULL, *iter = NULL;
 	PriorityMap *item = NULL;
 
@@ -268,7 +270,6 @@
 	g_return_val_if_fail (map == NM_VLAN_INGRESS_MAP || map == NM_VLAN_EGRESS_MAP, FALSE);
 	g_return_val_if_fail (str && str[0], FALSE);
 
-	priv = NM_SETTING_VLAN_GET_PRIVATE (setting);
 	list = get_map (setting, map);
 
 	item = priority_map_new_from_str (map, str);
@@ -458,29 +460,68 @@
 verify (NMSetting *setting, GSList *all_settings, GError **error)
 {
 	NMSettingVlanPrivate *priv = NM_SETTING_VLAN_GET_PRIVATE (setting);
-
-	if (priv->iface_name && !priv->iface_name[0]) {
-		g_set_error (error,
-		             NM_SETTING_VLAN_ERROR,
-		             NM_SETTING_VLAN_ERROR_INVALID_PROPERTY,
-		             NM_SETTING_VLAN_INTERFACE_NAME);
-		return FALSE;
+	NMSettingConnection *s_con = NULL;
+	NMSettingWired *s_wired = NULL;
+	GSList *iter;
+
+	for (iter = all_settings; iter; iter = iter->next) {
+		if (NM_IS_SETTING_CONNECTION (iter->data))
+			s_con = iter->data;
+		else if (NM_IS_SETTING_WIRED (iter->data))
+			s_wired = iter->data;
 	}
 
-	if (priv->parent && !priv->parent[0]) {
+	/* If iface_name is specified, it must be a valid interface name. We
+	 * don't check that it matches parent and/or id, because we allowing
+	 * renaming vlans to arbitrary names.
+	 */
+	if (priv->iface_name && !nm_utils_iface_valid_name (priv->iface_name)) {
 		g_set_error (error,
 		             NM_SETTING_VLAN_ERROR,
 		             NM_SETTING_VLAN_ERROR_INVALID_PROPERTY,
-		             NM_SETTING_VLAN_PARENT);
+		             NM_SETTING_VLAN_INTERFACE_NAME);
 		return FALSE;
 	}
 
-	if (priv->id > 4095) {
-		g_set_error (error,
-		             NM_SETTING_VLAN_ERROR,
-		             NM_SETTING_VLAN_ERROR_INVALID_PROPERTY,
-		             NM_SETTING_VLAN_ID);
-		return FALSE;
+	if (priv->parent) {
+		if (nm_utils_is_uuid (priv->parent)) {
+			/* If we have an NMSettingConnection:master with slave-type="vlan",
+			 * then it must be the same UUID.
+			 */
+			if (s_con) {
+				const char *master = NULL, *slave_type = NULL;
+
+				slave_type = nm_setting_connection_get_slave_type (s_con);
+				if (!g_strcmp0 (slave_type, NM_SETTING_VLAN_SETTING_NAME))
+					master = nm_setting_connection_get_master (s_con);
+
+				if (master && g_strcmp0 (priv->parent, master) != 0) {
+					g_set_error (error,
+					             NM_SETTING_VLAN_ERROR,
+					             NM_SETTING_VLAN_ERROR_INVALID_PARENT,
+					             NM_SETTING_CONNECTION_MASTER);
+					return FALSE;
+				}
+			}
+		} else if (!nm_utils_iface_valid_name (priv->parent)) {
+			/* parent must be either a UUID or an interface name */
+			g_set_error (error,
+			             NM_SETTING_VLAN_ERROR,
+			             NM_SETTING_VLAN_ERROR_INVALID_PROPERTY,
+			             NM_SETTING_VLAN_PARENT);
+			return FALSE;
+		} 
+	} else {
+		/* If parent is NULL, the parent must be specified via
+		 * NMSettingWired:mac-address.
+		 */
+		if (!s_wired || !nm_setting_wired_get_mac_address (s_wired)) {
+			g_set_error (error,
+			             NM_SETTING_VLAN_ERROR,
+			             NM_SETTING_VLAN_ERROR_MISSING_PROPERTY,
+			             NM_SETTING_VLAN_PARENT);
+			return FALSE;
+		}
 	}
 
 	if (priv->flags & ~(NM_VLAN_FLAG_REORDER_HEADERS |
--- NetworkManager-0.8.1/libnm-util/nm-utils.h.vlan-fixes	2012-10-04 14:50:11.873223016 -0400
+++ NetworkManager-0.8.1/libnm-util/nm-utils.h	2012-10-04 14:50:33.952224779 -0400
@@ -233,6 +233,10 @@
 GByteArray *nm_utils_hwaddr_atoba (const char *asc, int type);
 guint8     *nm_utils_hwaddr_aton  (const char *asc, int type, gpointer buffer);
 
+gboolean nm_utils_is_uuid (const char *str);
+
+gboolean    nm_utils_iface_valid_name(const char *name);
+
 G_END_DECLS
 
 #endif /* NM_UTILS_H */
--- NetworkManager-0.8.1/libnm-util/nm-setting-vlan.h.vlan-fixes	2012-10-04 14:50:11.889223019 -0400
+++ NetworkManager-0.8.1/libnm-util/nm-setting-vlan.h	2012-10-04 14:53:20.582238240 -0400
@@ -43,12 +43,15 @@
  * @NM_SETTING_VLAN_ERROR_UNKNOWN: unknown or unclassified error
  * @NM_SETTING_VLAN_ERROR_INVALID_PROPERTY: the property was invalid
  * @NM_SETTING_VLAN_ERROR_MISSING_PROPERTY: the property was missing and is
- * required
+ *   required
+ * @NM_SETTING_VLAN_ERROR_INVALID_PARENT: the VLAN parent was specified
+ *   inconsistently
  */
 typedef enum {
 	NM_SETTING_VLAN_ERROR_UNKNOWN = 0,
 	NM_SETTING_VLAN_ERROR_INVALID_PROPERTY,
-	NM_SETTING_VLAN_ERROR_MISSING_PROPERTY
+	NM_SETTING_VLAN_ERROR_MISSING_PROPERTY,
+	NM_SETTING_VLAN_ERROR_INVALID_PARENT
 } NMSettingVlanError;
 
 #define NM_TYPE_SETTING_VLAN_ERROR (nm_setting_vlan_error_get_type ()) 
--- NetworkManager-0.8.1/src/NetworkManagerUtils.c.vlan-fixes	2012-10-04 14:50:11.876223018 -0400
+++ NetworkManager-0.8.1/src/NetworkManagerUtils.c	2012-10-04 14:50:33.950224779 -0400
@@ -719,23 +719,6 @@
 	return success;
 }
 
-gboolean
-nm_utils_is_uuid (const char *str)
-{
-	const char *p = str;
-	int num_dashes = 0;
-
-	while (*p) {
-		if (*p == '-')
-			num_dashes++;
-		else if (!isxdigit (*p))
-			return FALSE;
-		p++;
-	}
-
-	return (num_dashes == 4) && (p - str == 36);
-}
-
 char *
 nm_utils_new_vlan_name (const char *parent_iface, guint32 vlan_id)
 {
--- NetworkManager-0.8.1/src/nm-device.c.vlan-fixes	2012-10-04 14:50:11.891223019 -0400
+++ NetworkManager-0.8.1/src/nm-device.c	2012-10-04 14:50:33.959224779 -0400
@@ -38,6 +38,7 @@
 #include "nm-device-interface.h"
 #include "nm-device.h"
 #include "nm-device-private.h"
+#include "nm-device-ethernet.h"
 #include "NetworkManagerUtils.h"
 #include "nm-system.h"
 #include "nm-dhcp-manager.h"
@@ -4259,3 +4260,9 @@
 	priv->autoconnect_inhibit = FALSE;
 }
 
+gboolean
+nm_device_supports_vlans (NMDevice *device)
+{
+	/* At the moment, NM's VLAN code assumes all VLANs are over ethernet. */
+	return NM_IS_DEVICE_ETHERNET (device);
+}
--- NetworkManager-0.8.1/src/nm-manager.c.vlan-fixes	2012-10-04 15:05:06.968294448 -0400
+++ NetworkManager-0.8.1/src/nm-manager.c	2012-10-04 15:32:24.502425125 -0400
@@ -66,6 +66,7 @@
 #include "nm-settings-system-interface.h"
 #include "nm-manager-auth.h"
 #include "NetworkManagerUtils.h"
+#include "nm-utils.h"
 
 #define NM_AUTOIP_DBUS_SERVICE "org.freedesktop.nm_avahi_autoipd"
 #define NM_AUTOIP_DBUS_IFACE   "org.freedesktop.nm_avahi_autoipd"
@@ -1575,11 +1576,20 @@
 
 		parent = find_vlan_parent (self, connection, TRUE);
 		if (parent) {
+			ifname = nm_connection_get_virtual_iface_name (connection);
+
+			if (!nm_device_supports_vlans (parent)) {
+				nm_log_warn (LOGD_DEVICE, "(%s): No support for VLANs on interface %s of type %s",
+				             ifname ? ifname : nm_connection_get_id (connection),
+				             nm_device_get_ip_iface (parent),
+				             nm_device_get_type_desc (parent));
+				return NULL;
+			}
+
 			/* If the connection doesn't specify the interface name for the VLAN
 			 * device, we create one for it using the VLAN ID and the parent
 			 * interface's name.
 			 */
-			ifname = nm_connection_get_virtual_iface_name (connection);
 			if (ifname)
 				vname = g_strdup (ifname);
 			else {
--- NetworkManager-0.8.1/src/NetworkManagerUtils.h.vlan-fixes	2012-10-04 14:50:11.880223017 -0400
+++ NetworkManager-0.8.1/src/NetworkManagerUtils.h	2012-10-04 14:50:33.950224779 -0400
@@ -78,8 +78,6 @@
                                           const char *iface,
                                           guint32 *out_value);
 
-gboolean nm_utils_is_uuid (const char *str);
-
 char *nm_utils_new_vlan_name (const char *parent_iface, guint32 vlan_id);
 
 #endif /* NETWORK_MANAGER_UTILS_H */
--- NetworkManager-0.8.1/src/nm-device.h.vlan-fixes	2012-10-04 14:50:11.894223017 -0400
+++ NetworkManager-0.8.1/src/nm-device.h	2012-10-04 14:50:33.960224779 -0400
@@ -210,6 +210,8 @@
                                    guint other_hwaddr_len,
                                    gboolean fail_if_no_hwaddr);
 
+gboolean nm_device_supports_vlans (NMDevice *device);
+
 G_END_DECLS
 
 #endif	/* NM_DEVICE_H */
--- NetworkManager-0.8.1/system-settings/plugins/ifcfg-rh/writer.c.vlan-fixes	2012-10-04 14:50:11.901223019 -0400
+++ NetworkManager-0.8.1/system-settings/plugins/ifcfg-rh/writer.c	2012-10-04 14:50:33.967224780 -0400
@@ -1009,7 +1009,8 @@
 	return TRUE;
 }
 
-static GString *vlan_priority_maplist_to_stringlist (NMSettingVlan *s_vlan, NMVlanPriorityMap map)
+static GString *
+vlan_priority_maplist_to_stringlist (NMSettingVlan *s_vlan, NMVlanPriorityMap map)
 {
 	GSList *strlist = NULL, *iter;
 	GString *value = NULL;
@@ -1031,10 +1032,11 @@
 }
 
 static gboolean
-write_vlan_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+write_vlan_setting (NMConnection *connection, shvarFile *ifcfg, gboolean *wired, GError **error)
 {
 	NMSettingVlan *s_vlan;
 	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
 	char *tmp;
 	guint32 vlan_flags = 0;
 	GString *text = NULL;
@@ -1086,6 +1088,39 @@
 	if (text)
 		g_string_free (text, TRUE);
 
+	svSetValue (ifcfg, "HWADDR", NULL, FALSE);
+	svSetValue (ifcfg, "MACADDR", NULL, FALSE);
+	svSetValue (ifcfg, "MTU", NULL, FALSE);
+
+	s_wired = nm_connection_get_setting_wired (connection);
+	if (s_wired) {
+		const GByteArray *device_mac, *cloned_mac;
+		guint32 mtu;
+
+		*wired = TRUE;
+
+		device_mac = nm_setting_wired_get_mac_address (s_wired);
+		if (device_mac) {
+			tmp = nm_utils_hwaddr_ntoa (device_mac->data, ARPHRD_ETHER);
+			svSetValue (ifcfg, "HWADDR", tmp, FALSE);
+			g_free (tmp);
+		}
+
+		cloned_mac = nm_setting_wired_get_cloned_mac_address (s_wired);
+		if (cloned_mac) {
+			tmp = nm_utils_hwaddr_ntoa (cloned_mac->data, ARPHRD_ETHER);
+			svSetValue (ifcfg, "MACADDR", tmp, FALSE);
+			g_free (tmp);
+		}
+
+		mtu = nm_setting_wired_get_mtu (s_wired);
+		if (mtu) {
+			tmp = g_strdup_printf ("%u", mtu);
+			svSetValue (ifcfg, "MTU", tmp, FALSE);
+			g_free (tmp);
+		}
+	}
+
 	return TRUE;
 }
 
@@ -1791,7 +1826,7 @@
 			goto out;
 		wired = TRUE;
 	} else if (!strcmp (type, NM_SETTING_VLAN_SETTING_NAME)) {
-		if (!write_vlan_setting (connection, ifcfg, error))
+		if (!write_vlan_setting (connection, ifcfg, &wired, error))
 			goto out;
 	} else if (!strcmp (type, NM_SETTING_WIRELESS_SETTING_NAME)) {
 		if (!write_wireless_setting (connection, ifcfg, &no_8021x, error))
