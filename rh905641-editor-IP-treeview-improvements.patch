From 4f2f3313523ef3261bdba4bbf4ebace5fcc501be Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ji=C5=99=C3=AD=20Klime=C5=A1?= <jklimes@redhat.com>
Date: Fri, 29 Apr 2011 06:20:55 -0400
Subject: [PATCH 01/11] editor: improve usability for entering manual IP
 addresses and routes (rh #698199) (bgo #607678)
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

GtkTreeView used for editing static IP addresses and routes didn't behave and
was not user-friendly. Specifically, it didn't change cell on Tab key, but
users expected that. Moreover, things went much worse with GTK3 that changes
behaviour of GtkTreeView. Pressing Tab key left the cell but *didn't* save the
value. Neither did mouse click. Thus the only way to store values was to
confirm them by pressing Enter.
Despite differences in GtkTreeView behaviour of GTK2 and GTK3, this commit
manages to implement expected/desired behaviour for both versions. Summary:
- Tab key can be used to sssssss through cells (as well as Up/Down arrows and Enter)
- mouse click can be used to switch between cells
- Esc can be used to leave cell (as well as clicking another part of treeview
  or another widget)
- the new edited value is stored on all ways of leaving the cell

Signed-off-by: Jiří Klimeš <jklimes@redhat.com>

(based on upstream commit 57ebc568daa3a4ee3cd7bbb85fddc69ffee8d424)

Signed-off-by: Jiří Klimeš <jklimes@redhat.com>
---
 .../src/connection-editor/ip4-routes-dialog.c      | 160 ++++++++++++++++++++-
 .../src/connection-editor/ip6-routes-dialog.c      | 160 ++++++++++++++++++++-
 .../src/connection-editor/page-ip4.c               | 100 ++++++++++++-
 .../src/connection-editor/page-ip6.c               | 100 ++++++++++++-
 4 files changed, 514 insertions(+), 6 deletions(-)

diff --git a/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c b/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
index 64c9d5f..539b7fa 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
@@ -29,6 +29,7 @@
 #include <string.h>
 
 #include <glib/gi18n.h>
+#include <gdk/gdkkeysyms.h>
 
 #include <nm-utils.h>
 
@@ -40,6 +41,12 @@
 #define COL_METRIC  3
 #define COL_LAST COL_METRIC
 
+/* Variables to temporarily save last edited cell value
+ * from routes treeview (cancelling issues) */
+static char *last_edited = NULL; /* cell text */
+static char *last_path = NULL;   /* row in treeview */
+static int last_column = -1;     /* column in treeview */
+
 static gboolean
 get_one_int (GtkTreeModel *model,
              GtkTreeIter *iter,
@@ -271,6 +278,33 @@ list_selection_changed (GtkTreeSelection *selection, gpointer user_data)
 }
 
 static void
+cell_editing_canceled (GtkCellRenderer *renderer, gpointer user_data)
+{
+	GtkBuilder *builder = GTK_BUILDER (user_data);
+	GtkTreeModel *model = NULL;
+	GtkTreeSelection *selection;
+	GtkTreeIter iter;
+	guint32 column;
+
+	if (last_edited) {
+		selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (gtk_builder_get_object (builder, "ip4_routes")));
+		if (gtk_tree_selection_get_selected (selection, &model, &iter)) {
+			column = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (renderer), "column"));
+			gtk_list_store_set (GTK_LIST_STORE (model), &iter, column, last_edited, -1);
+		}
+
+		g_free (last_edited);
+		last_edited = NULL;
+	}
+
+	g_free (last_path);
+	last_path = NULL;
+	last_column = -1;
+
+	validate (GTK_WIDGET (gtk_builder_get_object (builder, "ip4_routes_dialog")));
+}
+
+static void
 cell_edited (GtkCellRendererText *cell,
              const gchar *path_string,
              const gchar *new_text,
@@ -285,6 +319,13 @@ cell_edited (GtkCellRendererText *cell,
 	GtkTreeViewColumn *next_col;
 	GtkCellRenderer *next_cell;
 
+	/* Free auxiliary stuff */
+	g_free (last_edited);
+	last_edited = NULL;
+	g_free (last_path);
+	last_path = NULL;
+	last_column = -1;
+
 	widget = GTK_WIDGET (gtk_builder_get_object (builder, "ip4_routes"));
 	store = GTK_LIST_STORE (gtk_tree_view_get_model (GTK_TREE_VIEW (widget)));
 	path = gtk_tree_path_new_from_string (path_string);
@@ -300,7 +341,6 @@ cell_edited (GtkCellRendererText *cell,
 	next_cell = g_slist_nth_data (g_object_get_data (G_OBJECT (dialog), "renderers"), column);
 
 	gtk_tree_view_set_cursor_on_cell (GTK_TREE_VIEW (widget), path, next_col, next_cell, TRUE);
-	gtk_widget_grab_focus (widget);
 
 	gtk_tree_path_free (path);
 
@@ -329,6 +369,8 @@ ip_address_filter_cb (GtkEntry *   entry,
 		                                 G_CALLBACK (ip_address_filter_cb),
 		                                 user_data);
 		gtk_editable_insert_text (editable, result, count, position);
+		g_free (last_edited);
+		last_edited = g_strdup (gtk_editable_get_chars (editable, 0, -1));
 		g_signal_handlers_unblock_by_func (G_OBJECT (editable),
 		                                   G_CALLBACK (ip_address_filter_cb),
 		                                   user_data);
@@ -345,6 +387,41 @@ ip_address_filter_cb (GtkEntry *   entry,
 }
 
 static void
+delete_text_cb (GtkEditable *editable,
+                gint start_pos,
+                gint end_pos,
+                gpointer user_data)
+{
+	GtkWidget *ok_button = user_data;
+
+	/* Keep last_edited up-to-date */
+	g_free (last_edited);
+	last_edited = g_strdup (gtk_editable_get_chars (editable, 0, -1));
+
+	/* Desensitize the OK button during input to simplify input validation.
+	 * All routes will be validated on focus-out, which will then re-enable
+	 * the OK button if the routes are valid.
+	 */
+	gtk_widget_set_sensitive (ok_button, FALSE);
+}
+
+static gboolean
+key_pressed_cb (GtkWidget *widget,
+                GdkEvent *event,
+                gpointer user_data)
+{
+#if !GDK_KEY_Tab
+	#define GDK_KEY_Tab GDK_Tab
+#endif
+
+	/* Tab should behave the same way as Enter (finish editing) */
+	if (event->type == GDK_KEY_PRESS && event->key.keyval == GDK_KEY_Tab)
+		gtk_cell_editable_editing_done (GTK_CELL_EDITABLE (widget));
+
+	return FALSE;
+}
+
+static void
 ip4_cell_editing_started (GtkCellRenderer *cell,
                           GtkCellEditable *editable,
                           const gchar     *path,
@@ -355,10 +432,26 @@ ip4_cell_editing_started (GtkCellRenderer *cell,
 		return;
 	}
 
+	/* Initialize last_path and last_column, last_edited is initialized when the cell is edited */
+	g_free (last_edited);
+	last_edited = NULL;
+	g_free (last_path);
+	last_path = g_strdup (path);
+	last_column = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (cell), "column"));
+
 	/* Set up the entry filter */
 	g_signal_connect (G_OBJECT (editable), "insert-text",
 	                  (GCallback) ip_address_filter_cb,
 	                  user_data);
+
+	g_signal_connect_after (G_OBJECT (editable), "delete-text",
+	                        (GCallback) delete_text_cb,
+	                        user_data);
+
+	/* Set up key pressed handler - need to handle Tab key */
+	g_signal_connect (G_OBJECT (editable), "key-press-event",
+	                  (GCallback) key_pressed_cb,
+	                  user_data);
 }
 
 static void
@@ -383,6 +476,8 @@ uint_filter_cb (GtkEntry *   entry,
 		                                 G_CALLBACK (uint_filter_cb),
 		                                 user_data);
 		gtk_editable_insert_text (editable, result, count, position);
+		g_free (last_edited);
+		last_edited = g_strdup (gtk_editable_get_chars (editable, 0, -1));
 		g_signal_handlers_unblock_by_func (G_OBJECT (editable),
 		                                   G_CALLBACK (uint_filter_cb),
 		                                   user_data);
@@ -409,10 +504,61 @@ uint_cell_editing_started (GtkCellRenderer *cell,
 		return;
 	}
 
+	/* Initialize last_path and last_column, last_edited is initialized when the cell is edited */
+	g_free (last_edited);
+	last_edited = NULL;
+	g_free (last_path);
+	last_path = g_strdup (path);
+	last_column = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (cell), "column"));
+
 	/* Set up the entry filter */
 	g_signal_connect (G_OBJECT (editable), "insert-text",
 	                  (GCallback) uint_filter_cb,
 	                  user_data);
+
+	g_signal_connect_after (G_OBJECT (editable), "delete-text",
+	                        (GCallback) delete_text_cb,
+	                        user_data);
+
+	/* Set up key pressed handler - need to handle Tab key */
+	g_signal_connect (G_OBJECT (editable), "key-press-event",
+	                  (GCallback) key_pressed_cb,
+	                  user_data);
+}
+
+static gboolean
+tree_view_button_pressed_cb (GtkWidget *widget,
+                             GdkEvent *event,
+                             gpointer user_data)
+{
+	GtkBuilder *builder = GTK_BUILDER (user_data);
+
+	/* last_edited can be set e.g. when we get here by clicking an cell while
+	 * editing another cell. GTK3 issue neither editing-canceled nor editing-done
+	 * for cell renderer. Thus the previous cell value isn't saved. Store it now. */
+	if (last_edited && last_path) {
+		GtkTreeIter iter;
+		GtkListStore *store = GTK_LIST_STORE (gtk_tree_view_get_model (GTK_TREE_VIEW (widget)));
+		GtkTreePath *last_treepath = gtk_tree_path_new_from_string (last_path);
+
+		gtk_tree_model_get_iter (GTK_TREE_MODEL (store), &iter, last_treepath);
+		gtk_list_store_set (store, &iter, last_column, last_edited, -1);
+		gtk_tree_path_free (last_treepath);
+
+		g_free (last_edited);
+		last_edited = NULL;
+		g_free (last_path);
+		last_path = NULL;
+		last_column = -1;
+	}
+
+	/* Ignore double clicks events. (They are issued after the single clicks, see GdkEventButton) */
+	if (event->type == GDK_2BUTTON_PRESS)
+		return TRUE;
+
+	gtk_widget_grab_focus (GTK_WIDGET (widget));
+	validate (GTK_WIDGET (gtk_builder_get_object (builder, "ip4_routes_dialog")));
+	return FALSE;
 }
 
 GtkWidget *
@@ -430,6 +576,13 @@ ip4_routes_dialog_new (NMSettingIP4Config *s_ip4, gboolean automatic)
 	GSList *renderers = NULL;
 	GError* error = NULL;
 
+	/* Initialize temporary storage vars */
+	g_free (last_edited);
+	last_edited = NULL;
+	last_path = NULL;
+	g_free (last_path);
+	last_column = -1;
+
 	builder = gtk_builder_new ();
 
 	if (!gtk_builder_add_from_file (builder, UIDIR "/ce-page-ip4.ui", &error))
@@ -498,6 +651,7 @@ ip4_routes_dialog_new (NMSettingIP4Config *s_ip4, gboolean automatic)
 	g_signal_connect (renderer, "edited", G_CALLBACK (cell_edited), builder);
 	g_object_set_data (G_OBJECT (renderer), "column", GUINT_TO_POINTER (COL_ADDRESS));
 	g_signal_connect (renderer, "editing-started", G_CALLBACK (ip4_cell_editing_started), ok_button);
+	g_signal_connect (renderer, "editing-canceled", G_CALLBACK (cell_editing_canceled), builder);
 	renderers = g_slist_append (renderers, renderer);
 
 	offset = gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW (widget),
@@ -514,6 +668,7 @@ ip4_routes_dialog_new (NMSettingIP4Config *s_ip4, gboolean automatic)
 	g_signal_connect (renderer, "edited", G_CALLBACK (cell_edited), builder);
 	g_object_set_data (G_OBJECT (renderer), "column", GUINT_TO_POINTER (COL_PREFIX));
 	g_signal_connect (renderer, "editing-started", G_CALLBACK (ip4_cell_editing_started), ok_button);
+	g_signal_connect (renderer, "editing-canceled", G_CALLBACK (cell_editing_canceled), builder);
 	renderers = g_slist_append (renderers, renderer);
 
 	offset = gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW (widget),
@@ -530,6 +685,7 @@ ip4_routes_dialog_new (NMSettingIP4Config *s_ip4, gboolean automatic)
 	g_signal_connect (renderer, "edited", G_CALLBACK (cell_edited), builder);
 	g_object_set_data (G_OBJECT (renderer), "column", GUINT_TO_POINTER (COL_NEXT_HOP));
 	g_signal_connect (renderer, "editing-started", G_CALLBACK (ip4_cell_editing_started), ok_button);
+	g_signal_connect (renderer, "editing-canceled", G_CALLBACK (cell_editing_canceled), builder);
 	renderers = g_slist_append (renderers, renderer);
 
 	offset = gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW (widget),
@@ -546,6 +702,7 @@ ip4_routes_dialog_new (NMSettingIP4Config *s_ip4, gboolean automatic)
 	g_signal_connect (renderer, "edited", G_CALLBACK (cell_edited), builder);
 	g_object_set_data (G_OBJECT (renderer), "column", GUINT_TO_POINTER (COL_METRIC));
 	g_signal_connect (renderer, "editing-started", G_CALLBACK (uint_cell_editing_started), ok_button);
+	g_signal_connect (renderer, "editing-canceled", G_CALLBACK (cell_editing_canceled), builder);
 	renderers = g_slist_append (renderers, renderer);
 
 	offset = gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW (widget),
@@ -562,6 +719,7 @@ ip4_routes_dialog_new (NMSettingIP4Config *s_ip4, gboolean automatic)
 	g_signal_connect (selection, "changed",
 	                  G_CALLBACK (list_selection_changed),
 	                  GTK_WIDGET (gtk_builder_get_object (builder, "ip4_route_delete_button")));
+	g_signal_connect (widget, "button-press-event", G_CALLBACK (tree_view_button_pressed_cb), builder);
 
 	widget = GTK_WIDGET (gtk_builder_get_object (builder, "ip4_route_add_button"));
 	gtk_widget_set_sensitive (widget, TRUE);
diff --git a/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c b/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
index 3798f69..ee1c607 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
@@ -29,6 +29,7 @@
 #include <string.h>
 
 #include <glib/gi18n.h>
+#include <gdk/gdkkeysyms.h>
 
 #include <nm-utils.h>
 
@@ -40,6 +41,12 @@
 #define COL_METRIC  3
 #define COL_LAST COL_METRIC
 
+/* Variables to temporarily save last edited cell value
+ * from routes treeview (cancelling issues) */
+static char *last_edited = NULL; /* cell text */
+static char *last_path = NULL;   /* row in treeview */
+static int last_column = -1;     /* column in treeview */
+
 static gboolean
 get_one_int (GtkTreeModel *model,
              GtkTreeIter *iter,
@@ -228,6 +235,33 @@ list_selection_changed (GtkTreeSelection *selection, gpointer user_data)
 }
 
 static void
+cell_editing_canceled (GtkCellRenderer *renderer, gpointer user_data)
+{
+	GtkBuilder *builder = GTK_BUILDER (user_data);
+	GtkTreeModel *model = NULL;
+	GtkTreeSelection *selection;
+	GtkTreeIter iter;
+	guint32 column;
+
+	if (last_edited) {
+		selection = gtk_tree_view_get_selection (GTK_TREE_VIEW (gtk_builder_get_object (builder, "ip6_routes")));
+		if (gtk_tree_selection_get_selected (selection, &model, &iter)) {
+			column = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (renderer), "column"));
+			gtk_list_store_set (GTK_LIST_STORE (model), &iter, column, last_edited, -1);
+		}
+
+		g_free (last_edited);
+		last_edited = NULL;
+	}
+
+	g_free (last_path);
+	last_path = NULL;
+	last_column = -1;
+
+	validate (GTK_WIDGET (gtk_builder_get_object (builder, "ip6_routes_dialog")));
+}
+
+static void
 cell_edited (GtkCellRendererText *cell,
              const gchar *path_string,
              const gchar *new_text,
@@ -242,6 +276,13 @@ cell_edited (GtkCellRendererText *cell,
 	GtkTreeViewColumn *next_col;
 	GtkCellRenderer *next_cell;
 
+	/* Free auxiliary stuff */
+	g_free (last_edited);
+	last_edited = NULL;
+	g_free (last_path);
+	last_path = NULL;
+	last_column = -1;
+
 	widget = GTK_WIDGET (gtk_builder_get_object (builder, "ip6_routes"));
 	store = GTK_LIST_STORE (gtk_tree_view_get_model (GTK_TREE_VIEW (widget)));
 	path = gtk_tree_path_new_from_string (path_string);
@@ -257,7 +298,6 @@ cell_edited (GtkCellRendererText *cell,
 	next_cell = g_slist_nth_data (g_object_get_data (G_OBJECT (dialog), "renderers"), column);
 
 	gtk_tree_view_set_cursor_on_cell (GTK_TREE_VIEW (widget), path, next_col, next_cell, TRUE);
-	gtk_widget_grab_focus (widget);
 
 	gtk_tree_path_free (path);
 
@@ -286,6 +326,8 @@ ip_address_filter_cb (GtkEntry *   entry,
 		                                 G_CALLBACK (ip_address_filter_cb),
 		                                 user_data);
 		gtk_editable_insert_text (editable, result, count, position);
+		g_free (last_edited);
+		last_edited = g_strdup (gtk_editable_get_chars (editable, 0, -1));
 		g_signal_handlers_unblock_by_func (G_OBJECT (editable),
 		                                   G_CALLBACK (ip_address_filter_cb),
 		                                   user_data);
@@ -302,6 +344,41 @@ ip_address_filter_cb (GtkEntry *   entry,
 }
 
 static void
+delete_text_cb (GtkEditable *editable,
+                gint start_pos,
+                gint end_pos,
+                gpointer user_data)
+{
+	GtkWidget *ok_button = user_data;
+
+	/* Keep last_edited up-to-date */
+	g_free (last_edited);
+	last_edited = g_strdup (gtk_editable_get_chars (editable, 0, -1));
+
+	/* Desensitize the OK button during input to simplify input validation.
+	 * All routes will be validated on focus-out, which will then re-enable
+	 * the OK button if the routes are valid.
+	 */
+	gtk_widget_set_sensitive (ok_button, FALSE);
+}
+
+static gboolean
+key_pressed_cb (GtkWidget *widget,
+                GdkEvent *event,
+                gpointer user_data)
+{
+#if !GDK_KEY_Tab
+	#define GDK_KEY_Tab GDK_Tab
+#endif
+
+	/* Tab should behave the same way as Enter (finish editing) */
+	if (event->type == GDK_KEY_PRESS && event->key.keyval == GDK_KEY_Tab)
+		gtk_cell_editable_editing_done (GTK_CELL_EDITABLE (widget));
+
+	return FALSE;
+}
+
+static void
 ip6_cell_editing_started (GtkCellRenderer *cell,
                           GtkCellEditable *editable,
                           const gchar     *path,
@@ -312,10 +389,26 @@ ip6_cell_editing_started (GtkCellRenderer *cell,
 		return;
 	}
 
+	/* Initialize last_path and last_column, last_edited is initialized when the cell is edited */
+	g_free (last_edited);
+	last_edited = NULL;
+	g_free (last_path);
+	last_path = g_strdup (path);
+	last_column = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (cell), "column"));
+
 	/* Set up the entry filter */
 	g_signal_connect (G_OBJECT (editable), "insert-text",
 	                  (GCallback) ip_address_filter_cb,
 	                  user_data);
+
+	g_signal_connect_after (G_OBJECT (editable), "delete-text",
+	                        (GCallback) delete_text_cb,
+	                        user_data);
+
+	/* Set up key pressed handler - need to handle Tab key */
+	g_signal_connect (G_OBJECT (editable), "key-press-event",
+	                  (GCallback) key_pressed_cb,
+	                  user_data);
 }
 
 static void
@@ -340,6 +433,8 @@ uint_filter_cb (GtkEntry *   entry,
 		                                 G_CALLBACK (uint_filter_cb),
 		                                 user_data);
 		gtk_editable_insert_text (editable, result, count, position);
+		g_free (last_edited);
+		last_edited = g_strdup (gtk_editable_get_chars (editable, 0, -1));
 		g_signal_handlers_unblock_by_func (G_OBJECT (editable),
 		                                   G_CALLBACK (uint_filter_cb),
 		                                   user_data);
@@ -366,10 +461,61 @@ uint_cell_editing_started (GtkCellRenderer *cell,
 		return;
 	}
 
+	/* Initialize last_path and last_column, last_edited is initialized when the cell is edited */
+	g_free (last_edited);
+	last_edited = NULL;
+	g_free (last_path);
+	last_path = g_strdup (path);
+	last_column = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (cell), "column"));
+
 	/* Set up the entry filter */
 	g_signal_connect (G_OBJECT (editable), "insert-text",
 	                  (GCallback) uint_filter_cb,
 	                  user_data);
+
+	g_signal_connect_after (G_OBJECT (editable), "delete-text",
+	                        (GCallback) delete_text_cb,
+	                        user_data);
+
+	/* Set up key pressed handler - need to handle Tab key */
+	g_signal_connect (G_OBJECT (editable), "key-press-event",
+	                  (GCallback) key_pressed_cb,
+	                  user_data);
+}
+
+static gboolean
+tree_view_button_pressed_cb (GtkWidget *widget,
+                             GdkEvent *event,
+                             gpointer user_data)
+{
+	GtkBuilder *builder = GTK_BUILDER (user_data);
+
+	/* last_edited can be set e.g. when we get here by clicking an cell while
+	 * editing another cell. GTK3 issue neither editing-canceled nor editing-done
+	 * for cell renderer. Thus the previous cell value isn't saved. Store it now. */
+	if (last_edited && last_path) {
+		GtkTreeIter iter;
+		GtkListStore *store = GTK_LIST_STORE (gtk_tree_view_get_model (GTK_TREE_VIEW (widget)));
+		GtkTreePath *last_treepath = gtk_tree_path_new_from_string (last_path);
+
+		gtk_tree_model_get_iter (GTK_TREE_MODEL (store), &iter, last_treepath);
+		gtk_list_store_set (store, &iter, last_column, last_edited, -1);
+		gtk_tree_path_free (last_treepath);
+
+		g_free (last_edited);
+		last_edited = NULL;
+		g_free (last_path);
+		last_path = NULL;
+		last_column = -1;
+	}
+
+	/* Ignore double clicks events. (They are issued after the single clicks, see GdkEventButton) */
+	if (event->type == GDK_2BUTTON_PRESS)
+		return TRUE;
+
+	gtk_widget_grab_focus (GTK_WIDGET (widget));
+	validate (GTK_WIDGET (gtk_builder_get_object (builder, "ip6_routes_dialog")));
+	return FALSE;
 }
 
 GtkWidget *
@@ -387,6 +533,13 @@ ip6_routes_dialog_new (NMSettingIP6Config *s_ip6, gboolean automatic)
 	GSList *renderers = NULL;
 	GError* error = NULL;
 
+	/* Initialize temporary storage vars */
+	g_free (last_edited);
+	last_edited = NULL;
+	last_path = NULL;
+	g_free (last_path);
+	last_column = -1;
+
 	builder = gtk_builder_new ();
 
 	if (!gtk_builder_add_from_file (builder, UIDIR "/ce-page-ip6.ui", &error))
@@ -456,6 +609,7 @@ ip6_routes_dialog_new (NMSettingIP6Config *s_ip6, gboolean automatic)
 	g_signal_connect (renderer, "edited", G_CALLBACK (cell_edited), builder);
 	g_object_set_data (G_OBJECT (renderer), "column", GUINT_TO_POINTER (COL_ADDRESS));
 	g_signal_connect (renderer, "editing-started", G_CALLBACK (ip6_cell_editing_started), ok_button);
+	g_signal_connect (renderer, "editing-canceled", G_CALLBACK (cell_editing_canceled), builder);
 	renderers = g_slist_append (renderers, renderer);
 
 	offset = gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW (widget),
@@ -472,6 +626,7 @@ ip6_routes_dialog_new (NMSettingIP6Config *s_ip6, gboolean automatic)
 	g_signal_connect (renderer, "edited", G_CALLBACK (cell_edited), builder);
 	g_object_set_data (G_OBJECT (renderer), "column", GUINT_TO_POINTER (COL_PREFIX));
 	g_signal_connect (renderer, "editing-started", G_CALLBACK (uint_cell_editing_started), ok_button);
+	g_signal_connect (renderer, "editing-canceled", G_CALLBACK (cell_editing_canceled), builder);
 	renderers = g_slist_append (renderers, renderer);
 
 	offset = gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW (widget),
@@ -488,6 +643,7 @@ ip6_routes_dialog_new (NMSettingIP6Config *s_ip6, gboolean automatic)
 	g_signal_connect (renderer, "edited", G_CALLBACK (cell_edited), builder);
 	g_object_set_data (G_OBJECT (renderer), "column", GUINT_TO_POINTER (COL_NEXT_HOP));
 	g_signal_connect (renderer, "editing-started", G_CALLBACK (ip6_cell_editing_started), ok_button);
+	g_signal_connect (renderer, "editing-canceled", G_CALLBACK (cell_editing_canceled), builder);
 	renderers = g_slist_append (renderers, renderer);
 
 	offset = gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW (widget),
@@ -504,6 +660,7 @@ ip6_routes_dialog_new (NMSettingIP6Config *s_ip6, gboolean automatic)
 	g_signal_connect (renderer, "edited", G_CALLBACK (cell_edited), builder);
 	g_object_set_data (G_OBJECT (renderer), "column", GUINT_TO_POINTER (COL_METRIC));
 	g_signal_connect (renderer, "editing-started", G_CALLBACK (uint_cell_editing_started), ok_button);
+	g_signal_connect (renderer, "editing-canceled", G_CALLBACK (cell_editing_canceled), builder);
 	renderers = g_slist_append (renderers, renderer);
 
 	offset = gtk_tree_view_insert_column_with_attributes (GTK_TREE_VIEW (widget),
@@ -520,6 +677,7 @@ ip6_routes_dialog_new (NMSettingIP6Config *s_ip6, gboolean automatic)
 	g_signal_connect (selection, "changed",
 	                  G_CALLBACK (list_selection_changed),
 	                  GTK_WIDGET (gtk_builder_get_object (builder, "ip6_route_delete_button")));
+	g_signal_connect (widget, "button-press-event", G_CALLBACK (tree_view_button_pressed_cb), builder);
 
 	widget = GTK_WIDGET (gtk_builder_get_object (builder, "ip6_route_add_button"));
 	gtk_widget_set_sensitive (widget, TRUE);
diff --git a/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c b/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
index 3cb9f13..4aa5b58 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
@@ -26,6 +26,7 @@
 #include <arpa/inet.h>
 
 #include <gtk/gtk.h>
+#include <gdk/gdkkeysyms.h>
 #include <glib/gi18n.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
@@ -90,7 +91,12 @@ typedef struct {
 	gboolean window_added;
 
 	/* Cached tree view entry for editing-canceled */
-	char *last_edited;
+	/* Used also for saving old value when switching between cells via mouse
+	 * clicks - GTK3 produces neither editing-canceled nor editing-done for
+	 * that :( */
+	char *last_edited; /* cell text */
+	char *last_path;   /* row in treeview */
+	int last_column;   /* column in treeview */
 } CEPageIP4Private;
 
 #define METHOD_COL_NAME 0
@@ -536,6 +542,10 @@ cell_editing_canceled (GtkCellRenderer *renderer, gpointer user_data)
 
 		ce_page_changed (CE_PAGE (self));
 	}
+
+	g_free (priv->last_path);
+	priv->last_path = NULL;
+	priv->last_column = -1;
 }
 
 static void
@@ -552,8 +562,12 @@ cell_edited (GtkCellRendererText *cell,
 	guint32 column;
 	GtkTreeViewColumn *next_col;
 
+	/* Free auxiliary stuff */
 	g_free (priv->last_edited);
 	priv->last_edited = NULL;
+	g_free (priv->last_path);
+	priv->last_path = NULL;
+	priv->last_column = -1;
 
 	column = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (cell), "column"));
 	gtk_tree_model_get_iter (GTK_TREE_MODEL (store), &iter, path);
@@ -584,7 +598,6 @@ cell_edited (GtkCellRendererText *cell,
 	column = (column >= COL_LAST) ? 0 : column + 1;
 	next_col = gtk_tree_view_get_column (priv->addr_list, column);
 	gtk_tree_view_set_cursor_on_cell (priv->addr_list, path, next_col, priv->addr_cells[column], TRUE);
-	gtk_widget_grab_focus (GTK_WIDGET (priv->addr_list));
 
 	gtk_tree_path_free (path);
 	ce_page_changed (CE_PAGE (self));
@@ -625,6 +638,36 @@ ip_address_filter_cb (GtkEntry *   entry,
 }
 
 static void
+delete_text_cb (GtkEditable *editable,
+                    gint start_pos,
+                    gint end_pos,
+                    gpointer user_data)
+{
+	CEPageIP4 *self = CE_PAGE_IP4 (user_data);
+	CEPageIP4Private *priv = CE_PAGE_IP4_GET_PRIVATE (self);
+
+	/* Keep last_edited up-to-date */
+	g_free (priv->last_edited);
+	priv->last_edited = g_strdup (gtk_editable_get_chars (editable, 0, -1));
+}
+
+static gboolean
+key_pressed_cb (GtkWidget *widget,
+                GdkEvent *event,
+                gpointer user_data)
+{
+#if !GDK_KEY_Tab
+	#define GDK_KEY_Tab GDK_Tab
+#endif
+
+	/* Tab should behave the same way as Enter (finish editing) */
+	if (event->type == GDK_KEY_PRESS && event->key.keyval == GDK_KEY_Tab)
+		gtk_cell_editable_editing_done (GTK_CELL_EDITABLE (widget));
+
+	return FALSE;
+}
+
+static void
 cell_editing_started (GtkCellRenderer *cell,
                       GtkCellEditable *editable,
                       const gchar     *path,
@@ -638,13 +681,26 @@ cell_editing_started (GtkCellRenderer *cell,
 		return;
 	}
 
+	/* Initialize last_path and last_column, last_edited is initialized when the cell is edited */
 	g_free (priv->last_edited);
 	priv->last_edited = NULL;
+	g_free (priv->last_path);
+	priv->last_path = g_strdup (path);
+	priv->last_column = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (cell), "column"));
 
 	/* Set up the entry filter */
 	g_signal_connect (G_OBJECT (editable), "insert-text",
 	                  (GCallback) ip_address_filter_cb,
 	                  user_data);
+
+	g_signal_connect_after (G_OBJECT (editable), "delete-text",
+	                        (GCallback) delete_text_cb,
+	                        user_data);
+
+	/* Set up key pressed handler - need to handle Tab key */
+	g_signal_connect (G_OBJECT (editable), "key-press-event",
+	                  (GCallback) key_pressed_cb,
+	                  user_data);
 }
 
 static void
@@ -707,6 +763,41 @@ routes_button_clicked_cb (GtkWidget *button, gpointer user_data)
 	gtk_widget_show_all (dialog);
 }
 
+static gboolean
+tree_view_button_pressed_cb (GtkWidget *widget,
+                             GdkEvent *event,
+                             gpointer user_data)
+{
+	CEPageIP4 *self = CE_PAGE_IP4 (user_data);
+	CEPageIP4Private *priv = CE_PAGE_IP4_GET_PRIVATE (self);
+
+	/* last_edited can be set e.g. when we get here by clicking an cell while
+	 * editing another cell. GTK3 issue neither editing-canceled nor editing-done
+	 * for cell renderer. Thus the previous cell value isn't saved. Store it now. */
+	if (priv->last_edited && priv->last_path) {
+		GtkTreeIter iter;
+		GtkListStore *store = GTK_LIST_STORE (gtk_tree_view_get_model (priv->addr_list));
+		GtkTreePath *last_treepath = gtk_tree_path_new_from_string (priv->last_path);
+
+		gtk_tree_model_get_iter (GTK_TREE_MODEL (store), &iter, last_treepath);
+		gtk_list_store_set (store, &iter, priv->last_column, priv->last_edited, -1);
+		gtk_tree_path_free (last_treepath);
+
+		g_free (priv->last_edited);
+		priv->last_edited = NULL;
+		g_free (priv->last_path);
+		priv->last_path = NULL;
+		priv->last_column = -1;
+	}
+
+	/* Ignore double clicks events. (They are issued after the single clicks, see GdkEventButton) */
+	if (event->type == GDK_2BUTTON_PRESS)
+		return TRUE;
+
+	gtk_widget_grab_focus (GTK_WIDGET (priv->addr_list));
+	return FALSE;
+}
+
 static void
 finish_setup (CEPageIP4 *self, gpointer unused, GError *error, gpointer user_data)
 {
@@ -776,6 +867,8 @@ finish_setup (CEPageIP4 *self, gpointer unused, GError *error, gpointer user_dat
 	gtk_tree_view_column_set_expand (GTK_TREE_VIEW_COLUMN (column), TRUE);
 	gtk_tree_view_column_set_clickable (GTK_TREE_VIEW_COLUMN (column), TRUE);
 
+	g_signal_connect (priv->addr_list, "button-press-event", G_CALLBACK (tree_view_button_pressed_cb), self);
+
 	gtk_widget_set_sensitive (GTK_WIDGET (priv->addr_add), TRUE);
 	gtk_widget_set_sensitive (GTK_WIDGET (priv->addr_delete), FALSE);
 
@@ -1089,6 +1182,9 @@ validate (CEPage *page, NMConnection *connection, GError **error)
 static void
 ce_page_ip4_init (CEPageIP4 *self)
 {
+	CEPageIP4Private *priv = CE_PAGE_IP4_GET_PRIVATE (self);
+
+	priv->last_column = -1;
 }
 
 static void
diff --git a/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c b/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c
index 9ec7d83..2721373 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c
@@ -26,6 +26,7 @@
 #include <arpa/inet.h>
 
 #include <gtk/gtk.h>
+#include <gdk/gdkkeysyms.h>
 #include <glib/gi18n.h>
 #include <sys/socket.h>
 #include <netinet/in.h>
@@ -86,7 +87,12 @@ typedef struct {
 	gboolean window_added;
 
 	/* Cached tree view entry for editing-canceled */
-	char *last_edited;
+	/* Used also for saving old value when switching between cells via mouse
+	 * clicks - GTK3 produces neither editing-canceled nor editing-done for
+	 * that :( */
+	char *last_edited; /* cell text */
+	char *last_path;   /* row in treeview */
+	int last_column;   /* column in treeview */
 } CEPageIP6Private;
 
 #define METHOD_COL_NAME 0
@@ -529,6 +535,10 @@ cell_editing_canceled (GtkCellRenderer *renderer, gpointer user_data)
 
 		ce_page_changed (CE_PAGE (self));
 	}
+
+	g_free (priv->last_path);
+	priv->last_path = NULL;
+	priv->last_column = -1;
 }
 
 static void
@@ -545,8 +555,12 @@ cell_edited (GtkCellRendererText *cell,
 	guint32 column;
 	GtkTreeViewColumn *next_col;
 
+	/* Free auxiliary stuff */
 	g_free (priv->last_edited);
 	priv->last_edited = NULL;
+	g_free (priv->last_path);
+	priv->last_path = NULL;
+	priv->last_column = -1;
 
 	column = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (cell), "column"));
 	gtk_tree_model_get_iter (GTK_TREE_MODEL (store), &iter, path);
@@ -556,7 +570,6 @@ cell_edited (GtkCellRendererText *cell,
 	column = (column >= COL_LAST) ? 0 : column + 1;
 	next_col = gtk_tree_view_get_column (priv->addr_list, column);
 	gtk_tree_view_set_cursor_on_cell (priv->addr_list, path, next_col, priv->addr_cells[column], TRUE);
-	gtk_widget_grab_focus (GTK_WIDGET (priv->addr_list));
 
 	gtk_tree_path_free (path);
 	ce_page_changed (CE_PAGE (self));
@@ -605,6 +618,36 @@ ip_address_filter_cb (GtkEntry *   entry,
 }
 
 static void
+delete_text_cb (GtkEditable *editable,
+                    gint start_pos,
+                    gint end_pos,
+                    gpointer user_data)
+{
+	CEPageIP6 *self = CE_PAGE_IP6 (user_data);
+	CEPageIP6Private *priv = CE_PAGE_IP6_GET_PRIVATE (self);
+
+	/* Keep last_edited up-to-date */
+	g_free (priv->last_edited);
+	priv->last_edited = g_strdup (gtk_editable_get_chars (editable, 0, -1));
+}
+
+static gboolean
+key_pressed_cb (GtkWidget *widget,
+                GdkEvent *event,
+                gpointer user_data)
+{
+#if !GDK_KEY_Tab
+	#define GDK_KEY_Tab GDK_Tab
+#endif
+
+	/* Tab should behave the same way as Enter (finish editing) */
+	if (event->type == GDK_KEY_PRESS && event->key.keyval == GDK_KEY_Tab)
+		gtk_cell_editable_editing_done (GTK_CELL_EDITABLE (widget));
+
+	return FALSE;
+}
+
+static void
 cell_editing_started (GtkCellRenderer *cell,
                       GtkCellEditable *editable,
                       const gchar     *path,
@@ -619,8 +662,12 @@ cell_editing_started (GtkCellRenderer *cell,
 		return;
 	}
 
+	/* Initialize last_path and last_column, last_edited is initialized when the cell is edited */
 	g_free (priv->last_edited);
 	priv->last_edited = NULL;
+	g_free (priv->last_path);
+	priv->last_path = g_strdup (path);
+	priv->last_column = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (cell), "column"));
 
 	/* Need to pass column # to the editable's insert-text function */	
 	column = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (cell), "column"));
@@ -630,6 +677,15 @@ cell_editing_started (GtkCellRenderer *cell,
 	g_signal_connect (G_OBJECT (editable), "insert-text",
 	                  (GCallback) ip_address_filter_cb,
 	                  user_data);
+
+	g_signal_connect_after (G_OBJECT (editable), "delete-text",
+	                        (GCallback) delete_text_cb,
+	                        user_data);
+
+	/* Set up key pressed handler - need to handle Tab key */
+	g_signal_connect (G_OBJECT (editable), "key-press-event",
+	                  (GCallback) key_pressed_cb,
+	                  user_data);
 }
 
 static void
@@ -692,6 +748,41 @@ routes_button_clicked_cb (GtkWidget *button, gpointer user_data)
 	gtk_widget_show_all (dialog);
 }
 
+static gboolean
+tree_view_button_pressed_cb (GtkWidget *widget,
+                             GdkEvent *event,
+                             gpointer user_data)
+{
+	CEPageIP6 *self = CE_PAGE_IP6 (user_data);
+	CEPageIP6Private *priv = CE_PAGE_IP6_GET_PRIVATE (self);
+
+	/* last_edited can be set e.g. when we get here by clicking an cell while
+	 * editing another cell. GTK3 issue neither editing-canceled nor editing-done
+	 * for cell renderer. Thus the previous cell value isn't saved. Store it now. */
+	if (priv->last_edited && priv->last_path) {
+		GtkTreeIter iter;
+		GtkListStore *store = GTK_LIST_STORE (gtk_tree_view_get_model (priv->addr_list));
+		GtkTreePath *last_treepath = gtk_tree_path_new_from_string (priv->last_path);
+
+		gtk_tree_model_get_iter (GTK_TREE_MODEL (store), &iter, last_treepath);
+		gtk_list_store_set (store, &iter, priv->last_column, priv->last_edited, -1);
+		gtk_tree_path_free (last_treepath);
+
+		g_free (priv->last_edited);
+		priv->last_edited = NULL;
+		g_free (priv->last_path);
+		priv->last_path = NULL;
+		priv->last_column = -1;
+	}
+
+	/* Ignore double clicks events. (They are issued after the single clicks, see GdkEventButton) */
+	if (event->type == GDK_2BUTTON_PRESS)
+		return TRUE;
+
+	gtk_widget_grab_focus (GTK_WIDGET (priv->addr_list));
+	return FALSE;
+}
+
 static void
 finish_setup (CEPageIP6 *self, gpointer unused, GError *error, gpointer user_data)
 {
@@ -761,6 +852,8 @@ finish_setup (CEPageIP6 *self, gpointer unused, GError *error, gpointer user_dat
 	gtk_tree_view_column_set_expand (GTK_TREE_VIEW_COLUMN (column), TRUE);
 	gtk_tree_view_column_set_clickable (GTK_TREE_VIEW_COLUMN (column), TRUE);
 
+	g_signal_connect (priv->addr_list, "button-press-event", G_CALLBACK (tree_view_button_pressed_cb), self);
+
 	gtk_widget_set_sensitive (GTK_WIDGET (priv->addr_add), TRUE);
 	gtk_widget_set_sensitive (GTK_WIDGET (priv->addr_delete), FALSE);
 
@@ -1020,6 +1113,9 @@ validate (CEPage *page, NMConnection *connection, GError **error)
 static void
 ce_page_ip6_init (CEPageIP6 *self)
 {
+	CEPageIP6Private *priv = CE_PAGE_IP6_GET_PRIVATE (self);
+
+	priv->last_column = -1;
 }
 
 static void
-- 
2.1.0


From 94613bace53521ccd8459e9cfe4ab6829e8cb890 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ji=C5=99=C3=AD=20Klime=C5=A1?= <jklimes@redhat.com>
Date: Fri, 29 Apr 2011 09:01:26 -0400
Subject: [PATCH 02/11] editor: validate static IP/route values while editing
 cells in treeview
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

And make that visible through changing cell backround colour to green/red.

Signed-off-by: Jiří Klimeš <jklimes@redhat.com>

(based on upstream commit 4cad3c27ebd939ea3d7fd5782c19b921b50463a1)

Signed-off-by: Jiří Klimeš <jklimes@redhat.com>
---
 .../src/connection-editor/ip4-routes-dialog.c      | 71 ++++++++++++++++
 .../src/connection-editor/ip6-routes-dialog.c      | 61 ++++++++++++++
 .../src/connection-editor/page-ip4.c               | 98 +++++++++++++++-------
 .../src/connection-editor/page-ip6.c               | 47 +++++++++++
 4 files changed, 249 insertions(+), 28 deletions(-)

diff --git a/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c b/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
index 539b7fa..44cc679 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
@@ -406,6 +406,67 @@ delete_text_cb (GtkEditable *editable,
 }
 
 static gboolean
+cell_changed_cb (GtkEditable *editable,
+                 gpointer user_data)
+{
+	char *cell_text;
+	guint column;
+	GdkColor color;
+	gboolean value_valid = FALSE;
+
+	cell_text = gtk_editable_get_chars (editable, 0, -1);
+
+	/* The Netmask column can also contain prefix */
+	column = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (user_data), "column"));
+
+	if (column == COL_PREFIX) {
+		/* The COL_PREFIX can contain IP address or prefix */
+		guint32 tmp_prefix;
+
+		errno = 0;
+
+		/* Is it a prefix? */
+		if (!strchr (cell_text, '.')) {
+			tmp_prefix = strtol (cell_text, NULL, 10);
+			if (!errno && tmp_prefix >= 0 && tmp_prefix <= 32)
+				value_valid = TRUE;
+		} else {
+			struct in_addr tmp_addr;
+
+			/* Is it a netmask? */
+			if (inet_pton (AF_INET, cell_text, &tmp_addr) > 0)
+				value_valid = TRUE;
+		}
+	} else if (column == COL_METRIC) {
+		long int tmp_int;
+
+		errno = 0;
+		tmp_int = strtol (cell_text, NULL, 10);
+		if (errno || tmp_int < 0 || tmp_int > G_MAXUINT32)
+			value_valid = FALSE;
+		else
+			value_valid = TRUE;
+	} else {
+		struct in_addr tmp_addr;
+
+		if (inet_pton (AF_INET, cell_text, &tmp_addr) > 0)
+			value_valid = TRUE;
+	}
+
+	/* Change cell's background color while editing */
+	if (value_valid)
+		gdk_color_parse ("lightgreen", &color);
+	else
+		gdk_color_parse ("red", &color);
+
+	gtk_widget_modify_base (GTK_WIDGET (editable), GTK_STATE_NORMAL, &color); /* works for GTK2 */
+	gtk_widget_modify_bg (GTK_WIDGET (editable), GTK_STATE_NORMAL, &color);   /* works for GTK3 */
+
+	g_free (cell_text);
+	return FALSE;
+}
+
+static gboolean
 key_pressed_cb (GtkWidget *widget,
                 GdkEvent *event,
                 gpointer user_data)
@@ -448,6 +509,11 @@ ip4_cell_editing_started (GtkCellRenderer *cell,
 	                        (GCallback) delete_text_cb,
 	                        user_data);
 
+	/* Set up handler for value verifying and changing cell background */
+	g_signal_connect (G_OBJECT (editable), "changed",
+	                  (GCallback) cell_changed_cb,
+	                  cell);
+
 	/* Set up key pressed handler - need to handle Tab key */
 	g_signal_connect (G_OBJECT (editable), "key-press-event",
 	                  (GCallback) key_pressed_cb,
@@ -520,6 +586,11 @@ uint_cell_editing_started (GtkCellRenderer *cell,
 	                        (GCallback) delete_text_cb,
 	                        user_data);
 
+	/* Set up handler for value verifying and changing cell background */
+	g_signal_connect (G_OBJECT (editable), "changed",
+	                  (GCallback) cell_changed_cb,
+	                  cell);
+
 	/* Set up key pressed handler - need to handle Tab key */
 	g_signal_connect (G_OBJECT (editable), "key-press-event",
 	                  (GCallback) key_pressed_cb,
diff --git a/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c b/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
index ee1c607..879e6f9 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
@@ -363,6 +363,57 @@ delete_text_cb (GtkEditable *editable,
 }
 
 static gboolean
+cell_changed_cb (GtkEditable *editable,
+                 gpointer user_data)
+{
+	char *cell_text;
+	guint column;
+	GdkColor color;
+	gboolean value_valid = FALSE;
+
+	cell_text = gtk_editable_get_chars (editable, 0, -1);
+
+	column = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (user_data), "column"));
+
+	if (column == COL_PREFIX) {
+		long int tmp_int;
+
+		errno = 0;
+		tmp_int = strtol (cell_text, NULL, 10);
+		if (errno || tmp_int < 0 || tmp_int > 128)
+			value_valid = FALSE;
+		else
+			value_valid = TRUE;
+	} else if (column == COL_METRIC) {
+		long int tmp_int;
+
+		errno = 0;
+		tmp_int = strtol (cell_text, NULL, 10);
+		if (errno || tmp_int < 0 || tmp_int > G_MAXUINT32)
+			value_valid = FALSE;
+		else
+			value_valid = TRUE;
+	} else {
+		struct in6_addr tmp_addr;
+
+		if (inet_pton (AF_INET6, cell_text, &tmp_addr) > 0)
+			value_valid = TRUE;
+	}
+
+	/* Change cell's background color while editing */
+	if (value_valid)
+		gdk_color_parse ("lightgreen", &color);
+	else
+		gdk_color_parse ("red", &color);
+
+	gtk_widget_modify_base (GTK_WIDGET (editable), GTK_STATE_NORMAL, &color); /* works for GTK2 */
+	gtk_widget_modify_bg (GTK_WIDGET (editable), GTK_STATE_NORMAL, &color);   /* works for GTK3 */
+
+	g_free (cell_text);
+	return FALSE;
+}
+
+static gboolean
 key_pressed_cb (GtkWidget *widget,
                 GdkEvent *event,
                 gpointer user_data)
@@ -405,6 +456,11 @@ ip6_cell_editing_started (GtkCellRenderer *cell,
 	                        (GCallback) delete_text_cb,
 	                        user_data);
 
+	/* Set up handler for value verifying and changing cell background */
+	g_signal_connect (G_OBJECT (editable), "changed",
+	                  (GCallback) cell_changed_cb,
+	                  cell);
+
 	/* Set up key pressed handler - need to handle Tab key */
 	g_signal_connect (G_OBJECT (editable), "key-press-event",
 	                  (GCallback) key_pressed_cb,
@@ -477,6 +533,11 @@ uint_cell_editing_started (GtkCellRenderer *cell,
 	                        (GCallback) delete_text_cb,
 	                        user_data);
 
+	/* Set up handler for value verifying and changing cell background */
+	g_signal_connect (G_OBJECT (editable), "changed",
+	                  (GCallback) cell_changed_cb,
+	                  cell);
+
 	/* Set up key pressed handler - need to handle Tab key */
 	g_signal_connect (G_OBJECT (editable), "key-press-event",
 	                  (GCallback) key_pressed_cb,
diff --git a/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c b/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
index 4aa5b58..faa4264 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
@@ -652,6 +652,69 @@ delete_text_cb (GtkEditable *editable,
 }
 
 static gboolean
+parse_netmask (const char *str, guint32 *prefix)
+{
+	struct in_addr tmp_addr;
+	glong tmp_prefix;
+
+	errno = 0;
+
+	/* Is it a prefix? */
+	if (!strchr (str, '.')) {
+		tmp_prefix = strtol (str, NULL, 10);
+		if (!errno && tmp_prefix >= 0 && tmp_prefix <= 32) {
+			*prefix = tmp_prefix;
+			return TRUE;
+		}
+	}
+
+	/* Is it a netmask? */
+	if (inet_pton (AF_INET, str, &tmp_addr) > 0) {
+		*prefix = nm_utils_ip4_netmask_to_prefix (tmp_addr.s_addr);
+		return TRUE;
+	}
+
+	return FALSE;
+}
+
+static gboolean
+cell_changed_cb (GtkEditable *editable,
+                 gpointer user_data)
+{
+	char *cell_text;
+	guint column;
+	GdkColor color;
+	gboolean value_valid = FALSE;
+
+	cell_text = gtk_editable_get_chars (editable, 0, -1);
+
+	/* The COL_PREFIX can contain IP address or prefix */
+	column = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (user_data), "column"));
+	if (column == COL_PREFIX) {
+		guint32 tmp_prefix;
+
+		value_valid = parse_netmask (cell_text, &tmp_prefix);
+	} else {
+		struct in_addr tmp_addr;
+
+		if (inet_pton (AF_INET, cell_text, &tmp_addr) > 0)
+			value_valid = TRUE;
+	}
+
+	/* Change cell's background color while editing */
+	if (value_valid)
+		gdk_color_parse ("lightgreen", &color);
+	else
+		gdk_color_parse ("red", &color);
+
+	gtk_widget_modify_base (GTK_WIDGET (editable), GTK_STATE_NORMAL, &color); /* works for GTK2 */
+	gtk_widget_modify_bg (GTK_WIDGET (editable), GTK_STATE_NORMAL, &color);   /* works for GTK3 */
+
+	g_free (cell_text);
+	return FALSE;
+}
+
+static gboolean
 key_pressed_cb (GtkWidget *widget,
                 GdkEvent *event,
                 gpointer user_data)
@@ -697,6 +760,11 @@ cell_editing_started (GtkCellRenderer *cell,
 	                        (GCallback) delete_text_cb,
 	                        user_data);
 
+	/* Set up handler for IP verifying and changing cell background */
+	g_signal_connect (G_OBJECT (editable), "changed",
+	                  (GCallback) cell_changed_cb,
+	                  cell);
+
 	/* Set up key pressed handler - need to handle Tab key */
 	g_signal_connect (G_OBJECT (editable), "key-press-event",
 	                  (GCallback) key_pressed_cb,
@@ -959,32 +1027,6 @@ free_one_addr (gpointer data)
 }
 
 static gboolean
-parse_netmask (const char *str, guint32 *prefix)
-{
-	struct in_addr tmp_addr;
-	glong tmp_prefix;
-
-	errno = 0;
-
-	/* Is it a prefix? */
-	if (!strchr (str, '.')) {
-		tmp_prefix = strtol (str, NULL, 10);
-		if (!errno && tmp_prefix >= 0 && tmp_prefix <= 32) {
-			*prefix = tmp_prefix;
-			return TRUE;
-		}
-	}
-
-	/* Is it a netmask? */
-	if (inet_pton (AF_INET, str, &tmp_addr) > 0) {
-		*prefix = nm_utils_ip4_netmask_to_prefix (tmp_addr.s_addr);
-		return TRUE;
-	}
-
-	return FALSE;
-}
-
-static gboolean
 ui_to_setting (CEPageIP4 *self)
 {
 	CEPageIP4Private *priv = CE_PAGE_IP4_GET_PRIVATE (self);
@@ -1041,7 +1083,7 @@ ui_to_setting (CEPageIP4 *self)
 		guint32 empty_val = 0, prefix;
 
 		gtk_tree_model_get (model, &tree_iter, COL_ADDRESS, &item, -1);
-		if (!item || !inet_aton (item, &tmp_addr)) {
+		if (!item || inet_pton (AF_INET, item, &tmp_addr) <= 0) {
 			g_warning ("%s: IPv4 address '%s' missing or invalid!",
 			           __func__, item ? item : "<none>");
 			g_free (item);
@@ -1066,7 +1108,7 @@ ui_to_setting (CEPageIP4 *self)
 
 		/* Gateway is optional... */
 		gtk_tree_model_get (model, &tree_iter, COL_GATEWAY, &item, -1);
-		if (item && !inet_aton (item, &tmp_gateway)) {
+		if (item && inet_pton (AF_INET, item, &tmp_gateway) <= 0) {
 			g_warning ("%s: IPv4 gateway '%s' invalid!",
 			           __func__, item ? item : "<none>");
 			g_free (item);
diff --git a/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c b/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c
index 2721373..01cc4b1 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c
@@ -632,6 +632,48 @@ delete_text_cb (GtkEditable *editable,
 }
 
 static gboolean
+cell_changed_cb (GtkEditable *editable,
+                 gpointer user_data)
+{
+	char *cell_text;
+	guint column;
+	GdkColor color;
+	gboolean value_valid = FALSE;
+
+	cell_text = gtk_editable_get_chars (editable, 0, -1);
+
+	/* The Prefix column is 0..128 */
+	column = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (user_data), "column"));
+	if (column == COL_PREFIX) {
+		guint32 prefix;
+		char *end;
+
+		prefix = strtoul (cell_text, &end, 10);
+		if (!end || *end || prefix == 0 || prefix > 128)
+			value_valid = FALSE;
+		else
+			value_valid = TRUE;
+	} else {
+		struct in6_addr tmp_addr;
+
+		if (inet_pton (AF_INET6, cell_text, &tmp_addr))
+			value_valid = TRUE;
+	}
+
+	/* Change cell's background color while editing */
+	if (value_valid)
+		gdk_color_parse ("lightgreen", &color);
+	else
+		gdk_color_parse ("red", &color);
+
+	gtk_widget_modify_base (GTK_WIDGET (editable), GTK_STATE_NORMAL, &color); /* works for GTK2 */
+	gtk_widget_modify_bg (GTK_WIDGET (editable), GTK_STATE_NORMAL, &color);   /* works for GTK3 */
+
+	g_free (cell_text);
+	return FALSE;
+}
+
+static gboolean
 key_pressed_cb (GtkWidget *widget,
                 GdkEvent *event,
                 gpointer user_data)
@@ -682,6 +724,11 @@ cell_editing_started (GtkCellRenderer *cell,
 	                        (GCallback) delete_text_cb,
 	                        user_data);
 
+	/* Set up handler for value verifying and changing cell background */
+	g_signal_connect (G_OBJECT (editable), "changed",
+	                  (GCallback) cell_changed_cb,
+	                  cell);
+
 	/* Set up key pressed handler - need to handle Tab key */
 	g_signal_connect (G_OBJECT (editable), "key-press-event",
 	                  (GCallback) key_pressed_cb,
-- 
2.1.0


From 4ba87bf6c53db28230a3ae497db6b9cfcda4f79c Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ji=C5=99=C3=AD=20Klime=C5=A1?= <jklimes@redhat.com>
Date: Tue, 12 Mar 2013 13:23:21 +0100
Subject: [PATCH 03/11] editor: zero next_hop, else empty "Gateway" is filled
 with random bytes
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Found out while analyzing https://bugzilla.gnome.org/show_bug.cgi?id=695572

Signed-off-by: Jiří Klimeš <jklimes@redhat.com>

(based on upstream commit d48ab8376000cd7d56571bced4c95c722ae4fcd5)

Signed-off-by: Jiří Klimeš <jklimes@redhat.com>
---
 network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c | 1 +
 1 file changed, 1 insertion(+)

diff --git a/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c b/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
index 879e6f9..73d33d3 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
@@ -803,6 +803,7 @@ ip6_routes_dialog_update_setting (GtkWidget *dialog, NMSettingIP6Config *s_ip6)
 		}
 
 		/* Next hop (optional) */
+		memset (&next_hop, 0, sizeof (struct in6_addr));
 		if (!get_one_addr (model, &tree_iter, COL_NEXT_HOP, FALSE, &next_hop)) {
 			g_warning ("%s: IPv6 next hop invalid!", __func__);
 			goto next;
-- 
2.1.0


From 8312493c401efd330dcd56d181a2fc3cc78ce887 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ji=C5=99=C3=AD=20Klime=C5=A1?= <jklimes@redhat.com>
Date: Tue, 3 Mar 2015 14:33:14 +0100
Subject: [PATCH 04/11] editor: fix prefix validation for addresses, zero is
 not allowed
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Jiří Klimeš <jklimes@redhat.com>

(based on upstream commit 1b47f453bdb95f56297f84d8902cd75f8d74fe75)

Signed-off-by: Jiří Klimeš <jklimes@redhat.com>
---
 network-manager-applet-0.8.1/src/connection-editor/page-ip4.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c b/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
index faa4264..f84951d 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
@@ -662,7 +662,7 @@ parse_netmask (const char *str, guint32 *prefix)
 	/* Is it a prefix? */
 	if (!strchr (str, '.')) {
 		tmp_prefix = strtol (str, NULL, 10);
-		if (!errno && tmp_prefix >= 0 && tmp_prefix <= 32) {
+		if (!errno && tmp_prefix > 0 && tmp_prefix <= 32) {
 			*prefix = tmp_prefix;
 			return TRUE;
 		}
-- 
2.1.0


From c5c9ac2a9782e052c424dcf2d68a9e8968bb46ec Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ji=C5=99=C3=AD=20Klime=C5=A1?= <jklimes@redhat.com>
Date: Tue, 3 Mar 2015 16:40:22 +0100
Subject: [PATCH 05/11] editor: correct on-the-fly color error indication for
 empty values
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Jiří Klimeš <jklimes@redhat.com>

(based on upstream commit f22b86f4d1bc2b1c6dd0b384db2aa5d57c530518)

Signed-off-by: Jiří Klimeš <jklimes@redhat.com>
---
 .../src/connection-editor/ip4-routes-dialog.c                       | 6 +++++-
 .../src/connection-editor/ip6-routes-dialog.c                       | 6 +++++-
 2 files changed, 10 insertions(+), 2 deletions(-)

diff --git a/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c b/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
index 44cc679..0dad95d 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
@@ -428,7 +428,7 @@ cell_changed_cb (GtkEditable *editable,
 		/* Is it a prefix? */
 		if (!strchr (cell_text, '.')) {
 			tmp_prefix = strtol (cell_text, NULL, 10);
-			if (!errno && tmp_prefix >= 0 && tmp_prefix <= 32)
+			if (*cell_text && !errno && tmp_prefix <= 32)
 				value_valid = TRUE;
 		} else {
 			struct in_addr tmp_addr;
@@ -451,6 +451,10 @@ cell_changed_cb (GtkEditable *editable,
 
 		if (inet_pton (AF_INET, cell_text, &tmp_addr) > 0)
 			value_valid = TRUE;
+
+		/* Consider empty next_hop as valid */
+		if (!*cell_text && column == COL_NEXT_HOP)
+			value_valid = TRUE;
 	}
 
 	/* Change cell's background color while editing */
diff --git a/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c b/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
index 73d33d3..a58e336 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
@@ -380,7 +380,7 @@ cell_changed_cb (GtkEditable *editable,
 
 		errno = 0;
 		tmp_int = strtol (cell_text, NULL, 10);
-		if (errno || tmp_int < 0 || tmp_int > 128)
+		if (!*cell_text || errno || tmp_int < 0 || tmp_int > 128)
 			value_valid = FALSE;
 		else
 			value_valid = TRUE;
@@ -398,6 +398,10 @@ cell_changed_cb (GtkEditable *editable,
 
 		if (inet_pton (AF_INET6, cell_text, &tmp_addr) > 0)
 			value_valid = TRUE;
+
+		/* Consider empty next_hop as valid */
+		if (!*cell_text && column == COL_NEXT_HOP)
+			value_valid = TRUE;
 	}
 
 	/* Change cell's background color while editing */
-- 
2.1.0


From 8116424623b6089ca4516b54a1c8893fcc2119c9 Mon Sep 17 00:00:00 2001
From: Dan Williams <dcbw@redhat.com>
Date: Wed, 13 Apr 2011 15:15:29 -0500
Subject: [PATCH 06/11] editor: fix reading uninitialized memory
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Need to allocate space for the C string terminator and set it
to 0.

Signed-off-by: Jiří Klimeš <jklimes@redhat.com>

(based on upstream commit e9c8c6a35f66293833d456c41c6599fdbea34f96)

Signed-off-by: Jiří Klimeš <jklimes@redhat.com>
---
 .../src/connection-editor/ip4-routes-dialog.c      |  4 +++-
 .../src/connection-editor/ip6-routes-dialog.c      |  4 +++-
 .../src/connection-editor/page-ip4.c               |  4 +++-
 .../src/connection-editor/page-ip6.c               |  4 +++-
 .../src/wireless-security/ws-wep-key.c             | 24 +++++++++++-----------
 5 files changed, 24 insertions(+), 16 deletions(-)

diff --git a/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c b/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
index 0dad95d..b7bd51a 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
@@ -357,7 +357,9 @@ ip_address_filter_cb (GtkEntry *   entry,
 	GtkWidget *ok_button = user_data;
 	GtkEditable *editable = GTK_EDITABLE (entry);
 	int i, count = 0;
-	gchar *result = g_new (gchar, length);
+	gchar *result;
+
+	result = g_malloc0 (length + 1);
 
 	for (i = 0; i < length; i++) {
 		if ((text[i] >= '0' && text[i] <= '9') || (text[i] == '.'))
diff --git a/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c b/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
index a58e336..6cbc5f5 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
@@ -314,7 +314,9 @@ ip_address_filter_cb (GtkEntry *   entry,
 	GtkWidget *ok_button = user_data;
 	GtkEditable *editable = GTK_EDITABLE (entry);
 	int i, count = 0;
-	gchar *result = g_new (gchar, length);
+	gchar *result;
+
+	result = g_malloc0 (length + 1);
 
 	for (i = 0; i < length; i++) {
 		if (g_ascii_isxdigit(text[i]) || (text[i] == ':'))
diff --git a/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c b/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
index f84951d..219daa6 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
@@ -614,7 +614,9 @@ ip_address_filter_cb (GtkEntry *   entry,
 	CEPageIP4Private *priv = CE_PAGE_IP4_GET_PRIVATE (self);
 	GtkEditable *editable = GTK_EDITABLE (entry);
 	int i, count = 0;
-	gchar *result = g_new0 (gchar, length);
+	gchar *result;
+
+	result = g_malloc0 (length + 1);
 
 	for (i = 0; i < length; i++) {
 		if ((text[i] >= '0' && text[i] <= '9') || (text[i] == '.'))
diff --git a/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c b/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c
index 01cc4b1..88624da 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c
@@ -587,9 +587,11 @@ ip_address_filter_cb (GtkEntry *   entry,
 	GtkEditable *editable = GTK_EDITABLE (entry);
 	gboolean numeric = FALSE;
 	int i, count = 0;
-	gchar *result = g_new0 (gchar, length);
+	gchar *result;
 	guint column;
 
+	result = g_malloc0 (length + 1);
+
 	/* The prefix column only allows numbers, no ':' */
 	column = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (editable), "column"));
 	if (column == COL_PREFIX)
diff --git a/network-manager-applet-0.8.1/src/wireless-security/ws-wep-key.c b/network-manager-applet-0.8.1/src/wireless-security/ws-wep-key.c
index e13532b..905722e 100644
--- a/network-manager-applet-0.8.1/src/wireless-security/ws-wep-key.c
+++ b/network-manager-applet-0.8.1/src/wireless-security/ws-wep-key.c
@@ -184,7 +184,9 @@ wep_entry_filter_cb (GtkEntry *   entry,
 	WirelessSecurityWEPKey *sec = (WirelessSecurityWEPKey *) data;
 	GtkEditable *editable = GTK_EDITABLE (entry);
 	int i, count = 0;
-	gchar *result = g_new (gchar, length);
+	gchar *result;
+
+	result = g_malloc0 (length + 1);
 
 	if (sec->type == NM_WEP_KEY_TYPE_KEY) {
 		for (i = 0; i < length; i++) {
@@ -196,18 +198,16 @@ wep_entry_filter_cb (GtkEntry *   entry,
 			result[count++] = text[i];
 	}
 
-	if (count == 0)
-		goto out;
-
-	g_signal_handlers_block_by_func (G_OBJECT (editable),
-	                                 G_CALLBACK (wep_entry_filter_cb),
-	                                 data);
-	gtk_editable_insert_text (editable, result, count, position);
-	g_signal_handlers_unblock_by_func (G_OBJECT (editable),
-	                                   G_CALLBACK (wep_entry_filter_cb),
-	                                   data);
+	if (count > 0) {
+		g_signal_handlers_block_by_func (G_OBJECT (editable),
+			                             G_CALLBACK (wep_entry_filter_cb),
+			                             data);
+		gtk_editable_insert_text (editable, result, count, position);
+		g_signal_handlers_unblock_by_func (G_OBJECT (editable),
+			                               G_CALLBACK (wep_entry_filter_cb),
+			                               data);
+	}
 
-out:
 	g_signal_stop_emission_by_name (G_OBJECT (editable), "insert-text");
 	g_free (result);
 }
-- 
2.1.0


From b73766b436e887e7f6b142836649e1fc9bad8747 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ji=C5=99=C3=AD=20Klime=C5=A1?= <jklimes@redhat.com>
Date: Wed, 5 Dec 2012 18:58:39 +0100
Subject: [PATCH 07/11] editor: fix crash when 'Tab' is pressed with XIM input
 (editting IPs) (rh #747368)
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Reproducer:
1. GTK_IM_MODULE=xim nm-connection-editor
2. Go to 'IPv4 Settings', set Method as 'Manual'
3. Click Add and then press Tab key

For details see:
https://bugzilla.redhat.com/show_bug.cgi?id=747368

Signed-off-by: Jiří Klimeš <jklimes@redhat.com>

(based on upstream commit d06f1ea8e2eaa5faab41fbc87669dc9c56b3cb73)

Signed-off-by: Jiří Klimeš <jklimes@redhat.com>
---
 .../src/connection-editor/ip4-routes-dialog.c      | 23 +++++++++++++++++++---
 .../src/connection-editor/ip6-routes-dialog.c      | 23 +++++++++++++++++++---
 .../src/connection-editor/page-ip4.c               | 23 +++++++++++++++++++---
 .../src/connection-editor/page-ip6.c               | 23 +++++++++++++++++++---
 4 files changed, 80 insertions(+), 12 deletions(-)

diff --git a/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c b/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
index b7bd51a..9bd001c 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
@@ -481,9 +481,26 @@ key_pressed_cb (GtkWidget *widget,
 	#define GDK_KEY_Tab GDK_Tab
 #endif
 
-	/* Tab should behave the same way as Enter (finish editing) */
-	if (event->type == GDK_KEY_PRESS && event->key.keyval == GDK_KEY_Tab)
-		gtk_cell_editable_editing_done (GTK_CELL_EDITABLE (widget));
+	GdkKeymapKey *keys = NULL;
+	gint n_keys;
+
+	/*
+	 * Tab should behave the same way as Enter (cycling on cells).
+	 *
+	 * Previously, we had finished cell editing, which appeared to work:
+	 *   gtk_cell_editable_editing_done (GTK_CELL_EDITABLE (widget));
+	 * But unfortunately, it showed up crash occurred with XIM input (GTK_IM_MODULE=xim).
+	 * https://bugzilla.redhat.com/show_bug.cgi?id=747368
+	 */
+	if (event->type == GDK_KEY_PRESS && event->key.keyval == GDK_KEY_Tab) {
+		/* Get hardware keycode for GDK_KEY_Return */
+		if (gdk_keymap_get_entries_for_keyval (gdk_keymap_get_default (), GDK_KEY_Return, &keys, &n_keys)) {
+			/* Change 'Tab' to 'Enter' key */
+			event->key.keyval = GDK_KEY_Return;
+			event->key.hardware_keycode = keys[0].keycode;
+		}
+		g_free (keys);
+	}
 
 	return FALSE;
 }
diff --git a/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c b/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
index 6cbc5f5..f5b1ff9 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
@@ -428,9 +428,26 @@ key_pressed_cb (GtkWidget *widget,
 	#define GDK_KEY_Tab GDK_Tab
 #endif
 
-	/* Tab should behave the same way as Enter (finish editing) */
-	if (event->type == GDK_KEY_PRESS && event->key.keyval == GDK_KEY_Tab)
-		gtk_cell_editable_editing_done (GTK_CELL_EDITABLE (widget));
+	GdkKeymapKey *keys = NULL;
+	gint n_keys;
+
+	/*
+	 * Tab should behave the same way as Enter (cycling on cells).
+	 *
+	 * Previously, we had finished cell editing, which appeared to work:
+	 *   gtk_cell_editable_editing_done (GTK_CELL_EDITABLE (widget));
+	 * But unfortunately, it showed up crash occurred with XIM input (GTK_IM_MODULE=xim).
+	 * https://bugzilla.redhat.com/show_bug.cgi?id=747368
+	 */
+	if (event->type == GDK_KEY_PRESS && event->key.keyval == GDK_KEY_Tab) {
+		/* Get hardware keycode for GDK_KEY_Return */
+		if (gdk_keymap_get_entries_for_keyval (gdk_keymap_get_default (), GDK_KEY_Return, &keys, &n_keys)) {
+			/* Change 'Tab' to 'Enter' key */
+			event->key.keyval = GDK_KEY_Return;
+			event->key.hardware_keycode = keys[0].keycode;
+		}
+		g_free (keys);
+	}
 
 	return FALSE;
 }
diff --git a/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c b/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
index 219daa6..c563777 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
@@ -725,9 +725,26 @@ key_pressed_cb (GtkWidget *widget,
 	#define GDK_KEY_Tab GDK_Tab
 #endif
 
-	/* Tab should behave the same way as Enter (finish editing) */
-	if (event->type == GDK_KEY_PRESS && event->key.keyval == GDK_KEY_Tab)
-		gtk_cell_editable_editing_done (GTK_CELL_EDITABLE (widget));
+	GdkKeymapKey *keys = NULL;
+	gint n_keys;
+
+	/*
+	 * Tab should behave the same way as Enter (cycling on cells).
+	 *
+	 * Previously, we had finished cell editing, which appeared to work:
+	 *   gtk_cell_editable_editing_done (GTK_CELL_EDITABLE (widget));
+	 * But unfortunately, it showed up crash occurred with XIM input (GTK_IM_MODULE=xim).
+	 * https://bugzilla.redhat.com/show_bug.cgi?id=747368
+	 */
+	if (event->type == GDK_KEY_PRESS && event->key.keyval == GDK_KEY_Tab) {
+		/* Get hardware keycode for GDK_KEY_Return */
+		if (gdk_keymap_get_entries_for_keyval (gdk_keymap_get_default (), GDK_KEY_Return, &keys, &n_keys)) {
+			/* Change 'Tab' to 'Enter' key */
+			event->key.keyval = GDK_KEY_Return;
+			event->key.hardware_keycode = keys[0].keycode;
+		}
+		g_free (keys);
+	}
 
 	return FALSE;
 }
diff --git a/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c b/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c
index 88624da..7581549 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c
@@ -684,9 +684,26 @@ key_pressed_cb (GtkWidget *widget,
 	#define GDK_KEY_Tab GDK_Tab
 #endif
 
-	/* Tab should behave the same way as Enter (finish editing) */
-	if (event->type == GDK_KEY_PRESS && event->key.keyval == GDK_KEY_Tab)
-		gtk_cell_editable_editing_done (GTK_CELL_EDITABLE (widget));
+	GdkKeymapKey *keys = NULL;
+	gint n_keys;
+
+	/*
+	 * Tab should behave the same way as Enter (cycling on cells).
+	 *
+	 * Previously, we had finished cell editing, which appeared to work:
+	 *   gtk_cell_editable_editing_done (GTK_CELL_EDITABLE (widget));
+	 * But unfortunately, it showed up crash occurred with XIM input (GTK_IM_MODULE=xim).
+	 * https://bugzilla.redhat.com/show_bug.cgi?id=747368
+	 */
+	if (event->type == GDK_KEY_PRESS && event->key.keyval == GDK_KEY_Tab) {
+		/* Get hardware keycode for GDK_KEY_Return */
+		if (gdk_keymap_get_entries_for_keyval (gdk_keymap_get_default (), GDK_KEY_Return, &keys, &n_keys)) {
+			/* Change 'Tab' to 'Enter' key */
+			event->key.keyval = GDK_KEY_Return;
+			event->key.hardware_keycode = keys[0].keycode;
+		}
+		g_free (keys);
+	}
 
 	return FALSE;
 }
-- 
2.1.0


From 02e8094334ebdc957f3cc938228a57e579dfe4bc Mon Sep 17 00:00:00 2001
From: Thomas Haller <thaller@redhat.com>
Date: Fri, 27 Sep 2013 20:02:40 +0200
Subject: [PATCH 08/11] editor: fix mem leak when calling
 gtk_editable_get_chars
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

The return value of gtk_editable_get_chars is owned by the caller, so
calling g_strdup leaks memory.

Signed-off-by: Thomas Haller <thaller@redhat.com>
Signed-off-by: Jiří Klimeš <jklimes@redhat.com>

(based on upstream commit bbbdb09bca3a03652cb1e4630b39979226b96349)

Signed-off-by: Jiří Klimeš <jklimes@redhat.com>
---
 .../src/connection-editor/ip4-routes-dialog.c                       | 6 +++---
 .../src/connection-editor/ip6-routes-dialog.c                       | 6 +++---
 network-manager-applet-0.8.1/src/connection-editor/page-ip4.c       | 4 ++--
 network-manager-applet-0.8.1/src/connection-editor/page-ip6.c       | 4 ++--
 4 files changed, 10 insertions(+), 10 deletions(-)

diff --git a/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c b/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
index 9bd001c..8b7ea40 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
@@ -372,7 +372,7 @@ ip_address_filter_cb (GtkEntry *   entry,
 		                                 user_data);
 		gtk_editable_insert_text (editable, result, count, position);
 		g_free (last_edited);
-		last_edited = g_strdup (gtk_editable_get_chars (editable, 0, -1));
+		last_edited = gtk_editable_get_chars (editable, 0, -1);
 		g_signal_handlers_unblock_by_func (G_OBJECT (editable),
 		                                   G_CALLBACK (ip_address_filter_cb),
 		                                   user_data);
@@ -398,7 +398,7 @@ delete_text_cb (GtkEditable *editable,
 
 	/* Keep last_edited up-to-date */
 	g_free (last_edited);
-	last_edited = g_strdup (gtk_editable_get_chars (editable, 0, -1));
+	last_edited = gtk_editable_get_chars (editable, 0, -1);
 
 	/* Desensitize the OK button during input to simplify input validation.
 	 * All routes will be validated on focus-out, which will then re-enable
@@ -566,7 +566,7 @@ uint_filter_cb (GtkEntry *   entry,
 		                                 user_data);
 		gtk_editable_insert_text (editable, result, count, position);
 		g_free (last_edited);
-		last_edited = g_strdup (gtk_editable_get_chars (editable, 0, -1));
+		last_edited = gtk_editable_get_chars (editable, 0, -1);
 		g_signal_handlers_unblock_by_func (G_OBJECT (editable),
 		                                   G_CALLBACK (uint_filter_cb),
 		                                   user_data);
diff --git a/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c b/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
index f5b1ff9..5bbb669 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
@@ -329,7 +329,7 @@ ip_address_filter_cb (GtkEntry *   entry,
 		                                 user_data);
 		gtk_editable_insert_text (editable, result, count, position);
 		g_free (last_edited);
-		last_edited = g_strdup (gtk_editable_get_chars (editable, 0, -1));
+		last_edited = gtk_editable_get_chars (editable, 0, -1);
 		g_signal_handlers_unblock_by_func (G_OBJECT (editable),
 		                                   G_CALLBACK (ip_address_filter_cb),
 		                                   user_data);
@@ -355,7 +355,7 @@ delete_text_cb (GtkEditable *editable,
 
 	/* Keep last_edited up-to-date */
 	g_free (last_edited);
-	last_edited = g_strdup (gtk_editable_get_chars (editable, 0, -1));
+	last_edited = gtk_editable_get_chars (editable, 0, -1);
 
 	/* Desensitize the OK button during input to simplify input validation.
 	 * All routes will be validated on focus-out, which will then re-enable
@@ -513,7 +513,7 @@ uint_filter_cb (GtkEntry *   entry,
 		                                 user_data);
 		gtk_editable_insert_text (editable, result, count, position);
 		g_free (last_edited);
-		last_edited = g_strdup (gtk_editable_get_chars (editable, 0, -1));
+		last_edited = gtk_editable_get_chars (editable, 0, -1);
 		g_signal_handlers_unblock_by_func (G_OBJECT (editable),
 		                                   G_CALLBACK (uint_filter_cb),
 		                                   user_data);
diff --git a/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c b/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
index c563777..d264e52 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
@@ -629,7 +629,7 @@ ip_address_filter_cb (GtkEntry *   entry,
 		                                 user_data);
 		gtk_editable_insert_text (editable, result, count, position);
 		g_free (priv->last_edited);
-		priv->last_edited = g_strdup (gtk_editable_get_chars (editable, 0, -1));
+		priv->last_edited = gtk_editable_get_chars (editable, 0, -1);
 		g_signal_handlers_unblock_by_func (G_OBJECT (editable),
 		                                   G_CALLBACK (ip_address_filter_cb),
 		                                   user_data);
@@ -650,7 +650,7 @@ delete_text_cb (GtkEditable *editable,
 
 	/* Keep last_edited up-to-date */
 	g_free (priv->last_edited);
-	priv->last_edited = g_strdup (gtk_editable_get_chars (editable, 0, -1));
+	priv->last_edited = gtk_editable_get_chars (editable, 0, -1);
 }
 
 static gboolean
diff --git a/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c b/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c
index 7581549..adc9a3f 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c
@@ -609,7 +609,7 @@ ip_address_filter_cb (GtkEntry *   entry,
 		                                 user_data);
 		gtk_editable_insert_text (editable, result, count, position);
 		g_free (priv->last_edited);
-		priv->last_edited = g_strdup (gtk_editable_get_chars (editable, 0, -1));
+		priv->last_edited = gtk_editable_get_chars (editable, 0, -1);
 		g_signal_handlers_unblock_by_func (G_OBJECT (editable),
 		                                   G_CALLBACK (ip_address_filter_cb),
 		                                   user_data);
@@ -630,7 +630,7 @@ delete_text_cb (GtkEditable *editable,
 
 	/* Keep last_edited up-to-date */
 	g_free (priv->last_edited);
-	priv->last_edited = g_strdup (gtk_editable_get_chars (editable, 0, -1));
+	priv->last_edited = gtk_editable_get_chars (editable, 0, -1);
 }
 
 static gboolean
-- 
2.1.0


From 0deaa44ee1f3c7379b38dbed0b430a47d63c267b Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ji=C5=99=C3=AD=20Klime=C5=A1?= <jklimes@redhat.com>
Date: Tue, 17 May 2011 14:16:39 +0200
Subject: [PATCH 09/11] editor: don't allow inserting 0.0.0.0 as destination
 and netmask for IPv4 routes
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

0.0.0.0 would mean default gateway. However, it's not supported in routes now
anyway. At present, we only support one default gateway and that's taken from
gateway field of address structure.
Moreover, inserting 0.0.0.0 renders the connection invalid (verify() in
libnm-util).

Signed-off-by: Jiří Klimeš <jklimes@redhat.com>

(based on upstream commit bdc58dd6f4ef9004dd3f8937d55a35794b7d7c76)

Signed-off-by: Jiří Klimeš <jklimes@redhat.com>
---
 .../src/connection-editor/ip4-routes-dialog.c                       | 6 ++++++
 1 file changed, 6 insertions(+)

diff --git a/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c b/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
index 8b7ea40..25cf08b 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
@@ -170,10 +170,16 @@ validate (GtkWidget *dialog)
 		/* Address */
 		if (!get_one_addr (model, &tree_iter, COL_ADDRESS, TRUE, &addr))
 			goto done;
+		/* Don't allow inserting 0.0.0.0 for now - that's not supported in libnm-util */
+		if (addr == 0)
+			goto done;
 
 		/* Prefix */
 		if (!get_one_prefix (model, &tree_iter, COL_PREFIX, TRUE, &prefix))
 			goto done;
+		/* Don't allow zero prefix for now - that's not supported in libnm-util */
+		if (prefix == 0)
+			goto done;
 
 		/* Next hop (optional) */
 		if (!get_one_addr (model, &tree_iter, COL_NEXT_HOP, FALSE, &next_hop))
-- 
2.1.0


From aa05d5fd69a43d78c2fb5ad81b81f1a975f17ee9 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ji=C5=99=C3=AD=20Klime=C5=A1?= <jklimes@redhat.com>
Date: Wed, 4 Mar 2015 14:38:24 +0100
Subject: [PATCH 10/11] editor: don't allow zero prefix for IP routes
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Signed-off-by: Jiří Klimeš <jklimes@redhat.com>

(based on upstream commit cddb7cb7b1cde92bd7f21a77dee61b0b3eb471eb)

Signed-off-by: Jiří Klimeš <jklimes@redhat.com>
---
 .../src/connection-editor/ip4-routes-dialog.c                     | 2 +-
 .../src/connection-editor/ip6-routes-dialog.c                     | 8 +++++---
 2 files changed, 6 insertions(+), 4 deletions(-)

diff --git a/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c b/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
index 25cf08b..0d5982f 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
@@ -436,7 +436,7 @@ cell_changed_cb (GtkEditable *editable,
 		/* Is it a prefix? */
 		if (!strchr (cell_text, '.')) {
 			tmp_prefix = strtol (cell_text, NULL, 10);
-			if (*cell_text && !errno && tmp_prefix <= 32)
+			if (*cell_text && !errno && tmp_prefix > 0 && tmp_prefix <= 32)
 				value_valid = TRUE;
 		} else {
 			struct in_addr tmp_addr;
diff --git a/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c b/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
index 5bbb669..cc88f70 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
@@ -129,7 +129,8 @@ validate (GtkWidget *dialog)
 			goto done;
 
 		/* Prefix */
-		if (!get_one_int (model, &tree_iter, COL_PREFIX, 128, TRUE, &prefix))
+		if (   !get_one_int (model, &tree_iter, COL_PREFIX, 128, TRUE, &prefix)
+		    || prefix == 0)
 			goto done;
 
 		/* Next hop (optional) */
@@ -382,7 +383,7 @@ cell_changed_cb (GtkEditable *editable,
 
 		errno = 0;
 		tmp_int = strtol (cell_text, NULL, 10);
-		if (!*cell_text || errno || tmp_int < 0 || tmp_int > 128)
+		if (!*cell_text || errno || tmp_int < 1 || tmp_int > 128)
 			value_valid = FALSE;
 		else
 			value_valid = TRUE;
@@ -820,7 +821,8 @@ ip6_routes_dialog_update_setting (GtkWidget *dialog, NMSettingIP6Config *s_ip6)
 		}
 
 		/* Prefix */
-		if (!get_one_int (model, &tree_iter, COL_PREFIX, 128, TRUE, &prefix)) {
+		if (   !get_one_int (model, &tree_iter, COL_PREFIX, 128, TRUE, &prefix)
+		    || prefix == 0) {
 			g_warning ("%s: IPv6 prefix missing or invalid!", __func__);
 			goto next;
 		}
-- 
2.1.0


From cc38f9bc91f94108b0e2599a7f7f15dc255edf10 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Ji=C5=99=C3=AD=20Klime=C5=A1?= <jklimes@redhat.com>
Date: Tue, 3 Mar 2015 14:27:05 +0100
Subject: [PATCH 11/11] editor: improve color-indication for bad addresses and
 routes (bgo #660915)
MIME-Version: 1.0
Content-Type: text/plain; charset=UTF-8
Content-Transfer-Encoding: 8bit

Incorrect values are already indicated while they are edited. However, this
commit also makes the incorrect values visible afterwards by setting cell
background to red. It uses the pango markup which has the advantage of being
visible even if the row is selected. When there's no value in the cell, the
cell-background property is used instead.

https://bugzilla.gnome.org/show_bug.cgi?id=660915

Signed-off-by: Jiří Klimeš <jklimes@redhat.com>

(based on uptream commit 975181df307cbd25d6b86d48138457e8a461ed5a)

Signed-off-by: Jiří Klimeš <jklimes@redhat.com>
---
 .../src/connection-editor/ip4-routes-dialog.c      | 91 ++++++++++++++++++----
 .../src/connection-editor/ip6-routes-dialog.c      | 80 +++++++++++++++----
 .../src/connection-editor/page-ip4.c               | 42 ++++++++++
 .../src/connection-editor/page-ip6.c               | 89 +++++++++++++++------
 network-manager-applet-0.8.1/src/utils/utils.c     | 23 ++++++
 network-manager-applet-0.8.1/src/utils/utils.h     |  5 ++
 6 files changed, 277 insertions(+), 53 deletions(-)

diff --git a/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c b/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
index 0d5982f..b4e8f12 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/ip4-routes-dialog.c
@@ -34,6 +34,7 @@
 #include <nm-utils.h>
 
 #include "ip4-routes-dialog.h"
+#include "utils.h"
 
 #define COL_ADDRESS 0
 #define COL_PREFIX  1
@@ -53,15 +54,19 @@ get_one_int (GtkTreeModel *model,
              int column,
              guint32 max_value,
              gboolean fail_if_missing,
-             guint32 *out)
+             guint32 *out,
+             char **out_raw)
 {
 	char *item = NULL;
 	gboolean success = FALSE;
 	long int tmp_int;
 
 	gtk_tree_model_get (model, iter, column, &item, -1);
+	if (out_raw)
+		*out_raw = item;
 	if (!item || !strlen (item)) {
-		g_free (item);
+		if (!out_raw)
+			g_free (item);
 		return fail_if_missing ? FALSE : TRUE;
 	}
 
@@ -74,7 +79,8 @@ get_one_int (GtkTreeModel *model,
 	success = TRUE;
 
 out:
-	g_free (item);
+	if (!out_raw)
+		g_free (item);
 	return success;
 }
 
@@ -83,7 +89,8 @@ get_one_prefix (GtkTreeModel *model,
                 GtkTreeIter *iter,
                 int column,
                 gboolean fail_if_missing,
-                guint32 *out)
+                guint32 *out,
+                char **out_raw)
 {
 	char *item = NULL;
 	struct in_addr tmp_addr = { 0 };
@@ -91,8 +98,11 @@ get_one_prefix (GtkTreeModel *model,
 	glong tmp_prefix;
 
 	gtk_tree_model_get (model, iter, column, &item, -1);
+	if (out_raw)
+		*out_raw = item;
 	if (!item || !strlen (item)) {
-		g_free (item);
+		if (!out_raw)
+			g_free (item);
 		return fail_if_missing ? FALSE : TRUE;
 	}
 
@@ -115,7 +125,8 @@ get_one_prefix (GtkTreeModel *model,
 	}
 
 out:
-	g_free (item);
+	if (!out_raw)
+		g_free (item);
 	return success;
 }
 
@@ -124,15 +135,19 @@ get_one_addr (GtkTreeModel *model,
               GtkTreeIter *iter,
               int column,
               gboolean fail_if_missing,
-              guint32 *out)
+              guint32 *out,
+              char **out_raw)
 {
 	char *item = NULL;
 	struct in_addr tmp_addr = { 0 };
 	gboolean success = FALSE;
 
 	gtk_tree_model_get (model, iter, column, &item, -1);
+	if (out_raw)
+		*out_raw = item;
 	if (!item || !strlen (item)) {
-		g_free (item);
+		if (!out_raw)
+			g_free (item);
 		return fail_if_missing ? FALSE : TRUE;
 	}
 
@@ -141,7 +156,8 @@ get_one_addr (GtkTreeModel *model,
 		success = TRUE;
 	}
 
-	g_free (item);
+	if (!out_raw)
+		g_free (item);
 	return success;
 }
 
@@ -168,25 +184,26 @@ validate (GtkWidget *dialog)
 		guint32 addr = 0, prefix = 0, next_hop = 0, metric = 0;
 
 		/* Address */
-		if (!get_one_addr (model, &tree_iter, COL_ADDRESS, TRUE, &addr))
+		if (!get_one_addr (model, &tree_iter, COL_ADDRESS, TRUE, &addr, NULL))
 			goto done;
 		/* Don't allow inserting 0.0.0.0 for now - that's not supported in libnm-util */
 		if (addr == 0)
 			goto done;
 
 		/* Prefix */
-		if (!get_one_prefix (model, &tree_iter, COL_PREFIX, TRUE, &prefix))
+		if (   !get_one_prefix (model, &tree_iter, COL_PREFIX, TRUE, &prefix, NULL)
+ 		    || prefix == 0)
 			goto done;
 		/* Don't allow zero prefix for now - that's not supported in libnm-util */
 		if (prefix == 0)
 			goto done;
 
 		/* Next hop (optional) */
-		if (!get_one_addr (model, &tree_iter, COL_NEXT_HOP, FALSE, &next_hop))
+		if (!get_one_addr (model, &tree_iter, COL_NEXT_HOP, FALSE, &next_hop, NULL))
 			goto done;
 
 		/* Metric (optional) */
-		if (!get_one_int (model, &tree_iter, COL_METRIC, G_MAXUINT32, FALSE, &metric))
+		if (!get_one_int (model, &tree_iter, COL_METRIC, G_MAXUINT32, FALSE, &metric, NULL))
 			goto done;
 
 		iter_valid = gtk_tree_model_iter_next (model, &tree_iter);
@@ -661,6 +678,38 @@ tree_view_button_pressed_cb (GtkWidget *widget,
 	return FALSE;
 }
 
+static void
+cell_error_data_func (GtkTreeViewColumn *tree_column,
+                      GtkCellRenderer *cell,
+                      GtkTreeModel *tree_model,
+                      GtkTreeIter *iter,
+                      gpointer data)
+{
+	guint32 col = GPOINTER_TO_UINT (data);
+	char *value = NULL;
+	guint32 addr, prefix, next_hop, metric;
+	const char *color = "red";
+	gboolean invalid = FALSE;
+
+	if (col == COL_ADDRESS)
+		invalid = !get_one_addr (tree_model, iter, COL_ADDRESS, TRUE, &addr, &value);
+	else if (col == COL_PREFIX)
+		invalid =    !get_one_prefix (tree_model, iter, COL_PREFIX, TRUE, &prefix, &value)
+		          || prefix == 0;
+	else if (col == COL_NEXT_HOP)
+		invalid = !get_one_addr (tree_model, iter, COL_NEXT_HOP, FALSE, &next_hop, &value);
+	else if (col == COL_METRIC)
+		invalid = !get_one_int (tree_model, iter, COL_METRIC, G_MAXUINT32, FALSE, &metric, &value);
+	else
+		g_warn_if_reached ();
+
+	if (invalid)
+		utils_set_cell_background (cell, color, value);
+	else
+		utils_set_cell_background (cell, NULL, NULL);
+	g_free (value);
+}
+
 GtkWidget *
 ip4_routes_dialog_new (NMSettingIP4Config *s_ip4, gboolean automatic)
 {
@@ -761,6 +810,8 @@ ip4_routes_dialog_new (NMSettingIP4Config *s_ip4, gboolean automatic)
 	column = gtk_tree_view_get_column (GTK_TREE_VIEW (widget), offset - 1);
 	gtk_tree_view_column_set_expand (GTK_TREE_VIEW_COLUMN (column), TRUE);
 	gtk_tree_view_column_set_clickable (GTK_TREE_VIEW_COLUMN (column), TRUE);
+	gtk_tree_view_column_set_cell_data_func (column, renderer, cell_error_data_func,
+	                                         GUINT_TO_POINTER (COL_ADDRESS), NULL);
 
 	/* Prefix column */
 	renderer = gtk_cell_renderer_text_new ();
@@ -778,6 +829,8 @@ ip4_routes_dialog_new (NMSettingIP4Config *s_ip4, gboolean automatic)
 	column = gtk_tree_view_get_column (GTK_TREE_VIEW (widget), offset - 1);
 	gtk_tree_view_column_set_expand (GTK_TREE_VIEW_COLUMN (column), TRUE);
 	gtk_tree_view_column_set_clickable (GTK_TREE_VIEW_COLUMN (column), TRUE);
+	gtk_tree_view_column_set_cell_data_func (column, renderer, cell_error_data_func,
+	                                         GUINT_TO_POINTER (COL_PREFIX), NULL);
 
 	/* Gateway column */
 	renderer = gtk_cell_renderer_text_new ();
@@ -795,6 +848,8 @@ ip4_routes_dialog_new (NMSettingIP4Config *s_ip4, gboolean automatic)
 	column = gtk_tree_view_get_column (GTK_TREE_VIEW (widget), offset - 1);
 	gtk_tree_view_column_set_expand (GTK_TREE_VIEW_COLUMN (column), TRUE);
 	gtk_tree_view_column_set_clickable (GTK_TREE_VIEW_COLUMN (column), TRUE);
+	gtk_tree_view_column_set_cell_data_func (column, renderer, cell_error_data_func,
+	                                         GUINT_TO_POINTER (COL_NEXT_HOP), NULL);
 
 	/* Metric column */
 	renderer = gtk_cell_renderer_text_new ();
@@ -812,6 +867,8 @@ ip4_routes_dialog_new (NMSettingIP4Config *s_ip4, gboolean automatic)
 	column = gtk_tree_view_get_column (GTK_TREE_VIEW (widget), offset - 1);
 	gtk_tree_view_column_set_expand (GTK_TREE_VIEW_COLUMN (column), TRUE);
 	gtk_tree_view_column_set_clickable (GTK_TREE_VIEW_COLUMN (column), TRUE);
+	gtk_tree_view_column_set_cell_data_func (column, renderer, cell_error_data_func,
+	                                         GUINT_TO_POINTER (COL_METRIC), NULL);
 
 	g_object_set_data_full (G_OBJECT (dialog), "renderers", renderers, (GDestroyNotify) g_slist_free);
 
@@ -871,25 +928,25 @@ ip4_routes_dialog_update_setting (GtkWidget *dialog, NMSettingIP4Config *s_ip4)
 		NMIP4Route *route;
 
 		/* Address */
-		if (!get_one_addr (model, &tree_iter, COL_ADDRESS, TRUE, &addr)) {
+		if (!get_one_addr (model, &tree_iter, COL_ADDRESS, TRUE, &addr, NULL)) {
 			g_warning ("%s: IPv4 address missing or invalid!", __func__);
 			goto next;
 		}
 
 		/* Prefix */
-		if (!get_one_prefix (model, &tree_iter, COL_PREFIX, TRUE, &prefix)) {
+		if (!get_one_prefix (model, &tree_iter, COL_PREFIX, TRUE, &prefix, NULL)) {
 			g_warning ("%s: IPv4 prefix/netmask missing or invalid!", __func__);
 			goto next;
 		}
 
 		/* Next hop (optional) */
-		if (!get_one_addr (model, &tree_iter, COL_NEXT_HOP, FALSE, &next_hop)) {
+		if (!get_one_addr (model, &tree_iter, COL_NEXT_HOP, FALSE, &next_hop, NULL)) {
 			g_warning ("%s: IPv4 next hop invalid!", __func__);
 			goto next;
 		}
 
 		/* Metric (optional) */
-		if (!get_one_int (model, &tree_iter, COL_METRIC, G_MAXUINT32, FALSE, &metric)) {
+		if (!get_one_int (model, &tree_iter, COL_METRIC, G_MAXUINT32, FALSE, &metric, NULL)) {
 			g_warning ("%s: IPv4 metric invalid!", __func__);
 			goto next;
 		}
diff --git a/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c b/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
index cc88f70..16fbe60 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/ip6-routes-dialog.c
@@ -34,6 +34,7 @@
 #include <nm-utils.h>
 
 #include "ip6-routes-dialog.h"
+#include "utils.h"
 
 #define COL_ADDRESS 0
 #define COL_PREFIX  1
@@ -53,15 +54,19 @@ get_one_int (GtkTreeModel *model,
              int column,
              guint32 max_value,
              gboolean fail_if_missing,
-             guint *out)
+             guint *out,
+             char **out_raw)
 {
 	char *item = NULL;
 	gboolean success = FALSE;
 	long int tmp_int;
 
 	gtk_tree_model_get (model, iter, column, &item, -1);
+	if (out_raw)
+		*out_raw = item;
 	if (!item || !strlen (item)) {
-		g_free (item);
+		if (!out_raw)
+			g_free (item);
 		return fail_if_missing ? FALSE : TRUE;
 	}
 
@@ -74,7 +79,8 @@ get_one_int (GtkTreeModel *model,
 	success = TRUE;
 
 out:
-	g_free (item);
+	if (!out_raw)
+		g_free (item);
 	return success;
 }
 
@@ -83,21 +89,26 @@ get_one_addr (GtkTreeModel *model,
               GtkTreeIter *iter,
               int column,
               gboolean fail_if_missing,
-              struct in6_addr *out)
+              struct in6_addr *out,
+              char **out_raw)
 {
 	char *item = NULL;
 	gboolean success = FALSE;
 
 	gtk_tree_model_get (model, iter, column, &item, -1);
+	if (out_raw)
+		*out_raw = item;
 	if (!item || !strlen (item)) {
-		g_free (item);
+		if (!out_raw)
+			g_free (item);
 		return fail_if_missing ? FALSE : TRUE;
 	}
 
 	if (inet_pton (AF_INET6, item, out) > 0)
 		success = TRUE;
 
-	g_free (item);
+	if (!out_raw)
+		g_free (item);
 	return success;
 }
 
@@ -125,20 +136,20 @@ validate (GtkWidget *dialog)
 		guint prefix = 0, metric = 0;
 
 		/* Address */
-		if (!get_one_addr (model, &tree_iter, COL_ADDRESS, TRUE, &dest))
+		if (!get_one_addr (model, &tree_iter, COL_ADDRESS, TRUE, &dest, NULL))
 			goto done;
 
 		/* Prefix */
-		if (   !get_one_int (model, &tree_iter, COL_PREFIX, 128, TRUE, &prefix)
+		if (   !get_one_int (model, &tree_iter, COL_PREFIX, 128, TRUE, &prefix, NULL)
 		    || prefix == 0)
 			goto done;
 
 		/* Next hop (optional) */
-		if (!get_one_addr (model, &tree_iter, COL_NEXT_HOP, FALSE, &next_hop))
+		if (!get_one_addr (model, &tree_iter, COL_NEXT_HOP, FALSE, &next_hop, NULL))
 			goto done;
 
 		/* Metric (optional) */
-		if (!get_one_int (model, &tree_iter, COL_METRIC, G_MAXUINT32, FALSE, &metric))
+		if (!get_one_int (model, &tree_iter, COL_METRIC, G_MAXUINT32, FALSE, &metric, NULL))
 			goto done;
 
 		iter_valid = gtk_tree_model_iter_next (model, &tree_iter);
@@ -603,6 +614,39 @@ tree_view_button_pressed_cb (GtkWidget *widget,
 	return FALSE;
 }
 
+static void
+cell_error_data_func (GtkTreeViewColumn *tree_column,
+                      GtkCellRenderer *cell,
+                      GtkTreeModel *tree_model,
+                      GtkTreeIter *iter,
+                      gpointer data)
+{
+	guint32 col = GPOINTER_TO_UINT (data);
+	char *value = NULL;
+	struct in6_addr addr, next_hop;
+	guint32 prefix, metric;
+	const char *color = "red";
+	gboolean invalid = FALSE;
+
+	if (col == COL_ADDRESS)
+		invalid = !get_one_addr (tree_model, iter, COL_ADDRESS, TRUE, &addr, &value);
+	else if (col == COL_PREFIX)
+		invalid =    !get_one_int (tree_model, iter, COL_PREFIX, 128, TRUE, &prefix, &value)
+		          || prefix == 0;
+	else if (col == COL_NEXT_HOP)
+		invalid = !get_one_addr (tree_model, iter, COL_NEXT_HOP, FALSE, &next_hop, &value);
+	else if (col == COL_METRIC)
+		invalid = !get_one_int (tree_model, iter, COL_METRIC, G_MAXUINT32, FALSE, &metric, &value);
+	else
+		g_warn_if_reached ();
+
+	if (invalid)
+		utils_set_cell_background (cell, color, value);
+	else
+		utils_set_cell_background (cell, NULL, NULL);
+	g_free (value);
+}
+
 GtkWidget *
 ip6_routes_dialog_new (NMSettingIP6Config *s_ip6, gboolean automatic)
 {
@@ -704,6 +748,8 @@ ip6_routes_dialog_new (NMSettingIP6Config *s_ip6, gboolean automatic)
 	column = gtk_tree_view_get_column (GTK_TREE_VIEW (widget), offset - 1);
 	gtk_tree_view_column_set_expand (GTK_TREE_VIEW_COLUMN (column), TRUE);
 	gtk_tree_view_column_set_clickable (GTK_TREE_VIEW_COLUMN (column), TRUE);
+	gtk_tree_view_column_set_cell_data_func (column, renderer, cell_error_data_func,
+	                                         GUINT_TO_POINTER (COL_ADDRESS), NULL);
 
 	/* Prefix column */
 	renderer = gtk_cell_renderer_text_new ();
@@ -721,6 +767,8 @@ ip6_routes_dialog_new (NMSettingIP6Config *s_ip6, gboolean automatic)
 	column = gtk_tree_view_get_column (GTK_TREE_VIEW (widget), offset - 1);
 	gtk_tree_view_column_set_expand (GTK_TREE_VIEW_COLUMN (column), TRUE);
 	gtk_tree_view_column_set_clickable (GTK_TREE_VIEW_COLUMN (column), TRUE);
+	gtk_tree_view_column_set_cell_data_func (column, renderer, cell_error_data_func,
+	                                         GUINT_TO_POINTER (COL_PREFIX), NULL);
 
 	/* Gateway column */
 	renderer = gtk_cell_renderer_text_new ();
@@ -738,6 +786,8 @@ ip6_routes_dialog_new (NMSettingIP6Config *s_ip6, gboolean automatic)
 	column = gtk_tree_view_get_column (GTK_TREE_VIEW (widget), offset - 1);
 	gtk_tree_view_column_set_expand (GTK_TREE_VIEW_COLUMN (column), TRUE);
 	gtk_tree_view_column_set_clickable (GTK_TREE_VIEW_COLUMN (column), TRUE);
+	gtk_tree_view_column_set_cell_data_func (column, renderer, cell_error_data_func,
+	                                         GUINT_TO_POINTER (COL_NEXT_HOP), NULL);
 
 	/* Metric column */
 	renderer = gtk_cell_renderer_text_new ();
@@ -755,6 +805,8 @@ ip6_routes_dialog_new (NMSettingIP6Config *s_ip6, gboolean automatic)
 	column = gtk_tree_view_get_column (GTK_TREE_VIEW (widget), offset - 1);
 	gtk_tree_view_column_set_expand (GTK_TREE_VIEW_COLUMN (column), TRUE);
 	gtk_tree_view_column_set_clickable (GTK_TREE_VIEW_COLUMN (column), TRUE);
+	gtk_tree_view_column_set_cell_data_func (column, renderer, cell_error_data_func,
+	                                         GUINT_TO_POINTER (COL_METRIC), NULL);
 
 	g_object_set_data_full (G_OBJECT (dialog), "renderers", renderers, (GDestroyNotify) g_slist_free);
 
@@ -815,13 +867,13 @@ ip6_routes_dialog_update_setting (GtkWidget *dialog, NMSettingIP6Config *s_ip6)
 		NMIP6Route *route;
 
 		/* Address */
-		if (!get_one_addr (model, &tree_iter, COL_ADDRESS, TRUE, &dest)) {
+		if (!get_one_addr (model, &tree_iter, COL_ADDRESS, TRUE, &dest, NULL)) {
 			g_warning ("%s: IPv6 address missing or invalid!", __func__);
 			goto next;
 		}
 
 		/* Prefix */
-		if (   !get_one_int (model, &tree_iter, COL_PREFIX, 128, TRUE, &prefix)
+		if (   !get_one_int (model, &tree_iter, COL_PREFIX, 128, TRUE, &prefix, NULL)
 		    || prefix == 0) {
 			g_warning ("%s: IPv6 prefix missing or invalid!", __func__);
 			goto next;
@@ -829,13 +881,13 @@ ip6_routes_dialog_update_setting (GtkWidget *dialog, NMSettingIP6Config *s_ip6)
 
 		/* Next hop (optional) */
 		memset (&next_hop, 0, sizeof (struct in6_addr));
-		if (!get_one_addr (model, &tree_iter, COL_NEXT_HOP, FALSE, &next_hop)) {
+		if (!get_one_addr (model, &tree_iter, COL_NEXT_HOP, FALSE, &next_hop, NULL)) {
 			g_warning ("%s: IPv6 next hop invalid!", __func__);
 			goto next;
 		}
 
 		/* Metric (optional) */
-		if (!get_one_int (model, &tree_iter, COL_METRIC, G_MAXUINT32, FALSE, &metric)) {
+		if (!get_one_int (model, &tree_iter, COL_METRIC, G_MAXUINT32, FALSE, &metric, NULL)) {
 			g_warning ("%s: IPv6 metric invalid!", __func__);
 			goto next;
 		}
diff --git a/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c b/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
index d264e52..f6a315f 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/page-ip4.c
@@ -44,6 +44,7 @@
 
 #include "page-ip4.h"
 #include "ip4-routes-dialog.h"
+#include "utils.h"
 
 G_DEFINE_TYPE (CEPageIP4, ce_page_ip4, CE_TYPE_PAGE)
 
@@ -659,6 +660,9 @@ parse_netmask (const char *str, guint32 *prefix)
 	struct in_addr tmp_addr;
 	glong tmp_prefix;
 
+	if (!str || !*str)
+		return FALSE;
+
 	errno = 0;
 
 	/* Is it a prefix? */
@@ -886,6 +890,38 @@ tree_view_button_pressed_cb (GtkWidget *widget,
 }
 
 static void
+cell_error_data_func (GtkTreeViewColumn *tree_column,
+                      GtkCellRenderer *cell,
+                      GtkTreeModel *tree_model,
+                      GtkTreeIter *iter,
+                      gpointer data)
+{
+	guint32 col = GPOINTER_TO_UINT (data);
+	char *value = NULL;
+	const char *color = "red";
+	struct in_addr tmp_addr;
+	guint32 prefix;
+	gboolean invalid = FALSE;
+
+	gtk_tree_model_get (tree_model, iter, col, &value, -1);
+
+	if (col == COL_ADDRESS)
+		invalid = !value || !*value || !inet_pton (AF_INET, value, &tmp_addr);
+	else if (col == COL_PREFIX)
+		invalid = !parse_netmask (value, &prefix);
+	else if (col == COL_GATEWAY)
+		invalid = value && *value && !inet_pton (AF_INET, value, &tmp_addr);
+	else
+		g_warn_if_reached ();
+
+	if (invalid)
+		utils_set_cell_background (cell, color, value);
+	else
+		utils_set_cell_background (cell, NULL, NULL);
+	g_free (value);
+}
+
+static void
 finish_setup (CEPageIP4 *self, gpointer unused, GError *error, gpointer user_data)
 {
 	CEPageIP4Private *priv = CE_PAGE_IP4_GET_PRIVATE (self);
@@ -919,6 +955,8 @@ finish_setup (CEPageIP4 *self, gpointer unused, GError *error, gpointer user_dat
 	column = gtk_tree_view_get_column (GTK_TREE_VIEW (priv->addr_list), offset - 1);
 	gtk_tree_view_column_set_expand (GTK_TREE_VIEW_COLUMN (column), TRUE);
 	gtk_tree_view_column_set_clickable (GTK_TREE_VIEW_COLUMN (column), TRUE);
+	gtk_tree_view_column_set_cell_data_func (column, renderer, cell_error_data_func,
+	                                         GUINT_TO_POINTER (COL_ADDRESS), NULL);
 
 	/* Prefix/netmask column */
 	renderer = gtk_cell_renderer_text_new ();
@@ -936,6 +974,8 @@ finish_setup (CEPageIP4 *self, gpointer unused, GError *error, gpointer user_dat
 	column = gtk_tree_view_get_column (GTK_TREE_VIEW (priv->addr_list), offset - 1);
 	gtk_tree_view_column_set_expand (GTK_TREE_VIEW_COLUMN (column), TRUE);
 	gtk_tree_view_column_set_clickable (GTK_TREE_VIEW_COLUMN (column), TRUE);
+	gtk_tree_view_column_set_cell_data_func (column, renderer, cell_error_data_func,
+	                                         GUINT_TO_POINTER (COL_PREFIX), NULL);
 
 	/* Gateway column */
 	renderer = gtk_cell_renderer_text_new ();
@@ -953,6 +993,8 @@ finish_setup (CEPageIP4 *self, gpointer unused, GError *error, gpointer user_dat
 	column = gtk_tree_view_get_column (GTK_TREE_VIEW (priv->addr_list), offset - 1);
 	gtk_tree_view_column_set_expand (GTK_TREE_VIEW_COLUMN (column), TRUE);
 	gtk_tree_view_column_set_clickable (GTK_TREE_VIEW_COLUMN (column), TRUE);
+	gtk_tree_view_column_set_cell_data_func (column, renderer, cell_error_data_func,
+	                                         GUINT_TO_POINTER (COL_GATEWAY), NULL);
 
 	g_signal_connect (priv->addr_list, "button-press-event", G_CALLBACK (tree_view_button_pressed_cb), self);
 
diff --git a/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c b/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c
index adc9a3f..788416c 100644
--- a/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c
+++ b/network-manager-applet-0.8.1/src/connection-editor/page-ip6.c
@@ -44,6 +44,7 @@
 
 #include "page-ip6.h"
 #include "ip6-routes-dialog.h"
+#include "utils.h"
 
 G_DEFINE_TYPE (CEPageIP6, ce_page_ip6, CE_TYPE_PAGE)
 
@@ -430,6 +431,25 @@ populate_ui (CEPageIP6 *self)
 	                              !nm_setting_ip6_config_get_may_fail (setting));
 }
 
+static gboolean
+is_prefix_valid (const char *prefix_str, guint32 *out_prefix)
+{
+	guint32 prefix;
+	char *end;
+
+	if (!prefix_str || !*prefix_str)
+		return FALSE;
+
+	prefix = strtoul (prefix_str, &end, 10);
+	if (!end || *end || prefix == 0 || prefix > 128)
+		return FALSE;
+	else {
+		if (out_prefix)
+			*out_prefix = prefix;
+		return TRUE;
+	}
+}
+
 static void
 addr_add_clicked (GtkButton *button, gpointer user_data)
 {
@@ -644,18 +664,11 @@ cell_changed_cb (GtkEditable *editable,
 
 	cell_text = gtk_editable_get_chars (editable, 0, -1);
 
-	/* The Prefix column is 0..128 */
+	/* The Prefix column is 1..128 */
 	column = GPOINTER_TO_UINT (g_object_get_data (G_OBJECT (user_data), "column"));
-	if (column == COL_PREFIX) {
-		guint32 prefix;
-		char *end;
-
-		prefix = strtoul (cell_text, &end, 10);
-		if (!end || *end || prefix == 0 || prefix > 128)
-			value_valid = FALSE;
-		else
-			value_valid = TRUE;
-	} else {
+	if (column == COL_PREFIX)
+		value_valid = is_prefix_valid (cell_text, NULL);
+	else {
 		struct in6_addr tmp_addr;
 
 		if (inet_pton (AF_INET6, cell_text, &tmp_addr))
@@ -850,6 +863,37 @@ tree_view_button_pressed_cb (GtkWidget *widget,
 }
 
 static void
+cell_error_data_func (GtkTreeViewColumn *tree_column,
+                      GtkCellRenderer *cell,
+                      GtkTreeModel *tree_model,
+                      GtkTreeIter *iter,
+                      gpointer data)
+{
+	guint32 col = GPOINTER_TO_UINT (data);
+	char *value = NULL;
+	const char *color = "red";
+	struct in6_addr tmp_addr;
+	gboolean invalid = FALSE;
+
+	gtk_tree_model_get (tree_model, iter, col, &value, -1);
+
+	if (col == COL_ADDRESS)
+		invalid = !value || !*value || !inet_pton (AF_INET6, value, &tmp_addr);
+	else if (col == COL_PREFIX)
+		invalid = !is_prefix_valid (value, NULL);
+	else if (col == COL_GATEWAY)
+		invalid = value && *value && !inet_pton (AF_INET6, value, &tmp_addr);
+	else
+		g_warn_if_reached ();
+
+	if (invalid)
+		utils_set_cell_background (cell, color, value);
+	else
+		utils_set_cell_background (cell, NULL, NULL);
+	g_free (value);
+}
+
+static void
 finish_setup (CEPageIP6 *self, gpointer unused, GError *error, gpointer user_data)
 {
 	CEPageIP6Private *priv = CE_PAGE_IP6_GET_PRIVATE (self);
@@ -883,6 +927,8 @@ finish_setup (CEPageIP6 *self, gpointer unused, GError *error, gpointer user_dat
 	column = gtk_tree_view_get_column (GTK_TREE_VIEW (priv->addr_list), offset - 1);
 	gtk_tree_view_column_set_expand (GTK_TREE_VIEW_COLUMN (column), TRUE);
 	gtk_tree_view_column_set_clickable (GTK_TREE_VIEW_COLUMN (column), TRUE);
+	gtk_tree_view_column_set_cell_data_func (column, renderer, cell_error_data_func,
+	                                         GUINT_TO_POINTER (COL_ADDRESS), NULL);
 
 	/* Prefix column */
 	renderer = gtk_cell_renderer_text_new ();
@@ -900,6 +946,8 @@ finish_setup (CEPageIP6 *self, gpointer unused, GError *error, gpointer user_dat
 	column = gtk_tree_view_get_column (GTK_TREE_VIEW (priv->addr_list), offset - 1);
 	gtk_tree_view_column_set_expand (GTK_TREE_VIEW_COLUMN (column), TRUE);
 	gtk_tree_view_column_set_clickable (GTK_TREE_VIEW_COLUMN (column), TRUE);
+	gtk_tree_view_column_set_cell_data_func (column, renderer, cell_error_data_func,
+	                                         GUINT_TO_POINTER (COL_PREFIX), NULL);
 
 	/* Gateway column */
 	renderer = gtk_cell_renderer_text_new ();
@@ -917,6 +965,8 @@ finish_setup (CEPageIP6 *self, gpointer unused, GError *error, gpointer user_dat
 	column = gtk_tree_view_get_column (GTK_TREE_VIEW (priv->addr_list), offset - 1);
 	gtk_tree_view_column_set_expand (GTK_TREE_VIEW_COLUMN (column), TRUE);
 	gtk_tree_view_column_set_clickable (GTK_TREE_VIEW_COLUMN (column), TRUE);
+	gtk_tree_view_column_set_cell_data_func (column, renderer, cell_error_data_func,
+	                                         GUINT_TO_POINTER (COL_GATEWAY), NULL);
 
 	g_signal_connect (priv->addr_list, "button-press-event", G_CALLBACK (tree_view_button_pressed_cb), self);
 
@@ -1056,7 +1106,7 @@ ui_to_setting (CEPageIP6 *self)
 	model = gtk_tree_view_get_model (priv->addr_list);
 	iter_valid = gtk_tree_model_get_iter_first (model, &tree_iter);
 	while (iter_valid) {
-		char *item = NULL, *end;
+		char *item = NULL;
 		struct in6_addr tmp_addr, tmp_gw;
 		gboolean have_gw = FALSE;
 		NMIP6Address *addr;
@@ -1074,16 +1124,11 @@ ui_to_setting (CEPageIP6 *self)
 
 		/* Prefix */
 		gtk_tree_model_get (model, &tree_iter, COL_PREFIX, &item, -1);
-		if (!item) {
-			g_warning ("%s: IPv6 prefix '%s' missing!",
-			           __func__, item ? item : "<none>");
-			goto out;
-		}
-
-		prefix = strtoul (item, &end, 10);
-		if (!end || *end || prefix == 0 || prefix > 128) {
-			g_warning ("%s: IPv6 prefix '%s' invalid!",
-			           __func__, item ? item : "<none>");
+		if (!is_prefix_valid (item, &prefix)) {
+			if (!item)
+				g_warning ("%s: IPv6 prefix missing!", __func__);
+			else
+				g_warning ("%s: IPv6 prefix '%s' invalid!", __func__, item);
 			g_free (item);
 			goto out;
 		}
diff --git a/network-manager-applet-0.8.1/src/utils/utils.c b/network-manager-applet-0.8.1/src/utils/utils.c
index 051b2bf..2d9381a 100644
--- a/network-manager-applet-0.8.1/src/utils/utils.c
+++ b/network-manager-applet-0.8.1/src/utils/utils.c
@@ -827,3 +827,26 @@ utils_escape_notify_message (const char *src)
 
 	return g_string_free (escaped, FALSE);
 }
+
+void
+utils_set_cell_background (GtkCellRenderer *cell,
+                           const char *color,
+                           const char *value)
+{
+	if (color) {
+		if (!value || !*value) {
+			g_object_set (G_OBJECT (cell),
+			              "cell-background-set", TRUE,
+			              "cell-background", color,
+			              NULL);
+		} else {
+			char *markup;
+			markup = g_markup_printf_escaped ("<span background='%s'>%s</span>",
+			                                  color, value);
+			g_object_set (G_OBJECT (cell), "markup", markup, NULL);
+			g_free (markup);
+			g_object_set (G_OBJECT (cell), "cell-background-set", FALSE, NULL);
+		}
+	} else
+		g_object_set (G_OBJECT (cell), "cell-background-set", FALSE, NULL);
+}
diff --git a/network-manager-applet-0.8.1/src/utils/utils.h b/network-manager-applet-0.8.1/src/utils/utils.h
index 6f0411f..750d139 100644
--- a/network-manager-applet-0.8.1/src/utils/utils.h
+++ b/network-manager-applet-0.8.1/src/utils/utils.h
@@ -24,6 +24,7 @@
 #define UTILS_H
 
 #include <glib.h>
+#include <gtk/gtk.h>
 #include <nm-connection.h>
 #include <nm-device.h>
 #include <net/ethernet.h>
@@ -64,5 +65,9 @@ typedef enum  {
 	NMA_ERROR_GENERIC
 } NMAError;
 
+void utils_set_cell_background (GtkCellRenderer *cell,
+                                const char *color,
+                                const char *value);
+
 #endif /* UTILS_H */
 
-- 
2.1.0

