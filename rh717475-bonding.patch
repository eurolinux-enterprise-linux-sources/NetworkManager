Author: Dan Williams <dcbw@redhat.com>
Date:   Sat Mar 3 10:04:49 2012 -0600
Subject: [PATCH] backport bonding functionality to RHEL6 (rh #717475)

Oddities with the RHEL6 kernel's bonding implementation include delayed
carrier notifications after bringing device up, and that SIOCBONDENSLAVE
doesn't work at all since it doesn't update the bond master's MAC address
when adding the first slave, so we call back to using sysfs to add bond slaves.

---
diff --git a/cli/src/connections.c b/cli/src/connections.c
index 025e96e..c14d943 100644
--- a/cli/src/connections.c
+++ b/cli/src/connections.c
@@ -39,6 +39,7 @@
 #include <nm-setting-bluetooth.h>
 #include <nm-setting-olpc-mesh.h>
 #include <nm-setting-infiniband.h>
+#include <nm-device-bond.h>
 #include <nm-device-ethernet.h>
 #include <nm-device-wifi.h>
 #include <nm-gsm-device.h>
@@ -110,6 +111,7 @@ static NmcOutputField nmc_fields_settings_names[] = {
 	SETTING_FIELD (NM_SETTING_OLPC_MESH_SETTING_NAME, 0),             /* 13 */
 	SETTING_FIELD (NM_SETTING_VPN_SETTING_NAME, 0),                   /* 14 */
 	SETTING_FIELD (NM_SETTING_INFINIBAND_SETTING_NAME, 0),            /* 15 */
+	SETTING_FIELD (NM_SETTING_BOND_SETTING_NAME, 0),                  /* 16 */
 	{NULL, NULL, 0, NULL, 0}
 };
 #define NMC_FIELDS_SETTINGS_NAMES_ALL    NM_SETTING_CONNECTION_SETTING_NAME","\
@@ -127,7 +129,8 @@ static NmcOutputField nmc_fields_settings_names[] = {
                                          NM_SETTING_BLUETOOTH_SETTING_NAME","\
                                          NM_SETTING_OLPC_MESH_SETTING_NAME","\
                                          NM_SETTING_VPN_SETTING_NAME"," \
-                                         NM_SETTING_INFINIBAND_SETTING_NAME
+                                         NM_SETTING_INFINIBAND_SETTING_NAME"," \
+                                         NM_SETTING_BOND_SETTING_NAME
 
 
 typedef struct {
@@ -366,6 +369,15 @@ nmc_connection_detail (NMConnection *connection, NmCli *nmc)
 				continue;
 			}
 		}
+
+		if (!strcasecmp (nmc_fields_settings_names[section_idx].name, nmc_fields_settings_names[16].name)) {
+			setting = nm_connection_get_setting (connection, NM_TYPE_SETTING_BOND);
+			if (setting) {
+				setting_bond_details (setting, nmc);
+				was_output = TRUE;
+				continue;
+			}
+		}
 	}
 
 	if (print_settings_array)
@@ -944,6 +956,44 @@ check_infiniband_compatible (NMDeviceInfiniband *device, NMConnection *connectio
 }
 
 static gboolean
+check_bond_compatible (NMDeviceBond *device, NMConnection *connection, GError **error)
+{
+	NMSettingConnection *s_con;
+	NMSettingBond *s_bond;
+	const char *connection_type;
+	const char *dev_iface_name, *bond_iface_name;
+
+	g_return_val_if_fail (error == NULL || *error == NULL, FALSE);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+
+	connection_type = nm_setting_connection_get_connection_type (s_con);
+	if (strcmp (connection_type, NM_SETTING_BOND_SETTING_NAME)) {
+		g_set_error (error, 0, 0,
+		             "The connection was not an Bond connection.");
+		return FALSE;
+	}
+
+	s_bond = nm_connection_get_setting_bond (connection);
+	if (!s_bond) {
+		g_set_error (error, 0, 0,
+		             "The connection was not a valid Bond connection.");
+		return FALSE;
+	}
+
+	dev_iface_name = nm_device_get_iface (NM_DEVICE (device));
+	bond_iface_name = nm_setting_bond_get_interface_name (s_bond);
+	if (g_strcmp0 (dev_iface_name, bond_iface_name) != 0) {
+		g_set_error (error, 0, 0,
+		             "The connection's and device's interface names did not match.");
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static gboolean
 nm_device_is_connection_compatible (NMDevice *device, NMConnection *connection, GError **error)
 {
 	g_return_val_if_fail (NM_IS_DEVICE (device), FALSE);
@@ -959,6 +1009,8 @@ nm_device_is_connection_compatible (NMDevice *device, NMConnection *connection,
 //		return check_olpc_mesh_compatible (NM_DEVICE_OLPC_MESH (device), connection, error);
 	else if (NM_IS_DEVICE_INFINIBAND (device))
 		return check_infiniband_compatible (NM_DEVICE_INFINIBAND (device), connection, error);
+	else if (NM_IS_DEVICE_BOND (device))
+		return check_bond_compatible (NM_DEVICE_BOND (device), connection, error);
 
 	g_set_error (error, 0, 0, "unhandled device type '%s'", G_OBJECT_TYPE_NAME (device));
 	return FALSE;
@@ -1387,6 +1439,7 @@ do_connection_up (NmCli *nmc, int argc, char **argv)
 	gboolean id_specified = FALSE;
 	gboolean wait = TRUE;
 	GError *error = NULL;
+	gboolean is_virtual = FALSE;
 
 	/* Set default timeout for connection activation. It can take quite a long time.
 	 * Using 90 seconds.
@@ -1472,9 +1525,12 @@ do_connection_up (NmCli *nmc, int argc, char **argv)
 	g_assert (s_con);
 	con_type = nm_setting_connection_get_connection_type (s_con);
 
-	device_found = find_device_for_connection (nmc, connection, iface, ap, &device, &spec_object, &error);
+	if (nm_connection_is_type (connection, NM_SETTING_BOND_SETTING_NAME))
+		is_virtual = TRUE;
 
-	if (!device_found) {
+	device_found = find_device_for_connection (nmc, connection, iface, ap, &device, &spec_object, &error);
+	/* Virtual connections may not have had their devices created yet */
+	if (!device_found && !is_virtual) {
 		if (error)
 			g_string_printf (nmc->return_text, _("Error: No suitable device found: %s."), error->message);
 		else
diff --git a/cli/src/devices.c b/cli/src/devices.c
index 9668f99..e8e557a 100644
--- a/cli/src/devices.c
+++ b/cli/src/devices.c
@@ -40,6 +40,7 @@
 #include <nm-device-bt.h>
 //#include <nm-device-olpc-mesh.h>
 #include <nm-device-infiniband.h>
+#include <nm-device-bond.h>
 #include <nm-utils.h>
 #include <nm-setting-ip4-config.h>
 #include <nm-setting-ip6-config.h>
@@ -53,6 +54,7 @@
 #include <nm-setting-bluetooth.h>
 #include <nm-setting-olpc-mesh.h>
 #include <nm-setting-infiniband.h>
+#include <nm-setting-bond.h>
 
 #include "utils.h"
 #include "devices.h"
@@ -267,6 +269,8 @@ get_device_type (NMDevice * device)
 //		return NM_SETTING_OLPC_MESH_SETTING_NAME;
 	else if (NM_IS_DEVICE_INFINIBAND (device))
 		return NM_SETTING_INFINIBAND_SETTING_NAME;
+	else if (NM_IS_DEVICE_BOND (device))
+		return NM_SETTING_BOND_SETTING_NAME;
 	else
 		return _("Unknown");
 }
@@ -526,6 +530,8 @@ show_device_info (gpointer data, gpointer user_data)
 				hwaddr = nm_device_wifi_get_hw_address (NM_DEVICE_WIFI (device));
 			else if (NM_IS_DEVICE_INFINIBAND (device))
 				hwaddr = nm_device_infiniband_get_hw_address (NM_DEVICE_INFINIBAND (device));
+			else if (NM_IS_DEVICE_BOND (device))
+				hwaddr = nm_device_bond_get_hw_address (NM_DEVICE_BOND (device));
 
 			nmc->allowed_fields[0].value = nmc_fields_dev_list_sections[0].name;  /* "GENERAL"*/
 			nmc->allowed_fields[1].value = nm_device_get_iface (device);
diff --git a/cli/src/settings.c b/cli/src/settings.c
index 62354a8..3d6699c 100644
--- a/cli/src/settings.c
+++ b/cli/src/settings.c
@@ -422,6 +422,18 @@ static NmcOutputField nmc_fields_setting_infiniband[] = {
                                               NM_SETTING_INFINIBAND_TRANSPORT_MODE
 #define NMC_FIELDS_SETTING_INFINIBAND_COMMON  NMC_FIELDS_SETTING_INFINIBAND_ALL
 
+/* Available fields for NM_SETTING_BOND_SETTING_NAME */
+static NmcOutputField nmc_fields_setting_bond[] = {
+	SETTING_FIELD ("name",  8),                                        /* 0 */
+	SETTING_FIELD (NM_SETTING_BOND_INTERFACE_NAME, 15),                /* 1 */
+	SETTING_FIELD (NM_SETTING_BOND_OPTIONS, 30),                       /* 2 */
+	{NULL, NULL, 0, NULL, 0}
+};
+#define NMC_FIELDS_SETTING_BOND_ALL     "name"","\
+                                        NM_SETTING_BOND_INTERFACE_NAME","\
+                                        NM_SETTING_BOND_OPTIONS
+#define NMC_FIELDS_SETTING_BOND_COMMON  NMC_FIELDS_SETTING_BOND_ALL
+
 
 static char *
 wep_key_type_to_string (NMWepKeyType type)
@@ -1439,3 +1451,42 @@ setting_infiniband_details (NMSetting *setting, NmCli *nmc)
 	return TRUE;
 }
 
+gboolean
+setting_bond_details (NMSetting *setting, NmCli *nmc)
+{
+	NMSettingBond *s_bond;
+	GString *bond_options_s;
+	int i;
+	guint32 mode_flag = (nmc->print_output == NMC_PRINT_PRETTY) ? NMC_PF_FLAG_PRETTY : (nmc->print_output == NMC_PRINT_TERSE) ? NMC_PF_FLAG_TERSE : 0;
+	guint32 multiline_flag = nmc->multiline_output ? NMC_PF_FLAG_MULTILINE : 0;
+	guint32 escape_flag = nmc->escape_values ? NMC_PF_FLAG_ESCAPE : 0;
+
+	g_return_val_if_fail (NM_IS_SETTING_BOND (setting), FALSE);
+	s_bond = (NMSettingBond *) setting;
+
+	nmc->allowed_fields = nmc_fields_setting_bond;
+	nmc->print_fields.indices = parse_output_fields (NMC_FIELDS_SETTING_BOND_ALL, nmc->allowed_fields, NULL);
+	nmc->print_fields.flags = multiline_flag | mode_flag | escape_flag | NMC_PF_FLAG_FIELD_NAMES;
+	print_fields (nmc->print_fields, nmc->allowed_fields);  /* Print field names */
+
+	bond_options_s = g_string_new (NULL);
+	for (i = 0; i < nm_setting_bond_get_num_options (s_bond); i++) {
+		const char *key, *value;
+
+		nm_setting_bond_get_option (s_bond, i, &key, &value);
+		g_string_append_printf (bond_options_s, "%s=%s,", key, value);
+	}
+	g_string_truncate (bond_options_s, bond_options_s->len-1);  /* chop off trailing ',' */
+
+	nmc->allowed_fields[0].value = NM_SETTING_BOND_SETTING_NAME;
+	nmc->allowed_fields[1].value = nm_setting_bond_get_interface_name (s_bond);
+	nmc->allowed_fields[2].value = bond_options_s->str;
+
+	nmc->print_fields.flags = multiline_flag | mode_flag | escape_flag | NMC_PF_FLAG_SECTION_PREFIX;
+	print_fields (nmc->print_fields, nmc->allowed_fields); /* Print values */
+
+	g_string_free (bond_options_s, TRUE);
+
+	return TRUE;
+}
+
diff --git a/cli/src/settings.h b/cli/src/settings.h
index f18b331..590005e 100644
--- a/cli/src/settings.h
+++ b/cli/src/settings.h
@@ -36,6 +36,7 @@
 #include <nm-setting-olpc-mesh.h>
 #include <nm-setting-vpn.h>
 #include <nm-setting-infiniband.h>
+#include <nm-setting-bond.h>
 
 #include "nmcli.h"
 #include "utils.h"
@@ -57,5 +58,6 @@ gboolean setting_bluetooth_details (NMSetting *setting, NmCli *nmc);
 gboolean setting_olpc_mesh_details (NMSetting *setting, NmCli *nmc);
 gboolean setting_vpn_details (NMSetting *setting, NmCli *nmc);
 gboolean setting_infiniband_details (NMSetting *setting, NmCli *nmc);
+gboolean setting_bond_details (NMSetting *setting, NmCli *nmc);
 
 #endif /* NMC_SETTINGS_H */
diff --git a/docs/generate-settings-spec.c b/docs/generate-settings-spec.c
index 850e203..95dcc24 100644
--- a/docs/generate-settings-spec.c
+++ b/docs/generate-settings-spec.c
@@ -31,6 +31,7 @@
 
 #include <nm-setting-8021x.h>
 #include <nm-setting-bluetooth.h>
+#include <nm-setting-bond.h>
 #include <nm-setting-cdma.h>
 #include <nm-setting-connection.h>
 #include <nm-setting-gsm.h>
@@ -54,6 +55,7 @@ typedef NMSetting* (*SettingNewFunc) (void);
 static SettingNewFunc funcs[] = {
 	nm_setting_802_1x_new,
 	nm_setting_bluetooth_new,
+	nm_setting_bond_new,
 	nm_setting_cdma_new,
 	nm_setting_connection_new,
 	nm_setting_gsm_new,
diff --git a/docs/libnm-glib/Makefile.am b/docs/libnm-glib/Makefile.am
index 24b89f1..19e9968 100644
--- a/docs/libnm-glib/Makefile.am
+++ b/docs/libnm-glib/Makefile.am
@@ -40,6 +40,7 @@ IGNORE_HFILES= \
 	nm-active-connection-bindings.h \
 	nm-client-bindings.h \
 	nm-device-bindings.h \
+	nm-device-bond-bindings.h \
 	nm-device-bt-bindings.h \
 	nm-device-ethernet-bindings.h \
 	nm-device-wifi-bindings.h \
diff --git a/docs/libnm-glib/libnm-glib-docs.sgml b/docs/libnm-glib/libnm-glib-docs.sgml
index 70b94d5..4d7a16f 100644
--- a/docs/libnm-glib/libnm-glib-docs.sgml
+++ b/docs/libnm-glib/libnm-glib-docs.sgml
@@ -21,6 +21,7 @@
     <xi:include href="xml/nm-serial-device.xml"/>
     <xi:include href="xml/nm-gsm-device.xml"/>
     <xi:include href="xml/nm-cdma-device.xml"/>
+    <xi:include href="xml/nm-device-bond.xml"/>
     <xi:include href="xml/nm-device-bt.xml"/>
     <xi:include href="xml/nm-device-infiniband.xml"/>
     <xi:include href="xml/nm-access-point.xml"/>
diff --git a/docs/libnm-util/libnm-util-docs.sgml b/docs/libnm-util/libnm-util-docs.sgml
index 395588a..bbf18f2 100644
--- a/docs/libnm-util/libnm-util-docs.sgml
+++ b/docs/libnm-util/libnm-util-docs.sgml
@@ -23,6 +23,7 @@
     <xi:include href="xml/nm-setting-wireless.xml"/>
     <xi:include href="xml/nm-setting-wireless-security.xml"/>
     <xi:include href="xml/nm-setting-bluetooth.xml"/>
+    <xi:include href="xml/nm-setting-bond.xml"/>
     <xi:include href="xml/nm-setting-serial.xml"/>
     <xi:include href="xml/nm-setting-cdma.xml"/>
     <xi:include href="xml/nm-setting-gsm.xml"/>
diff --git a/docs/libnm-glib/tmpl/nm-device-bond.sgml b/docs/libnm-glib/tmpl/nm-device-bond.sgml
new file mode 100644
index 0000000..7548b72
--- /dev/null
+++ b/docs/libnm-glib/tmpl/nm-device-bond.sgml
@@ -0,0 +1,95 @@
+<!-- ##### SECTION Title ##### -->
+NMDeviceBond
+
+<!-- ##### SECTION Short_Description ##### -->
+
+
+<!-- ##### SECTION Long_Description ##### -->
+<para>
+
+</para>
+
+
+<!-- ##### SECTION See_Also ##### -->
+<para>
+
+</para>
+
+
+<!-- ##### SECTION Stability_Level ##### -->
+
+
+<!-- ##### SECTION Image ##### -->
+
+
+<!-- ##### STRUCT NMDeviceBond ##### -->
+<para>
+
+</para>
+
+
+<!-- ##### ARG NMDeviceBond:carrier ##### -->
+<para>
+
+</para>
+
+<!-- ##### ARG NMDeviceBond:hw-address ##### -->
+<para>
+
+</para>
+
+<!-- ##### STRUCT NMDeviceBondClass ##### -->
+<para>
+
+</para>
+
+@parent: 
+@_reserved1: 
+@_reserved2: 
+@_reserved3: 
+@_reserved4: 
+@_reserved5: 
+@_reserved6: 
+
+<!-- ##### MACRO NM_DEVICE_BOND_CARRIER ##### -->
+<para>
+
+</para>
+
+
+
+<!-- ##### MACRO NM_DEVICE_BOND_HW_ADDRESS ##### -->
+<para>
+
+</para>
+
+
+
+<!-- ##### FUNCTION nm_device_bond_get_carrier ##### -->
+<para>
+
+</para>
+
+@device: 
+@Returns: 
+
+
+<!-- ##### FUNCTION nm_device_bond_get_hw_address ##### -->
+<para>
+
+</para>
+
+@device: 
+@Returns: 
+
+
+<!-- ##### FUNCTION nm_device_bond_new ##### -->
+<para>
+
+</para>
+
+@connection: 
+@path: 
+@Returns: 
+
+
diff --git a/docs/libnm-glib/libnm-glib.types b/docs/libnm-glib/libnm-glib.types
index 99783ba..16efa63 100644
--- a/docs/libnm-glib/libnm-glib.types
+++ b/docs/libnm-glib/libnm-glib.types
@@ -1,6 +1,9 @@
 #include <nm-client.h>
 #include <nm-device-ethernet.h>
 #include <nm-device-wifi.h>
+#include <nm-device-infiniband.h>
+#include <nm-device-bond.h>
+#include <nm-device-vlan.h>
 #include <nm-cdma-device.h>
 #include <nm-gsm-device.h>
 #include <nm-serial-device.h>
@@ -15,6 +18,9 @@ nm_client_get_type
 nm_device_get_type
 nm_device_ethernet_get_type
 nm_device_wifi_get_type
+nm_device_infiniband_get_type
+nm_device_bond_get_type
+nm_device_vlan_get_type
 nm_gsm_device_get_type
 nm_cdma_device_get_type
 nm_serial_device_get_type
diff --git a/docs/libnm-glib/libnm-glib-sections.txt b/docs/libnm-glib/libnm-glib-sections.txt
index 6171547..7ef3384 100644
--- a/docs/libnm-glib/libnm-glib-sections.txt
+++ b/docs/libnm-glib/libnm-glib-sections.txt
@@ -382,6 +404,26 @@ NM_DEVICE_GET_CLASS
 </SECTION>
 
 <SECTION>
+<FILE>nm-device-bond</FILE>
+<TITLE>NMDeviceBond</TITLE>
+NMDeviceBond
+NMDeviceBondClass
+NM_DEVICE_BOND_CARRIER
+NM_DEVICE_BOND_HW_ADDRESS
+nm_device_bond_get_carrier
+nm_device_bond_get_hw_address
+nm_device_bond_new
+<SUBSECTION Standard>
+NM_DEVICE_BOND
+NM_DEVICE_BOND_CLASS
+NM_DEVICE_BOND_GET_CLASS
+NM_IS_DEVICE_BOND
+NM_IS_DEVICE_BOND_CLASS
+NM_TYPE_DEVICE_BOND
+nm_device_bond_get_type
+</SECTION>
+
+<SECTION>
 <FILE>nm-device-ethernet</FILE>
 <TITLE>NMDeviceEthernet</TITLE>
 NM_DEVICE_ETHERNET_HW_ADDRESS
diff --git a/include/NetworkManager.h b/include/NetworkManager.h
index 7abb430..1852997 100644
--- a/include/NetworkManager.h
+++ b/include/NetworkManager.h
@@ -44,6 +44,7 @@
 #define NM_DBUS_INTERFACE_IP6_CONFIG        NM_DBUS_INTERFACE ".IP6Config"
 #define NM_DBUS_INTERFACE_DHCP6_CONFIG      NM_DBUS_INTERFACE ".DHCP6Config"
 #define NM_DBUS_INTERFACE_DEVICE_INFINIBAND NM_DBUS_INTERFACE_DEVICE ".Infiniband"
+#define NM_DBUS_INTERFACE_DEVICE_BOND       NM_DBUS_INTERFACE_DEVICE ".Bond"
 
 
 #define NM_DBUS_SERVICE_USER_SETTINGS     "org.freedesktop.NetworkManagerUserSettings"
@@ -83,6 +84,7 @@ typedef enum NMDeviceType
 	NM_DEVICE_TYPE_BT,  /* Bluetooth */
 	NM_DEVICE_TYPE_OLPC_MESH,
 	NM_DEVICE_TYPE_INFINIBAND = 9,
+	NM_DEVICE_TYPE_BOND = 10,
 } NMDeviceType;
 
 /* DEPRECATED TYPE NAMES */
@@ -377,6 +379,9 @@ typedef enum {
 	/* InfiniBand device does not support connected mode */
 	NM_DEVICE_STATE_REASON_INFINIBAND_MODE = 49,
 
+	/* A dependency of the connection failed */
+	NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED = 50,
+
 	/* Unused */
 	NM_DEVICE_STATE_REASON_LAST = 0xFFFF
 } NMDeviceStateReason;
diff --git a/introspection/Makefile.am b/introspection/Makefile.am
index 97b72bd..98d1e08 100644
--- a/introspection/Makefile.am
+++ b/introspection/Makefile.am
@@ -8,6 +8,7 @@ EXTRA_DIST = \
 	nm-device-wifi.xml \
 	nm-device-olpc-mesh.xml \
 	nm-device-ethernet.xml \
+	nm-device-bond.xml \
 	nm-device-cdma.xml \
 	nm-device-gsm.xml \
 	nm-device-infiniband.xml \
diff --git a/introspection/all.xml b/introspection/all.xml
index 5787286..83a7eaf 100644
--- a/introspection/all.xml
+++ b/introspection/all.xml
@@ -36,6 +36,7 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</
 <xi:include href="nm-device-bt.xml"/>
 <xi:include href="nm-device-olpc-mesh.xml"/>
 <xi:include href="nm-device-infiniband.xml"/>
+<xi:include href="nm-device-bond.xml"/>
 <xi:include href="nm-ip4-config.xml"/>
 <xi:include href="nm-ip6-config.xml"/>
 <xi:include href="nm-dhcp4-config.xml"/>
diff --git a/introspection/nm-active-connection.xml b/introspection/nm-active-connection.xml
index 765830a..97f91da 100644
--- a/introspection/nm-active-connection.xml
+++ b/introspection/nm-active-connection.xml
@@ -26,6 +26,9 @@
     <property name="Vpn" type="b" access="read">
       <tp:docstring>Whether this active connection is also a VPN connection.</tp:docstring>
     </property>
+    <property name="Master" type="o" access="read">
+      <tp:docstring>The path to the master device if the connection is a slave.</tp:docstring>
+    </property>
 
     <signal name="PropertiesChanged">
         <arg name="properties" type="a{sv}" tp:type="String_Variant_Map">
diff --git a/introspection/nm-device-bond.xml b/introspection/nm-device-bond.xml
new file mode 100644
index 0000000..9d200ef
--- /dev/null
+++ b/introspection/nm-device-bond.xml
@@ -0,0 +1,27 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<node name="/" xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0">
+  <interface name="org.freedesktop.NetworkManager.Device.Bond">
+
+    <property name="HwAddress" type="s" access="read">
+      <tp:docstring>
+        Hardware address of the device.
+      </tp:docstring>
+    </property>
+
+    <property name="Carrier" type="b" access="read">
+      <tp:docstring>
+        Indicates whether the physical carrier is found (e.g. whether a cable is plugged in or not).
+      </tp:docstring>
+    </property>
+
+    <signal name="PropertiesChanged">
+        <arg name="properties" type="a{sv}" tp:type="String_Variant_Map">
+            <tp:docstring>
+                A dictionary mapping property names to variant boxed values
+            </tp:docstring>
+        </arg>
+    </signal>
+
+  </interface>
+</node>
diff --git a/introspection/nm-device.xml b/introspection/nm-device.xml
index e0324ca..cc9cc91 100644
--- a/introspection/nm-device.xml
+++ b/introspection/nm-device.xml
@@ -182,6 +182,11 @@
           The device is an IP-capable InfiniBand interface.
         </tp:docstring>
       </tp:enumvalue>
+      <tp:enumvalue suffix="BOND" value="10">
+        <tp:docstring>
+          The device is a bond master interface.
+        </tp:docstring>
+      </tp:enumvalue>
     </tp:enum>
 
     <tp:flags name="NM_DEVICE_CAP" value-prefix="NM_DEVICE_CAP" type="u">
@@ -427,6 +432,11 @@
           InfiniBand device does not support connected mode.
         </tp:docstring>
       </tp:enumvalue>
+      <tp:enumvalue suffix="DEPENDENCY_FAILED" value="50">
+        <tp:docstring>
+          A dependency of the connection failed.
+        </tp:docstring>
+      </tp:enumvalue>
     </tp:enum>
 
   </interface>
diff --git a/libnm-glib/Makefile.am b/libnm-glib/Makefile.am
index 20dfa1e..d11428b 100644
--- a/libnm-glib/Makefile.am
+++ b/libnm-glib/Makefile.am
@@ -11,6 +11,7 @@ BUILT_SOURCES = \
 	nm-device-infiniband-bindings.h \
 	nm-device-wifi-bindings.h \
 	nm-device-bt-bindings.h \
+	nm-device-bond-bindings.h \
 	nm-exported-connection-glue.h \
 	nm-exported-connection-bindings.h \
 	nm-settings-glue.h \
@@ -67,6 +68,7 @@ libnminclude_HEADERS = \
 	nm-device-infiniband.h \
 	nm-device-wifi.h \
 	nm-device-bt.h \
+	nm-device-bond.h \
 	nm-access-point.h \
 	nm-ip4-config.h \
 	nm-gsm-device.h \
@@ -101,6 +103,7 @@ libnm_glib_la_SOURCES = \
 	nm-device-infiniband.c \
 	nm-device-wifi.c \
 	nm-device-bt.c \
+	nm-device-bond.c \
 	nm-access-point.c \
 	nm-ip4-config.c \
 	nm-gsm-device.c \
@@ -169,6 +172,9 @@ nm-device-wifi-bindings.h: $(top_srcdir)/introspection/nm-device-wifi.xml
 nm-device-bt-bindings.h: $(top_srcdir)/introspection/nm-device-bt.xml
 	$(AM_V_GEN) dbus-binding-tool --prefix=nm_device_bt --mode=glib-client --output=$@ $<
 
+nm-device-bond-bindings.h: $(top_srcdir)/introspection/nm-device-bond.xml
+	$(AM_V_GEN) dbus-binding-tool --prefix=nm_device_bond --mode=glib-client --output=$@ $<
+
 nm-access-point-bindings.h: $(top_srcdir)/introspection/nm-access-point.xml
 	$(AM_V_GEN) dbus-binding-tool --prefix=nm_access_point --mode=glib-client --output=$@ $<
 
diff --git a/libnm-glib/libnm-glib.ver b/libnm-glib/libnm-glib.ver
index 55424c0..18d6b1d 100644
--- a/libnm-glib/libnm-glib.ver
+++ b/libnm-glib/libnm-glib.ver
@@ -55,12 +55,16 @@ global:
 	nm_dbus_settings_system_get_type;
 	nm_dbus_settings_system_get_unmanaged_devices;
 	nm_dbus_settings_system_new;
-	nm_device_disconnect;
+	nm_device_bond_get_carrier;
+	nm_device_bond_get_hw_address;
+	nm_device_bond_get_type;
+	nm_device_bond_new;
 	nm_device_bt_new;
 	nm_device_bt_get_capabilities;
 	nm_device_bt_get_hw_address;
 	nm_device_bt_get_name;
 	nm_device_bt_get_type;
+	nm_device_disconnect;
 	nm_device_ethernet_get_carrier;
 	nm_device_ethernet_get_hw_address;
 	nm_device_ethernet_get_permanent_hw_address;
diff --git a/libnm-glib/nm-client.c b/libnm-glib/nm-client.c
index 88fe15b..28e9487 100644
--- a/libnm-glib/nm-client.c
+++ b/libnm-glib/nm-client.c
@@ -1013,19 +1013,13 @@ nm_client_activate_connection (NMClient *client,
 					  gpointer user_data)
 {
 	ActivateDeviceInfo *info;
-	char *internal_so = (char *) specific_object;
 
 	g_return_if_fail (NM_IS_CLIENT (client));
-	g_return_if_fail (NM_IS_DEVICE (device));
+	if (device)
+		g_return_if_fail (NM_IS_DEVICE (device));
 	g_return_if_fail (service_name != NULL);
 	g_return_if_fail (connection_path != NULL);
 
-	/* NULL specific object must be translated into "/" because D-Bus does
-	 * not have any idea of NULL object paths.
-	 */
-	if (internal_so == NULL)
-		internal_so = "/";
-
 	info = g_slice_new (ActivateDeviceInfo);
 	info->fn = callback;
 	info->user_data = user_data;
@@ -1033,8 +1027,8 @@ nm_client_activate_connection (NMClient *client,
 	org_freedesktop_NetworkManager_activate_connection_async (NM_CLIENT_GET_PRIVATE (client)->client_proxy,
 											    service_name,
 											    connection_path,
-											    nm_object_get_path (NM_OBJECT (device)),
-											    internal_so,
+											    device ? nm_object_get_path (NM_OBJECT (device)) : "/",
+											    specific_object ? specific_object : "/",
 											    activate_cb,
 											    info);
 }
diff --git a/libnm-glib/nm-device-bond.c b/libnm-glib/nm-device-bond.c
new file mode 100644
index 0000000..94a872b
--- /dev/null
+++ b/libnm-glib/nm-device-bond.c
@@ -0,0 +1,265 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/*
+ * libnm_glib -- Access network status & information from glib applications
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2007 - 2008 Novell, Inc.
+ * Copyright (C) 2007 - 2011 Red Hat, Inc.
+ */
+
+#include <config.h>
+#include <string.h>
+#include <netinet/ether.h>
+
+#include <nm-setting-connection.h>
+#include <nm-setting-bond.h>
+#include <nm-utils.h>
+
+#include "nm-device-bond.h"
+#include "nm-device-private.h"
+#include "nm-object-private.h"
+
+G_DEFINE_TYPE (NMDeviceBond, nm_device_bond, NM_TYPE_DEVICE)
+
+#define NM_DEVICE_BOND_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DEVICE_BOND, NMDeviceBondPrivate))
+
+typedef struct {
+	DBusGProxy *proxy;
+
+	char *hw_address;
+	gboolean carrier;
+	gboolean carrier_valid;
+} NMDeviceBondPrivate;
+
+enum {
+	PROP_0,
+	PROP_HW_ADDRESS,
+	PROP_CARRIER,
+
+	LAST_PROP
+};
+
+#define DBUS_PROP_HW_ADDRESS "HwAddress"
+#define DBUS_PROP_CARRIER "Carrier"
+
+/**
+ * nm_device_bond_new:
+ * @connection: the #DBusGConnection
+ * @path: the DBus object path of the device
+ *
+ * Creates a new #NMDeviceBond.
+ *
+ * Returns: (transfer full): a new device
+ **/
+GObject *
+nm_device_bond_new (DBusGConnection *connection, const char *path)
+{
+	g_return_val_if_fail (connection != NULL, NULL);
+	g_return_val_if_fail (path != NULL, NULL);
+
+	return g_object_new (NM_TYPE_DEVICE_BOND,
+	                     NM_OBJECT_DBUS_CONNECTION, connection,
+	                     NM_OBJECT_DBUS_PATH, path,
+	                     NULL);
+}
+
+/**
+ * nm_device_bond_get_hw_address:
+ * @device: a #NMDeviceBond
+ *
+ * Gets the hardware (MAC) address of the #NMDeviceBond
+ *
+ * Returns: the hardware address. This is the internal string used by the
+ * device, and must not be modified.
+ **/
+const char *
+nm_device_bond_get_hw_address (NMDeviceBond *device)
+{
+	NMDeviceBondPrivate *priv;
+
+	g_return_val_if_fail (NM_IS_DEVICE_BOND (device), NULL);
+
+	priv = NM_DEVICE_BOND_GET_PRIVATE (device);
+	if (!priv->hw_address) {
+		priv->hw_address = _nm_object_get_string_property (NM_OBJECT (device),
+														   NM_DBUS_INTERFACE_DEVICE_BOND,
+														   DBUS_PROP_HW_ADDRESS);
+	}
+
+	return priv->hw_address;
+}
+
+/**
+ * nm_device_bond_get_carrier:
+ * @device: a #NMDeviceBond
+ *
+ * Whether the device has carrier.
+ *
+ * Returns: %TRUE if the device has carrier
+ **/
+gboolean
+nm_device_bond_get_carrier (NMDeviceBond *device)
+{
+	NMDeviceBondPrivate *priv;
+
+	g_return_val_if_fail (NM_IS_DEVICE_BOND (device), FALSE);
+
+	priv = NM_DEVICE_BOND_GET_PRIVATE (device);
+	if (!priv->carrier_valid) {
+		priv->carrier = _nm_object_get_boolean_property (NM_OBJECT (device),
+														 NM_DBUS_INTERFACE_DEVICE_BOND,
+														 DBUS_PROP_CARRIER);
+		priv->carrier_valid = TRUE;
+	}
+
+	return priv->carrier;
+}
+
+/***********************************************************/
+
+static void
+nm_device_bond_init (NMDeviceBond *device)
+{
+}
+
+static void
+register_for_property_changed (NMDeviceBond *device)
+{
+	NMDeviceBondPrivate *priv = NM_DEVICE_BOND_GET_PRIVATE (device);
+	const NMPropertiesChangedInfo property_changed_info[] = {
+		{ NM_DEVICE_BOND_HW_ADDRESS, _nm_object_demarshal_generic, &priv->hw_address },
+		{ NM_DEVICE_BOND_CARRIER,    _nm_object_demarshal_generic, &priv->carrier },
+		{ NULL },
+	};
+
+	_nm_object_handle_properties_changed (NM_OBJECT (device),
+	                                      priv->proxy,
+	                                      property_changed_info);
+}
+
+static GObject*
+constructor (GType type,
+             guint n_construct_params,
+             GObjectConstructParam *construct_params)
+{
+	GObject *object;
+	NMDeviceBondPrivate *priv;
+
+	object = G_OBJECT_CLASS (nm_device_bond_parent_class)->constructor (type,
+	                                                                    n_construct_params,
+	                                                                    construct_params);
+	if (!object)
+		return NULL;
+
+	priv = NM_DEVICE_BOND_GET_PRIVATE (object);
+
+	priv->proxy = dbus_g_proxy_new_for_name (nm_object_get_connection (NM_OBJECT (object)),
+	                                         NM_DBUS_SERVICE,
+	                                         nm_object_get_path (NM_OBJECT (object)),
+	                                         NM_DBUS_INTERFACE_DEVICE_BOND);
+
+	register_for_property_changed (NM_DEVICE_BOND (object));
+
+	return object;
+}
+
+static void
+dispose (GObject *object)
+{
+	NMDeviceBondPrivate *priv = NM_DEVICE_BOND_GET_PRIVATE (object);
+
+	if (priv->proxy) {
+		g_object_unref (priv->proxy);
+		priv->proxy = NULL;
+	}
+
+	G_OBJECT_CLASS (nm_device_bond_parent_class)->dispose (object);
+}
+
+static void
+finalize (GObject *object)
+{
+	NMDeviceBondPrivate *priv = NM_DEVICE_BOND_GET_PRIVATE (object);
+
+	g_free (priv->hw_address);
+
+	G_OBJECT_CLASS (nm_device_bond_parent_class)->finalize (object);
+}
+
+static void
+get_property (GObject *object,
+              guint prop_id,
+              GValue *value,
+              GParamSpec *pspec)
+{
+	NMDeviceBond *device = NM_DEVICE_BOND (object);
+
+	switch (prop_id) {
+	case PROP_HW_ADDRESS:
+		g_value_set_string (value, nm_device_bond_get_hw_address (device));
+		break;
+	case PROP_CARRIER:
+		g_value_set_boolean (value, nm_device_bond_get_carrier (device));
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+nm_device_bond_class_init (NMDeviceBondClass *eth_class)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (eth_class);
+
+	g_type_class_add_private (eth_class, sizeof (NMDeviceBondPrivate));
+
+	/* virtual methods */
+	object_class->constructor = constructor;
+	object_class->dispose = dispose;
+	object_class->finalize = finalize;
+	object_class->get_property = get_property;
+
+	/* properties */
+
+	/**
+	 * NMDeviceBond:hw-address:
+	 *
+	 * The hardware (MAC) address of the device.
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_HW_ADDRESS,
+		 g_param_spec_string (NM_DEVICE_BOND_HW_ADDRESS,
+		                      "Active MAC Address",
+		                      "Currently set hardware MAC address",
+		                      NULL,
+		                      G_PARAM_READABLE));
+
+	/**
+	 * NMDeviceBond:carrier:
+	 *
+	 * Whether the device has carrier.
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_CARRIER,
+		 g_param_spec_boolean (NM_DEVICE_BOND_CARRIER,
+		                       "Carrier",
+		                       "Carrier",
+		                       FALSE,
+		                       G_PARAM_READABLE));
+
+}
diff --git a/libnm-glib/nm-device-bond.h b/libnm-glib/nm-device-bond.h
new file mode 100644
index 0000000..097a204
--- /dev/null
+++ b/libnm-glib/nm-device-bond.h
@@ -0,0 +1,66 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/*
+ * libnm_glib -- Access network status & information from glib applications
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2007 - 2008 Novell, Inc.
+ * Copyright (C) 2007 - 2011 Red Hat, Inc.
+ */
+
+#ifndef NM_DEVICE_BOND_H
+#define NM_DEVICE_BOND_H
+
+#include "nm-device.h"
+
+G_BEGIN_DECLS
+
+#define NM_TYPE_DEVICE_BOND            (nm_device_bond_get_type ())
+#define NM_DEVICE_BOND(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DEVICE_BOND, NMDeviceBond))
+#define NM_DEVICE_BOND_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_DEVICE_BOND, NMDeviceBondClass))
+#define NM_IS_DEVICE_BOND(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_DEVICE_BOND))
+#define NM_IS_DEVICE_BOND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_DEVICE_BOND))
+#define NM_DEVICE_BOND_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_DEVICE_BOND, NMDeviceBondClass))
+
+#define NM_DEVICE_BOND_HW_ADDRESS  "hw-address"
+#define NM_DEVICE_BOND_CARRIER     "carrier"
+
+typedef struct {
+	NMDevice parent;
+} NMDeviceBond;
+
+typedef struct {
+	NMDeviceClass parent;
+
+	/* Padding for future expansion */
+	void (*_reserved1) (void);
+	void (*_reserved2) (void);
+	void (*_reserved3) (void);
+	void (*_reserved4) (void);
+	void (*_reserved5) (void);
+	void (*_reserved6) (void);
+} NMDeviceBondClass;
+
+GType nm_device_bond_get_type (void);
+
+GObject *nm_device_bond_new (DBusGConnection *connection, const char *path);
+
+const char * nm_device_bond_get_hw_address (NMDeviceBond *device);
+gboolean     nm_device_bond_get_carrier (NMDeviceBond *device);
+
+G_END_DECLS
+
+#endif /* NM_DEVICE_BOND_H */
diff --git a/libnm-glib/nm-device.c b/libnm-glib/nm-device.c
index c96def8..6c010e7 100644
--- a/libnm-glib/nm-device.c
+++ b/libnm-glib/nm-device.c
@@ -33,6 +33,7 @@
 #include "nm-cdma-device.h"
 #include "nm-device-bt.h"
 #include "nm-device-infiniband.h"
+#include "nm-device-bond.h"
 #include "nm-device.h"
 #include "nm-device-private.h"
 #include "nm-object-private.h"
@@ -713,6 +714,9 @@ nm_device_new (DBusGConnection *connection, const char *path)
 	case NM_DEVICE_TYPE_INFINIBAND:
 		dtype = NM_TYPE_DEVICE_INFINIBAND;
 		break;
+	case NM_DEVICE_TYPE_BOND:
+		dtype = NM_TYPE_DEVICE_BOND;
+		break;
 	default:
 		g_warning ("Unknown device type %d", g_value_get_uint (&value));
 		break;
diff --git a/libnm-util/Makefile.am b/libnm-util/Makefile.am
index 9202561..c611261 100644
--- a/libnm-util/Makefile.am
+++ b/libnm-util/Makefile.am
@@ -15,6 +15,7 @@ libnm_util_include_HEADERS = 		\
 	nm-setting.h			\
 	nm-setting-8021x.h		\
 	nm-setting-bluetooth.h		\
+	nm-setting-bond.h		\
 	nm-setting-connection.h		\
 	nm-setting-infiniband.h		\
 	nm-setting-ip4-config.h		\
@@ -40,6 +41,7 @@ libnm_util_la_SOURCES=			\
 	nm-setting.c			\
 	nm-setting-8021x.c		\
 	nm-setting-bluetooth.c		\
+	nm-setting-bond.c		\
 	nm-setting-connection.c		\
 	nm-setting-infiniband.c		\
 	nm-setting-ip4-config.c		\
diff --git a/libnm-util/libnm-util.ver b/libnm-util/libnm-util.ver
index 4c16477..086ade5 100644
--- a/libnm-util/libnm-util.ver
+++ b/libnm-util/libnm-util.ver
@@ -10,9 +10,17 @@ global:
 	nm_connection_error_quark;
 	nm_connection_for_each_setting_value;
 	nm_connection_get_path;
+	nm_connection_get_virtual_iface_name;
+	nm_connection_get_uuid;
+	nm_connection_get_id;
+	nm_connection_is_type;
 	nm_connection_get_scope;
 	nm_connection_get_setting;
 	nm_connection_get_setting_by_name;
+	nm_connection_get_setting_connection;
+	nm_connection_get_setting_ip4_config;
+	nm_connection_get_setting_bond;
+	nm_connection_get_setting_wired;
 	nm_connection_get_type;
 	nm_connection_lookup_setting_type;
 	nm_connection_lookup_setting_type_by_quark;
@@ -97,6 +105,18 @@ global:
 	nm_setting_bluetooth_new;
 	nm_setting_bluetooth_get_bdaddr;
 	nm_setting_bluetooth_get_connection_type;
+	nm_setting_bond_error_get_type;
+	nm_setting_bond_error_quark;
+	nm_setting_bond_get_type;
+	nm_setting_bond_new;
+	nm_setting_bond_get_interface_name;
+	nm_setting_bond_get_num_options;
+	nm_setting_bond_get_option;
+	nm_setting_bond_get_option_by_name;
+	nm_setting_bond_get_option_default;
+	nm_setting_bond_get_valid_options;
+	nm_setting_bond_add_option;
+	nm_setting_bond_remove_option;
 	nm_setting_cdma_error_get_type;
 	nm_setting_cdma_error_quark;
 	nm_setting_cdma_get_type;
@@ -116,6 +136,9 @@ global:
 	nm_setting_connection_get_autoconnect;
 	nm_setting_connection_get_timestamp;
 	nm_setting_connection_get_read_only;
+	nm_setting_connection_get_master;
+	nm_setting_connection_get_slave_type;
+	nm_setting_connection_is_slave_type;
 	nm_setting_duplicate;
 	nm_setting_enumerate_values;
 	nm_setting_error_get_type;
@@ -123,6 +146,7 @@ global:
 	nm_setting_new_from_hash;
 	nm_setting_get_name;
 	nm_setting_get_type;
+	nm_setting_get_virtual_iface_name;
 	nm_setting_gsm_error_get_type;
 	nm_setting_gsm_error_quark;
 	nm_setting_gsm_get_type;
diff --git a/libnm-util/nm-connection.c b/libnm-util/nm-connection.c
index 6a04ce6..23a1052 100644
--- a/libnm-util/nm-connection.c
+++ b/libnm-util/nm-connection.c
@@ -32,6 +32,7 @@
 
 #include "nm-setting-8021x.h"
 #include "nm-setting-bluetooth.h"
+#include "nm-setting-bond.h"
 #include "nm-setting-connection.h"
 #include "nm-setting-infiniband.h"
 #include "nm-setting-ip4-config.h"
@@ -142,7 +143,7 @@ static guint signals[LAST_SIGNAL] = { 0 };
 
 static GHashTable *registered_settings = NULL;
 
-#define DEFAULT_MAP_SIZE 16
+#define DEFAULT_MAP_SIZE 17
 
 static struct SettingInfo {
 	const char *name;
@@ -243,6 +244,11 @@ register_default_settings (void)
 	                      NM_SETTING_INFINIBAND_ERROR,
 	                      1);
 
+	register_one_setting (NM_SETTING_BOND_SETTING_NAME,
+	                      NM_TYPE_SETTING_BOND,
+	                      NM_SETTING_BOND_ERROR,
+	                      1);
+
 	register_one_setting (NM_SETTING_WIRELESS_SECURITY_SETTING_NAME,
 	                      NM_TYPE_SETTING_WIRELESS_SECURITY,
 	                      NM_SETTING_WIRELESS_SECURITY_ERROR,
@@ -473,6 +479,101 @@ nm_connection_get_setting_by_name (NMConnection *connection, const char *name)
 }
 
 /**
+ * nm_connection_get_type_setting:
+ * @connection: a #NMConnection
+ *
+ * Returns: (transfer none): the #NMSetting of the connection base type
+ */
+static NMSetting *
+nm_connection_get_type_setting (NMConnection *connection)
+{
+	NMSettingConnection *s_con;
+	const char *type;
+	NMSetting *base;
+
+	g_return_val_if_fail (NM_IS_CONNECTION (connection), NULL);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+
+	type = nm_setting_connection_get_connection_type (s_con);
+	g_assert (type);
+
+	base = nm_connection_get_setting_by_name (connection, type);
+	g_assert (base);
+
+	return base;
+}
+
+/**
+ * nm_connection_get_setting_connection:
+ * @connection: the #NMConnection
+ *
+ * A shortcut to return any #NMSettingConnection the connection might contain.
+ *
+ * Returns: (transfer none): an #NMSettingConnection if the connection contains one, otherwise NULL
+ **/
+NMSettingConnection *
+nm_connection_get_setting_connection (NMConnection *connection)
+{
+	g_return_val_if_fail (connection != NULL, NULL);
+	g_return_val_if_fail (NM_IS_CONNECTION (connection), NULL);
+
+	return (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
+}
+
+/**
+ * nm_connection_get_setting_ip4_config:
+ * @connection: the #NMConnection
+ *
+ * A shortcut to return any #NMSettingIP4Config the connection might contain.
+ *
+ * Returns: (transfer none): an #NMSettingIP4Config if the connection contains one, otherwise NULL
+ **/
+NMSettingIP4Config *
+nm_connection_get_setting_ip4_config (NMConnection *connection)
+{
+	g_return_val_if_fail (connection != NULL, NULL);
+	g_return_val_if_fail (NM_IS_CONNECTION (connection), NULL);
+
+	return (NMSettingIP4Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG);
+}
+
+/**
+ * nm_connection_get_setting_bond:
+ * @connection: the #NMConnection
+ *
+ * A shortcut to return any #NMSettingBond the connection might contain.
+ *
+ * Returns: (transfer none): an #NMSettingBond if the connection contains one, otherwise NULL
+ **/
+NMSettingBond *
+nm_connection_get_setting_bond (NMConnection *connection)
+{
+	g_return_val_if_fail (connection != NULL, NULL);
+	g_return_val_if_fail (NM_IS_CONNECTION (connection), NULL);
+
+	return (NMSettingBond *) nm_connection_get_setting (connection, NM_TYPE_SETTING_BOND);
+}
+
+/**
+ * nm_connection_get_setting_wired:
+ * @connection: the #NMConnection
+ *
+ * A shortcut to return any #NMSettingWired the connection might contain.
+ *
+ * Returns: (transfer none): an #NMSettingWired if the connection contains one, otherwise NULL
+ **/
+NMSettingWired *
+nm_connection_get_setting_wired (NMConnection *connection)
+{
+	g_return_val_if_fail (connection != NULL, NULL);
+	g_return_val_if_fail (NM_IS_CONNECTION (connection), NULL);
+
+	return (NMSettingWired *) nm_connection_get_setting (connection, NM_TYPE_SETTING_WIRED);
+}
+
+/**
  * nm_connection_replace_settings:
  * @connection: a #NMConnection
  * @new_settings: a #GHashTable of settings
@@ -832,6 +933,37 @@ nm_connection_to_hash (NMConnection *connection)
 	return connection_hash;
 }
 
+/**
+ * nm_connection_is_type:
+ * @connection: the #NMConnection
+ * @type: a setting name to check the connection's type against (like 
+ * %NM_SETTING_WIRELESS_SETTING_NAME or %NM_SETTING_WIRED_SETTING_NAME)
+ *
+ * A convenience function to check if the given @connection is a particular
+ * type (ie wired, wifi, ppp, etc). Checks the #NMSettingConnection:type
+ * property of the connection and matches that against @type.
+ *
+ * Returns: %TRUE if the connection is of the given @type, %FALSE if not
+ **/
+gboolean
+nm_connection_is_type (NMConnection *connection, const char *type)
+{
+	NMSettingConnection *s_con;
+	const char *type2;
+
+	g_return_val_if_fail (connection != NULL, FALSE);
+	g_return_val_if_fail (NM_IS_CONNECTION (connection), FALSE);
+	g_return_val_if_fail (type != NULL, FALSE);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+
+	type2 = nm_setting_connection_get_connection_type (s_con);
+	g_assert (type2);
+
+	return !strcmp (type2, type);
+}
+
 typedef struct ForEachValueInfo {
 	NMSettingValueIterFn func;
 	gpointer user_data;
@@ -989,6 +1121,30 @@ nm_connection_get_path (NMConnection *connection)
 }
 
 /**
+ * nm_connection_get_virtual_iface_name:
+ * @connection: The #NMConnection
+ *
+ * Returns the name of the virtual kernel interface which the connection
+ * needs to use if specified in the settings. This function abstracts all
+ * connection types which require this functionality. For all other
+ * connection types, this function will return NULL.
+ *
+ * Returns: Name of the kernel interface or NULL
+ */
+const char *
+nm_connection_get_virtual_iface_name (NMConnection *connection)
+{
+	NMSetting *base;
+
+	g_return_val_if_fail (NM_IS_CONNECTION (connection), NULL);
+
+	base = nm_connection_get_type_setting (connection);
+	g_assert (base);
+
+	return nm_setting_get_virtual_iface_name (base);
+}
+
+/**
  * nm_connection_new:
  *
  * Creates a new #NMConnection object with no #NMSetting objects.
@@ -1068,6 +1224,50 @@ nm_connection_duplicate (NMConnection *connection)
 	return dup;
 }
 
+/**
+ * nm_connection_get_uuid:
+ * @connection: the #NMConnection
+ *
+ * A shortcut to return the UUID from the connection's #NMSettingConnection.
+ *
+ * Returns: the UUID from the connection's 'connection' setting
+ **/
+const char *
+nm_connection_get_uuid (NMConnection *connection)
+{
+	NMSettingConnection *s_con;
+
+	g_return_val_if_fail (connection != NULL, NULL);
+	g_return_val_if_fail (NM_IS_CONNECTION (connection), NULL);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_return_val_if_fail (s_con != NULL, NULL);
+
+	return nm_setting_connection_get_uuid (s_con);
+}
+
+/**
+ * nm_connection_get_id:
+ * @connection: the #NMConnection
+ *
+ * A shortcut to return the ID from the connection's #NMSettingConnection.
+ *
+ * Returns: the ID from the connection's 'connection' setting
+ **/
+const char *
+nm_connection_get_id (NMConnection *connection)
+{
+	NMSettingConnection *s_con;
+
+	g_return_val_if_fail (connection != NULL, NULL);
+	g_return_val_if_fail (NM_IS_CONNECTION (connection), NULL);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_return_val_if_fail (s_con != NULL, NULL);
+
+	return nm_setting_connection_get_id (s_con);
+}
+
 static void
 nm_connection_init (NMConnection *connection)
 {
diff --git a/libnm-util/nm-connection.h b/libnm-util/nm-connection.h
index 576db04..b47972b 100644
--- a/libnm-util/nm-connection.h
+++ b/libnm-util/nm-connection.h
@@ -30,6 +30,11 @@
 #include <glib-object.h>
 #include <nm-setting.h>
 
+#include <nm-setting-connection.h>
+#include <nm-setting-ip4-config.h>
+#include <nm-setting-bond.h>
+#include <nm-setting-wired.h>
+
 G_BEGIN_DECLS
 
 #define NM_TYPE_CONNECTION            (nm_connection_get_type ())
@@ -149,6 +154,10 @@ void             nm_connection_set_path (NMConnection *connection,
 
 const char *     nm_connection_get_path (NMConnection *connection);
 
+const char *  nm_connection_get_virtual_iface_name (NMConnection *connection);
+
+gboolean      nm_connection_is_type (NMConnection *connection, const char *type);
+
 void          nm_connection_for_each_setting_value (NMConnection *connection,
 										  NMSettingValueIterFn func,
 										  gpointer user_data);
@@ -162,6 +171,15 @@ GType nm_connection_lookup_setting_type (const char *name);
 
 GType nm_connection_lookup_setting_type_by_quark (GQuark error_quark);
 
+const char *  nm_connection_get_uuid      (NMConnection *connection);
+
+const char *  nm_connection_get_id        (NMConnection *connection);
+
+NMSettingConnection *      nm_connection_get_setting_connection        (NMConnection *connection);
+NMSettingIP4Config *       nm_connection_get_setting_ip4_config        (NMConnection *connection);
+NMSettingBond *            nm_connection_get_setting_bond              (NMConnection *connection);
+NMSettingWired *           nm_connection_get_setting_wired             (NMConnection *connection);
+
 G_END_DECLS
 
 #endif /* NM_CONNECTION_H */
diff --git a/libnm-util/nm-setting-bond.c b/libnm-util/nm-setting-bond.c
new file mode 100644
index 0000000..50cad2d
--- /dev/null
+++ b/libnm-util/nm-setting-bond.c
@@ -0,0 +1,534 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+
+/*
+ * Thomas Graf <tgraf@redhat.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2011 - 2012 Red Hat, Inc.
+ */
+
+#include <string.h>
+#include <ctype.h>
+#include <dbus/dbus-glib.h>
+
+#include "nm-setting-bond.h"
+#include "nm-param-spec-specialized.h"
+#include "nm-utils.h"
+#include "nm-utils-private.h"
+#include "nm-dbus-glib-types.h"
+
+/**
+ * SECTION:nm-setting-bond
+ * @short_description: Describes connection properties for bonds
+ * @include: nm-setting-bond.h
+ *
+ * The #NMSettingBond object is a #NMSetting subclass that describes properties
+ * necessary for bond connections.
+ **/
+
+/**
+ * nm_setting_bond_error_quark:
+ *
+ * Registers an error quark for #NMSettingBond if necessary.
+ *
+ * Returns: the error quark used for #NMSettingBond errors.
+ **/
+GQuark
+nm_setting_bond_error_quark (void)
+{
+	static GQuark quark;
+
+	if (G_UNLIKELY (!quark))
+		quark = g_quark_from_static_string ("nm-setting-bond-error-quark");
+	return quark;
+}
+
+
+G_DEFINE_TYPE (NMSettingBond, nm_setting_bond, NM_TYPE_SETTING)
+
+#define NM_SETTING_BOND_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_SETTING_BOND, NMSettingBondPrivate))
+
+typedef struct {
+	char *interface_name;
+	GHashTable *options;
+} NMSettingBondPrivate;
+
+enum {
+	PROP_0,
+	PROP_INTERFACE_NAME,
+	PROP_OPTIONS,
+	LAST_PROP
+};
+
+typedef struct {
+	const char *opt;
+	const char *val;
+} BondDefault;
+
+static const BondDefault defaults[] = {
+	{ NM_SETTING_BOND_OPTION_MODE,          "balance-rr" },
+	{ NM_SETTING_BOND_OPTION_MIIMON,        "100"        },
+	{ NM_SETTING_BOND_OPTION_DOWNDELAY,     "0"          },
+	{ NM_SETTING_BOND_OPTION_UPDELAY,       "0"          },
+	{ NM_SETTING_BOND_OPTION_ARP_INTERVAL,  "0"          },
+	{ NM_SETTING_BOND_OPTION_ARP_IP_TARGET, ""           },
+};
+
+/**
+ * nm_setting_bond_new:
+ *
+ * Creates a new #NMSettingBond object with default values.
+ *
+ * Returns: (transfer full): the new empty #NMSettingBond object
+ **/
+NMSetting *
+nm_setting_bond_new (void)
+{
+	return (NMSetting *) g_object_new (NM_TYPE_SETTING_BOND, NULL);
+}
+
+/**
+ * nm_setting_bond_get_interface_name
+ * @setting: the #NMSettingBond
+ *
+ * Returns: the #NMSettingBond:interface-name property of the setting
+ **/
+const char *
+nm_setting_bond_get_interface_name (NMSettingBond *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_BOND (setting), 0);
+
+	return NM_SETTING_BOND_GET_PRIVATE (setting)->interface_name;
+}
+
+/**
+ * nm_setting_bond_get_num_options:
+ * @setting: the #NMSettingBond
+ *
+ * Returns the number of options that should be set for this bond when it
+ * is activated. This can be used to retrieve each option individually
+ * using nm_setting_bond_get_option().
+ *
+ * Returns: the number of bonding options
+ **/
+guint32
+nm_setting_bond_get_num_options (NMSettingBond *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_BOND (setting), 0);
+
+	return g_hash_table_size (NM_SETTING_BOND_GET_PRIVATE (setting)->options);
+}
+
+/**
+ * nm_setting_bond_get_option:
+ * @setting: the #NMSettingBond
+ * @idx: index of the desired option, from 0 to
+ * nm_setting_bond_get_num_options() - 1
+ * @out_name: (out): on return, the name of the bonding option; this
+ * value is owned by the setting and should not be modified
+ * @out_value: (out): on return, the value of the name of the bonding
+ * option; this value is owned by the setting and should not be modified
+ *
+ * Given an index, return the value of the bonding option at that index.  Indexes
+ * are *not* guaranteed to be static across modifications to options done by
+ * nm_setting_bond_add_option() and nm_setting_bond_remove_option(),
+ * and should not be used to refer to options except for short periods of time
+ * such as during option iteration.
+ *
+ * Returns: %TRUE on success if the index was valid and an option was found,
+ * %FALSE if the index was invalid (ie, greater than the number of options
+ * currently held by the setting)
+ **/
+gboolean
+nm_setting_bond_get_option (NMSettingBond *setting,
+                            guint32 idx,
+                            const char **out_name,
+                            const char **out_value)
+{
+	NMSettingBondPrivate *priv;
+	GList *keys;
+	const char *_key = NULL, *_value = NULL;
+
+	g_return_val_if_fail (NM_IS_SETTING_BOND (setting), FALSE);
+
+	priv = NM_SETTING_BOND_GET_PRIVATE (setting);
+
+	if (idx >= nm_setting_bond_get_num_options (setting))
+		return FALSE;
+
+	keys = g_hash_table_get_keys (priv->options);
+	_key = g_list_nth_data (keys, idx);
+	_value = g_hash_table_lookup (priv->options, _key);
+
+	if (out_name)
+		*out_name = _key;
+	if (out_value)
+		*out_value = _value;
+
+	g_list_free (keys);
+	return TRUE;
+}
+
+static gboolean
+validate_option (const char *name)
+{
+	guint i;
+
+	g_return_val_if_fail (name != NULL, FALSE);
+	g_return_val_if_fail (name[0] != '\0', FALSE);
+
+	for (i = 0; i < G_N_ELEMENTS (defaults); i++) {
+		if (g_strcmp0 (defaults[i].opt, name) == 0)
+			return TRUE;
+	}
+	return FALSE;
+}
+
+/**
+ * nm_setting_bond_get_option_by_name:
+ * @setting: the #NMSettingBond
+ * @name: the option name for which to retrieve the value
+ *
+ * Returns the value associated with the bonding option specified by
+ * @name, if it exists.
+ *
+ * Returns: the value, or %NULL if the key/value pair was never added to the
+ * setting; the value is owned by the setting and must not be modified
+ **/
+const char *
+nm_setting_bond_get_option_by_name (NMSettingBond *setting,
+                                    const char *name)
+{
+	g_return_val_if_fail (NM_IS_SETTING_BOND (setting), NULL);
+	g_return_val_if_fail (validate_option (name), NULL);
+
+	return g_hash_table_lookup (NM_SETTING_BOND_GET_PRIVATE (setting)->options, name);
+}
+
+/**
+ * nm_setting_bond_add_option:
+ * @setting: the #NMSettingBond
+ * @name: name for the option
+ * @value: value for the option
+ *
+ * Add an option to the table.  The option is compared to an internal list
+ * of allowed options.  Option names may contain only alphanumeric characters
+ * (ie [a-zA-Z0-9]).  Adding a new name replaces any existing name/value pair
+ * that may already exist.
+ *
+ * Returns: %TRUE if the option was valid and was added to the internal option
+ * list, %FALSE if it was not.
+ **/
+gboolean nm_setting_bond_add_option (NMSettingBond *setting,
+                                     const char *name,
+                                     const char *value)
+{
+	size_t value_len;
+
+	g_return_val_if_fail (NM_IS_SETTING_BOND (setting), FALSE);
+	g_return_val_if_fail (validate_option (name), FALSE);
+	g_return_val_if_fail (value != NULL, FALSE);
+
+	value_len = strlen (value);
+	g_return_val_if_fail (value_len > 0 && value_len < 200, FALSE);
+
+	g_hash_table_insert (NM_SETTING_BOND_GET_PRIVATE (setting)->options,
+	                     g_strdup (name), g_strdup (value));
+	return TRUE;
+}
+
+/**
+ * nm_setting_bond_remove_option:
+ * @setting: the #NMSettingBond
+ * @name: name of the option to remove
+ *
+ * Remove the bonding option referenced by @name from the internal option
+ * list.
+ *
+ * Returns: %TRUE if the option was found and removed from the internal option
+ * list, %FALSE if it was not.
+ **/
+gboolean
+nm_setting_bond_remove_option (NMSettingBond *setting,
+                               const char *name)
+{
+	g_return_val_if_fail (NM_IS_SETTING_BOND (setting), FALSE);
+	g_return_val_if_fail (validate_option (name), FALSE);
+
+	return g_hash_table_remove (NM_SETTING_BOND_GET_PRIVATE (setting)->options, name);
+}
+
+/**
+ * nm_setting_bond_get_valid_options:
+ * @setting: the #NMSettingBond
+ *
+ * Returns a list of valid bond options.
+ *
+ * Returns: a NULL-terminated array of strings of valid bond options.
+ **/
+const char **
+nm_setting_bond_get_valid_options  (NMSettingBond *setting)
+{
+	static const char *array[G_N_ELEMENTS (defaults) + 1] = { NULL };
+	int i;
+
+	/* initialize the array once */
+	if (G_UNLIKELY (array[0] == NULL)) {
+		for (i = 0; i < G_N_ELEMENTS (defaults); i++)
+			array[i] = defaults[i].opt;
+		array[i] = NULL;
+	}
+	return array;
+}
+
+/**
+ * nm_setting_bond_get_option_default:
+ * @setting: the #NMSettingBond
+ * @name: the name of the option
+ *
+ * Returns: the value of the bond option if not overridden by an entry in
+ *   the #NMSettingBond:options property.
+ **/
+const char *
+nm_setting_bond_get_option_default (NMSettingBond *setting, const char *name)
+{
+	guint i;
+
+	g_return_val_if_fail (NM_IS_SETTING_BOND (setting), NULL);
+	g_return_val_if_fail (validate_option (name), NULL);
+
+	for (i = 0; i < G_N_ELEMENTS (defaults); i++) {
+		if (g_strcmp0 (defaults[i].opt, name) == 0)
+			return defaults[i].val;
+	}
+	/* Any option that passes validate_option() should also be found in defaults */
+	g_assert_not_reached ();
+}
+
+/*
+ * This function is a 1:1 copy of the kernel's
+ * dev_valid_name() in net/core/dev.c
+ */
+static gboolean
+dev_valid_name(const char *name)
+{
+	if (*name == '\0')
+		return FALSE;
+
+	if (strlen (name) >= 16)
+		return FALSE;
+
+	if (!strcmp (name, ".") || !strcmp (name, ".."))
+		return FALSE;
+
+	while (*name) {
+		if (*name == '/' || isspace (*name))
+			return FALSE;
+		name++;
+	}
+
+	return TRUE;
+}
+
+static gboolean
+verify (NMSetting *setting, GSList *all_settings, GError **error)
+{
+	NMSettingBondPrivate *priv = NM_SETTING_BOND_GET_PRIVATE (setting);
+	GHashTableIter iter;
+	const char *key, *value;
+	const char *valid_modes[] = { "balance-rr",
+	                              "active-backup",
+	                              "balance-xor",
+	                              "broadcast",
+	                              "802.3ad",
+	                              "balance-tlb",
+	                              "balance-alb",
+	                              NULL };
+
+	if (!priv->interface_name || !strlen(priv->interface_name)) {
+		g_set_error (error,
+		             NM_SETTING_BOND_ERROR,
+		             NM_SETTING_BOND_ERROR_MISSING_PROPERTY,
+		             NM_SETTING_BOND_INTERFACE_NAME);
+		return FALSE;
+	}
+
+	if (!dev_valid_name (priv->interface_name)) {
+		g_set_error (error,
+		             NM_SETTING_BOND_ERROR,
+		             NM_SETTING_BOND_ERROR_INVALID_PROPERTY,
+		             NM_SETTING_BOND_INTERFACE_NAME);
+		return FALSE;
+	}
+
+	g_hash_table_iter_init (&iter, priv->options);
+	while (g_hash_table_iter_next (&iter, (gpointer) &key, (gpointer) &value)) {
+		if (   !validate_option (key)
+		    || !value[0]
+		    || (strlen (value) > 200)) {
+			g_set_error (error,
+			             NM_SETTING_BOND_ERROR,
+			             NM_SETTING_BOND_ERROR_INVALID_PROPERTY,
+			             NM_SETTING_BOND_OPTIONS);
+			return FALSE;
+		}
+
+		if (   (g_strcmp0 (key, "mode") == 0)
+		    && !_nm_utils_string_in_list (value, valid_modes)) {
+			g_set_error (error,
+			             NM_SETTING_BOND_ERROR,
+			             NM_SETTING_BOND_ERROR_INVALID_PROPERTY,
+			             NM_SETTING_BOND_OPTIONS);
+			return FALSE;
+		}
+
+		/* XXX: Validate arp-ip-target */
+	}
+
+	return TRUE;
+}
+
+static const char *
+get_virtual_iface_name (NMSetting *setting)
+{
+	NMSettingBond *self = NM_SETTING_BOND (setting);
+
+	return nm_setting_bond_get_interface_name (self);
+}
+
+static void
+nm_setting_bond_init (NMSettingBond *setting)
+{
+	NMSettingBondPrivate *priv = NM_SETTING_BOND_GET_PRIVATE (setting);
+
+	g_object_set (setting, NM_SETTING_NAME, NM_SETTING_BOND_SETTING_NAME,
+	              NULL);
+
+	priv->options = g_hash_table_new_full (g_str_hash, g_str_equal, g_free, g_free);
+
+	/* Default values: */
+	nm_setting_bond_add_option (setting, NM_SETTING_BOND_OPTION_MIIMON, "100");
+}
+
+static void
+finalize (GObject *object)
+{
+	NMSettingBondPrivate *priv = NM_SETTING_BOND_GET_PRIVATE (object);
+
+	g_free (priv->interface_name);
+	g_hash_table_destroy (priv->options);
+
+	G_OBJECT_CLASS (nm_setting_bond_parent_class)->finalize (object);
+}
+
+static void
+copy_hash (gpointer key, gpointer value, gpointer user_data)
+{
+	g_hash_table_insert ((GHashTable *) user_data, g_strdup (key), g_strdup (value));
+}
+
+static void
+set_property (GObject *object, guint prop_id,
+              const GValue *value, GParamSpec *pspec)
+{
+	NMSettingBondPrivate *priv = NM_SETTING_BOND_GET_PRIVATE (object);
+	GHashTable *new_hash;
+
+	switch (prop_id) {
+	case PROP_INTERFACE_NAME:
+		priv->interface_name = g_value_dup_string (value);
+		break;
+	case PROP_OPTIONS:
+		/* Must make a deep copy of the hash table here... */
+		g_hash_table_remove_all (priv->options);
+		new_hash = g_value_get_boxed (value);
+		if (new_hash)
+			g_hash_table_foreach (new_hash, copy_hash, priv->options);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+get_property (GObject *object, guint prop_id,
+              GValue *value, GParamSpec *pspec)
+{
+	NMSettingBondPrivate *priv = NM_SETTING_BOND_GET_PRIVATE (object);
+	NMSettingBond *setting = NM_SETTING_BOND (object);
+
+	switch (prop_id) {
+	case PROP_INTERFACE_NAME:
+		g_value_set_string (value, nm_setting_bond_get_interface_name (setting));
+		break;
+	case PROP_OPTIONS:
+		g_value_set_boxed (value, priv->options);
+        break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+nm_setting_bond_class_init (NMSettingBondClass *setting_class)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (setting_class);
+	NMSettingClass *parent_class = NM_SETTING_CLASS (setting_class);
+
+	g_type_class_add_private (setting_class, sizeof (NMSettingBondPrivate));
+
+	/* virtual methods */
+	object_class->set_property = set_property;
+	object_class->get_property = get_property;
+	object_class->finalize     = finalize;
+	parent_class->verify       = verify;
+	parent_class->get_virtual_iface_name = get_virtual_iface_name;
+
+	/* Properties */
+	/**
+	 * NMSettingBond:interface-name:
+	 *
+	 * The name of the virtual in-kernel bonding network interface
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_INTERFACE_NAME,
+		 g_param_spec_string (NM_SETTING_BOND_INTERFACE_NAME,
+		                      "InterfaceName",
+		                      "The name of the virtual in-kernel bonding network interface",
+		                      NULL,
+		                      G_PARAM_READWRITE | NM_SETTING_PARAM_SERIALIZE));
+
+	/**
+	 * NMSettingBond:options:
+	 *
+	 * Dictionary of key/value pairs of bonding options.  Both keys
+	 * and values must be strings. Option names must contain only
+	 * alphanumeric characters (ie, [a-zA-Z0-9]).
+	 **/
+	 g_object_class_install_property
+		 (object_class, PROP_OPTIONS,
+		 _nm_param_spec_specialized (NM_SETTING_BOND_OPTIONS,
+		                             "Options",
+		                             "Dictionary of key/value pairs of bonding "
+		                             "options.  Both keys and values must be "
+		                             "strings.  Option names must contain only "
+		                             "alphanumeric characters (ie, [a-zA-Z0-9]).",
+		                             DBUS_TYPE_G_MAP_OF_STRING,
+		                             G_PARAM_READWRITE | NM_SETTING_PARAM_SERIALIZE));
+}
diff --git a/libnm-util/nm-setting-bond.h b/libnm-util/nm-setting-bond.h
new file mode 100644
index 0000000..1980964
--- /dev/null
+++ b/libnm-util/nm-setting-bond.h
@@ -0,0 +1,105 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+
+/*
+ * Thomas Graf <tgraf@redhat.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2011 - 2012 Red Hat, Inc.
+ */
+
+#ifndef NM_SETTING_BOND_H
+#define NM_SETTING_BOND_H
+
+#include <nm-setting.h>
+
+G_BEGIN_DECLS
+
+#define NM_TYPE_SETTING_BOND            (nm_setting_bond_get_type ())
+#define NM_SETTING_BOND(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_SETTING_BOND, NMSettingBond))
+#define NM_SETTING_BOND_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_SETTING_BOND, NMSettingBondClass))
+#define NM_IS_SETTING_BOND(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_SETTING_BOND))
+#define NM_IS_SETTING_BOND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_SETTING_BOND))
+#define NM_SETTING_BOND_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_SETTING_BOND, NMSettingBondClass))
+
+#define NM_SETTING_BOND_SETTING_NAME "bond"
+
+/**
+ * NMSettingBondError:
+ * @NM_SETTING_BOND_ERROR_UNKNOWN: unknown or unclassified error
+ * @NM_SETTING_BOND_ERROR_INVALID_PROPERTY: the property was invalid
+ * @NM_SETTING_BOND_ERROR_MISSING_PROPERTY: the property was missing and is
+ * required
+ */
+typedef enum {
+	NM_SETTING_BOND_ERROR_UNKNOWN = 0,
+	NM_SETTING_BOND_ERROR_INVALID_PROPERTY,
+	NM_SETTING_BOND_ERROR_MISSING_PROPERTY,
+} NMSettingBondError;
+
+#define NM_SETTING_BOND_ERROR nm_setting_bond_error_quark ()
+GQuark nm_setting_bond_error_quark (void);
+
+#define NM_SETTING_BOND_INTERFACE_NAME "interface-name"
+#define NM_SETTING_BOND_OPTIONS "options"
+
+/* Valid options for the 'options' property */
+#define NM_SETTING_BOND_OPTION_MODE          "mode"
+#define NM_SETTING_BOND_OPTION_MIIMON        "miimon"
+#define NM_SETTING_BOND_OPTION_DOWNDELAY     "downdelay"
+#define NM_SETTING_BOND_OPTION_UPDELAY       "updelay"
+#define NM_SETTING_BOND_OPTION_ARP_INTERVAL  "arp_interval"
+#define NM_SETTING_BOND_OPTION_ARP_IP_TARGET "arp_ip_target"
+
+typedef struct {
+	NMSetting parent;
+} NMSettingBond;
+
+typedef struct {
+	NMSettingClass parent;
+
+	/* Padding for future expansion */
+	void (*_reserved1) (void);
+	void (*_reserved2) (void);
+	void (*_reserved3) (void);
+	void (*_reserved4) (void);
+} NMSettingBondClass;
+
+GType nm_setting_bond_get_type (void);
+
+NMSetting *  nm_setting_bond_new                (void);
+const char * nm_setting_bond_get_interface_name (NMSettingBond *setting);
+guint32      nm_setting_bond_get_num_options    (NMSettingBond *setting);
+gboolean     nm_setting_bond_get_option         (NMSettingBond *setting,
+                                                 guint32 idx,
+                                                 const char **out_name,
+                                                 const char **out_value);
+const char * nm_setting_bond_get_option_by_name (NMSettingBond *setting,
+                                                 const char *name);
+gboolean     nm_setting_bond_add_option         (NMSettingBond *setting,
+                                                 const char *name,
+                                                 const char *value);
+gboolean     nm_setting_bond_remove_option      (NMSettingBond *setting,
+                                                 const char *name);
+
+const char **nm_setting_bond_get_valid_options  (NMSettingBond *setting);
+
+const char * nm_setting_bond_get_option_default (NMSettingBond *setting,
+                                                 const char *name);
+
+G_END_DECLS
+
+#endif /* NM_SETTING_BOND_H */
diff --git a/libnm-util/nm-setting-connection.c b/libnm-util/nm-setting-connection.c
index 65f613e..d7616f5 100644
--- a/libnm-util/nm-setting-connection.c
+++ b/libnm-util/nm-setting-connection.c
@@ -26,6 +26,9 @@
 #include <string.h>
 #include <ctype.h>
 #include "nm-setting-connection.h"
+#include "nm-setting-bond.h"
+#include "nm-setting-ip4-config.h"
+#include "nm-setting-ip6-config.h"
 
 /**
  * SECTION:nm-setting-connection
@@ -85,6 +88,8 @@ typedef struct {
 	char *id;
 	char *uuid;
 	char *type;
+	char *master;
+	char *slave_type;
 	gboolean autoconnect;
 	guint64 timestamp;
 	gboolean read_only;
@@ -98,6 +103,8 @@ enum {
 	PROP_AUTOCONNECT,
 	PROP_TIMESTAMP,
 	PROP_READ_ONLY,
+	PROP_MASTER,
+	PROP_SLAVE_TYPE,
 
 	LAST_PROP
 };
@@ -210,6 +217,56 @@ nm_setting_connection_get_read_only (NMSettingConnection *setting)
 	return NM_SETTING_CONNECTION_GET_PRIVATE (setting)->read_only;
 }
 
+/**
+ * nm_setting_connection_get_master:
+ * @setting: the #NMSettingConnection
+ *
+ * Returns the #NMSettingConnection:master property of the connection.
+ *
+ * Returns: interface name of the master device or UUID of the master
+ * connection.
+ */
+const char *
+nm_setting_connection_get_master (NMSettingConnection *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_CONNECTION (setting), NULL);
+
+	return NM_SETTING_CONNECTION_GET_PRIVATE (setting)->master;
+}
+
+/**
+ * nm_setting_connection_get_slave_type:
+ * @setting: the #NMSettingConnection
+ *
+ * Returns the #NMSettingConnection:slave-type property of the connection.
+ *
+ * Returns: the type of slave this connection is, if any
+ */
+const char *
+nm_setting_connection_get_slave_type (NMSettingConnection *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_CONNECTION (setting), NULL);
+
+	return NM_SETTING_CONNECTION_GET_PRIVATE (setting)->slave_type;
+}
+
+/**
+ * nm_setting_connection_is_slave_type:
+ * @setting: the #NMSettingConnection
+ * @type: the setting name (ie #NM_SETTING_BOND_SETTING_NAME) to be matched
+ * against @setting's slave type
+ *
+ * Returns: TRUE if connection is of the given slave @type
+ */
+gboolean
+nm_setting_connection_is_slave_type (NMSettingConnection *setting,
+                                     const char *type)
+{
+	g_return_val_if_fail (NM_IS_SETTING_CONNECTION (setting), FALSE);
+
+	return !g_strcmp0 (NM_SETTING_CONNECTION_GET_PRIVATE (setting)->slave_type, type);
+}
+
 static gint
 find_setting_by_name (gconstpointer a, gconstpointer b)
 {
@@ -291,6 +348,46 @@ verify (NMSetting *setting, GSList *all_settings, GError **error)
 		return FALSE;
 	}
 
+	/*
+	 * Bonding: Slaves are not allowed to have any IP configuration.
+	 */
+	if (priv->slave_type && all_settings &&
+	    !strcmp(priv->slave_type, NM_SETTING_BOND_SETTING_NAME)) {
+		GSList *list;
+
+		list = g_slist_find_custom (all_settings, NM_SETTING_IP4_CONFIG_SETTING_NAME,
+		                            find_setting_by_name);
+		if (list) {
+			NMSettingIP4Config *s_ip4 = g_slist_nth_data (list, 0);
+			g_assert (s_ip4);
+
+			if (strcmp (nm_setting_ip4_config_get_method (s_ip4),
+			            NM_SETTING_IP4_CONFIG_METHOD_DISABLED)) {
+				g_set_error (error,
+				             NM_SETTING_CONNECTION_ERROR,
+				             NM_SETTING_CONNECTION_ERROR_IP_CONFIG_NOT_ALLOWED,
+				             "No IP configuration allowed for bonding slave");
+				return FALSE;
+			}
+		}
+
+		list = g_slist_find_custom (all_settings, NM_SETTING_IP6_CONFIG_SETTING_NAME,
+		                            find_setting_by_name);
+		if (list) {
+			NMSettingIP6Config *s_ip6 = g_slist_nth_data (list, 0);
+			g_assert (s_ip6);
+
+			if (strcmp (nm_setting_ip6_config_get_method (s_ip6),
+			            NM_SETTING_IP6_CONFIG_METHOD_IGNORE)) {
+				g_set_error (error,
+				             NM_SETTING_CONNECTION_ERROR,
+				             NM_SETTING_CONNECTION_ERROR_IP_CONFIG_NOT_ALLOWED,
+				             "No IPv6 configuration allowed for bonding slave");
+				return FALSE;
+			}
+		}
+	}
+
 	return TRUE;
 }
 
@@ -308,6 +405,8 @@ finalize (GObject *object)
 	g_free (priv->id);
 	g_free (priv->uuid);
 	g_free (priv->type);
+	g_free (priv->master);
+	g_free (priv->slave_type);
 
 	G_OBJECT_CLASS (nm_setting_connection_parent_class)->finalize (object);
 }
@@ -340,6 +439,14 @@ set_property (GObject *object, guint prop_id,
 	case PROP_READ_ONLY:
 		priv->read_only = g_value_get_boolean (value);
 		break;
+	case PROP_MASTER:
+		g_free (priv->master);
+		priv->master = g_value_dup_string (value);
+		break;
+	case PROP_SLAVE_TYPE:
+		g_free (priv->slave_type);
+		priv->slave_type = g_value_dup_string (value);
+		break;
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -371,6 +478,12 @@ get_property (GObject *object, guint prop_id,
 	case PROP_READ_ONLY:
 		g_value_set_boolean (value, nm_setting_connection_get_read_only (setting));
 		break;
+	case PROP_MASTER:
+		g_value_set_string (value, nm_setting_connection_get_master (setting));
+		break;
+	case PROP_SLAVE_TYPE:
+		g_value_set_string (value, nm_setting_connection_get_slave_type (setting));
+		break;
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -518,4 +631,35 @@ nm_setting_connection_class_init (NMSettingConnectionClass *setting_class)
 	                      "cannot yet write updated connections back out.",
 	                      FALSE,
 	                      G_PARAM_READWRITE | G_PARAM_CONSTRUCT | NM_SETTING_PARAM_SERIALIZE | NM_SETTING_PARAM_FUZZY_IGNORE));
+
+	/**
+	 * NMSettingConnection:master:
+	 *
+	 * Interface name of the master device or UUID of the master connection.
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_MASTER,
+		 g_param_spec_string (NM_SETTING_CONNECTION_MASTER,
+		                      "Master",
+		                      "Interface name of the master device or UUID of "
+		                      "the master connection",
+		                      NULL,
+		                      G_PARAM_READWRITE | NM_SETTING_PARAM_SERIALIZE | NM_SETTING_PARAM_FUZZY_IGNORE));
+
+	/**
+	 * NMSettingConnection:slave-type:
+	 *
+	 * Setting name describing the type of slave device (ie
+	 * #NM_SETTING_BOND_SETTING_NAME) or NULL if this connection is not a slave.
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_SLAVE_TYPE,
+		 g_param_spec_string (NM_SETTING_CONNECTION_SLAVE_TYPE,
+		                      "Slave-Type",
+		                      "Setting name describing the type of slave "
+		                      "this connection is (ie, 'bond') or NULL if this "
+		                      "connection is not a slave.",
+		                      NULL,
+		                      G_PARAM_READWRITE | NM_SETTING_PARAM_SERIALIZE | NM_SETTING_PARAM_FUZZY_IGNORE));
 }
+
diff --git a/libnm-util/nm-setting-connection.h b/libnm-util/nm-setting-connection.h
index 6dedca2..c38776e 100644
--- a/libnm-util/nm-setting-connection.h
+++ b/libnm-util/nm-setting-connection.h
@@ -49,6 +49,8 @@ G_BEGIN_DECLS
  * @NM_SETTING_CONNECTION_ERROR_TYPE_SETTING_NOT_FOUND: the #NMSetting object
  *   referenced by the setting name contained in the
  *   #NMSettingConnection:type property was not present in the #NMConnection
+ * @NM_SETTING_CONNECTION_ERROR_IP_CONFIG_NOT_ALLOWED: ip configuration is not
+ *   allowed to be present.
  *
  * Describes errors that may result from operations involving a
  * #NMSettingConnection.
@@ -59,7 +61,8 @@ typedef enum
 	NM_SETTING_CONNECTION_ERROR_UNKNOWN = 0,
 	NM_SETTING_CONNECTION_ERROR_INVALID_PROPERTY,
 	NM_SETTING_CONNECTION_ERROR_MISSING_PROPERTY,
-	NM_SETTING_CONNECTION_ERROR_TYPE_SETTING_NOT_FOUND
+	NM_SETTING_CONNECTION_ERROR_TYPE_SETTING_NOT_FOUND,
+	NM_SETTING_CONNECTION_ERROR_IP_CONFIG_NOT_ALLOWED,
 } NMSettingConnectionError;
 
 #define NM_TYPE_SETTING_CONNECTION_ERROR (nm_setting_connection_error_get_type ()) 
@@ -74,6 +77,8 @@ GQuark nm_setting_connection_error_quark (void);
 #define NM_SETTING_CONNECTION_AUTOCONNECT "autoconnect"
 #define NM_SETTING_CONNECTION_TIMESTAMP   "timestamp"
 #define NM_SETTING_CONNECTION_READ_ONLY   "read-only"
+#define NM_SETTING_CONNECTION_MASTER      "master"
+#define NM_SETTING_CONNECTION_SLAVE_TYPE  "slave-type"
 
 /**
  * NMSettingConnection:
@@ -104,6 +109,10 @@ const char *nm_setting_connection_get_connection_type (NMSettingConnection *sett
 gboolean    nm_setting_connection_get_autoconnect     (NMSettingConnection *setting);
 guint64     nm_setting_connection_get_timestamp       (NMSettingConnection *setting);
 gboolean    nm_setting_connection_get_read_only       (NMSettingConnection *setting);
+const char *nm_setting_connection_get_master           (NMSettingConnection *setting);
+gboolean    nm_setting_connection_is_slave_type        (NMSettingConnection *setting,
+							const char *type);
+const char *nm_setting_connection_get_slave_type       (NMSettingConnection *setting);
 
 G_END_DECLS
 
diff --git a/libnm-util/nm-setting.c b/libnm-util/nm-setting.c
index 06994c7..328e9c9 100644
--- a/libnm-util/nm-setting.c
+++ b/libnm-util/nm-setting.c
@@ -640,6 +640,27 @@ nm_setting_to_string (NMSetting *setting)
 	return g_string_free (string, FALSE);
 }
 
+/**
+ * nm_setting_get_virtual_iface_name:
+ * @setting: the #NMSetting
+ *
+ * Returns the name of the virtual kernel interface which the connection
+ * needs to use if specified in the settings.
+ *
+ * Returns: Name of the virtual interface or %NULL if the setting does not
+ * support this feature
+ **/
+const char *
+nm_setting_get_virtual_iface_name (NMSetting *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING (setting), NULL);
+
+	if (NM_SETTING_GET_CLASS (setting)->get_virtual_iface_name)
+		return NM_SETTING_GET_CLASS (setting)->get_virtual_iface_name (setting);
+
+	return NULL;
+}
+
 /*****************************************************************************/
 
 static void
diff --git a/libnm-util/nm-setting.h b/libnm-util/nm-setting.h
index de5657e..e0fd6e7 100644
--- a/libnm-util/nm-setting.h
+++ b/libnm-util/nm-setting.h
@@ -108,11 +108,12 @@ typedef struct {
 	                                  GValue     *value,
 	                                  GError    **error);
 
+	const char *(*get_virtual_iface_name) (NMSetting *setting);
+
 	/* Padding for future expansion */
 	void (*_reserved1) (void);
 	void (*_reserved2) (void);
 	void (*_reserved3) (void);
-	void (*_reserved4) (void);
 } NMSettingClass;
 
 typedef void (*NMSettingValueIterFn) (NMSetting *setting,
@@ -173,6 +174,8 @@ gboolean    nm_setting_update_secrets (NMSetting *setting,
                                        GHashTable *secrets,
                                        GError **error);
 
+const char *nm_setting_get_virtual_iface_name (NMSetting *setting);
+
 G_END_DECLS
 
 #endif /* NM_SETTING_H */
diff --git a/src/Makefile.am b/src/Makefile.am
index 47c1648..9ef3474 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -108,6 +108,8 @@ NetworkManager_SOURCES = \
 		nm-device-gsm.h \
 		nm-device-infiniband.c \
 		nm-device-infiniband.h \
+		nm-device-bond.c \
+		nm-device-bond.h \
 		nm-wifi-ap.c \
 		nm-wifi-ap.h \
 		nm-dbus-manager.h \
@@ -141,6 +143,8 @@ NetworkManager_SOURCES = \
 		nm-manager-auth.h \
 		nm-netlink-monitor.c \
 		nm-netlink-monitor.h \
+		nm-netlink-utils.c \
+		nm-netlink-utils.h \
 		nm-activation-request.c \
 		nm-activation-request.h \
 		nm-properties-changed-signal.c \
@@ -168,6 +172,9 @@ nm-device-ethernet-glue.h: $(top_srcdir)/introspection/nm-device-ethernet.xml
 nm-device-infiniband-glue.h: $(top_srcdir)/introspection/nm-device-infiniband.xml
 	$(AM_V_GEN) dbus-binding-tool --prefix=nm_device_infiniband --mode=glib-server --output=$@ $<
 
+nm-device-bond-glue.h: $(top_srcdir)/introspection/nm-device-bond.xml
+	$(AM_V_GEN) dbus-binding-tool --prefix=nm_device_bond --mode=glib-server --output=$@ $<
+
 nm-device-wifi-glue.h: $(top_srcdir)/introspection/nm-device-wifi.xml
 	$(AM_V_GEN) dbus-binding-tool --prefix=nm_device_wifi --mode=glib-server --output=$@ $<
 
@@ -204,6 +211,7 @@ BUILT_SOURCES = \
 	nm-device-interface-glue.h \
 	nm-device-ethernet-glue.h \
 	nm-device-infiniband-glue.h \
+	nm-device-bond-glue.h \
 	nm-device-wifi-glue.h \
 	nm-device-olpc-mesh-glue.h \
 	nm-device-bt-glue.h \
diff --git a/src/NetworkManagerUtils.c b/src/NetworkManagerUtils.c
index 83674f9..9609819 100644
--- a/src/NetworkManagerUtils.c
+++ b/src/NetworkManagerUtils.c
@@ -719,3 +719,19 @@ nm_utils_get_proc_sys_net_value (const char *path,
 	return success;
 }
 
+gboolean
+nm_utils_is_uuid (const char *str)
+{
+	const char *p = str;
+	int num_dashes = 0;
+
+	while (*p) {
+		if (*p == '-')
+			num_dashes++;
+		else if (!isxdigit (*p))
+			return FALSE;
+		p++;
+	}
+
+	return (num_dashes == 4) && (p - str == 36);
+}
diff --git a/src/NetworkManagerUtils.h b/src/NetworkManagerUtils.h
index 72c0e53..50577cb 100644
--- a/src/NetworkManagerUtils.h
+++ b/src/NetworkManagerUtils.h
@@ -78,4 +78,6 @@ gboolean nm_utils_get_proc_sys_net_value (const char *path,
                                           const char *iface,
                                           guint32 *out_value);
 
+gboolean nm_utils_is_uuid (const char *str);
+
 #endif /* NETWORK_MANAGER_UTILS_H */
diff --git a/src/nm-activation-request.c b/src/nm-activation-request.c
index 7d13140..a8887f7 100644
--- a/src/nm-activation-request.c
+++ b/src/nm-activation-request.c
@@ -50,6 +50,7 @@ enum {
 	CONNECTION_SECRETS_UPDATED,
 	CONNECTION_SECRETS_FAILED,
 	PROPERTIES_CHANGED,
+	DEP_RESULT,
 
 	LAST_SIGNAL
 };
@@ -74,6 +75,10 @@ typedef struct {
 	NMActiveConnectionState state;
 	gboolean is_default;
 	gboolean is_default6;
+
+	NMActRequest *dep;
+	guint dep_state_id;
+
 	gboolean shared;
 	GSList *share_rules;
 
@@ -92,6 +97,7 @@ enum {
 	PROP_DEFAULT,
 	PROP_DEFAULT6,
 	PROP_VPN,
+	PROP_MASTER,
 
 	LAST_PROP
 };
@@ -143,12 +149,59 @@ device_state_changed (NMDevice *device,
 	}
 }
 
+static void
+dep_gone (NMActRequest *self, GObject *ignored)
+{
+	NMActRequestPrivate *priv = NM_ACT_REQUEST_GET_PRIVATE (self);
+
+	g_warn_if_fail (G_OBJECT (priv->dep) == ignored);
+
+	/* Dependent connection is gone; clean up and fail */
+	priv->dep = NULL;
+	priv->dep_state_id = 0;
+	g_signal_emit (self, signals[DEP_RESULT], 0, NM_ACT_REQUEST_DEP_RESULT_FAILED);
+}
+
+static NMActRequestDependencyResult
+ac_state_to_dep_result (NMActRequest *ac)
+{
+	NMActiveConnectionState state = nm_act_request_get_ac_state (ac);
+
+	if (state == NM_ACTIVE_CONNECTION_STATE_ACTIVATING)
+		return NM_ACT_REQUEST_DEP_RESULT_WAIT;
+	else if (state == NM_ACTIVE_CONNECTION_STATE_ACTIVATED)
+		return NM_ACT_REQUEST_DEP_RESULT_READY;
+
+	return NM_ACT_REQUEST_DEP_RESULT_FAILED;
+}
+
+static void
+dep_state_changed (NMActRequest *dep,
+                   GParamSpec *pspec,
+                   NMActRequest *self)
+{
+	NMActRequestPrivate *priv = NM_ACT_REQUEST_GET_PRIVATE (self);
+	NMActRequestDependencyResult result;
+
+	g_warn_if_fail (priv->dep == dep);
+
+	result = ac_state_to_dep_result (priv->dep);
+	if (result == NM_ACT_REQUEST_DEP_RESULT_FAILED) {
+		g_object_weak_unref (G_OBJECT (priv->dep), (GWeakNotify) dep_gone, self);
+		g_signal_handler_disconnect (priv->dep, priv->dep_state_id);
+		priv->dep = NULL;
+		priv->dep_state_id = 0;
+	}
+	g_signal_emit (self, signals[DEP_RESULT], 0, result);
+}
+
 NMActRequest *
 nm_act_request_new (NMConnection *connection,
                     const char *specific_object,
                     gboolean user_requested,
                     gboolean assumed,
-                    gpointer *device)
+                    gpointer *device,
+                    NMActRequest *dependency)
 {
 	GObject *object;
 	NMActRequestPrivate *priv;
@@ -174,6 +227,15 @@ nm_act_request_new (NMConnection *connection,
 	priv->user_requested = user_requested;
 	priv->assumed = assumed;
 
+	if (dependency) {
+		priv->dep = dependency;
+		g_object_weak_ref (G_OBJECT (dependency), (GWeakNotify) dep_gone, object);
+		priv->dep_state_id = g_signal_connect (dependency,
+		                                       "notify::" NM_ACTIVE_CONNECTION_STATE,
+		                                       G_CALLBACK (dep_state_changed),
+		                                       object);
+	}
+
 	return NM_ACT_REQUEST (object);
 }
 
@@ -215,6 +277,13 @@ dispose (GObject *object)
 
 	g_object_unref (priv->connection);
 
+	if (priv->dep) {
+		g_object_weak_unref (G_OBJECT (priv->dep), (GWeakNotify) dep_gone, object);
+		g_signal_handler_disconnect (priv->dep, priv->dep_state_id);
+		priv->dep = NULL;
+		priv->dep_state_id = 0;
+	}
+
 	G_OBJECT_CLASS (nm_act_request_parent_class)->dispose (object);
 }
 
@@ -255,6 +324,7 @@ get_property (GObject *object, guint prop_id,
 {
 	NMActRequestPrivate *priv = NM_ACT_REQUEST_GET_PRIVATE (object);
 	GPtrArray *devices;
+	NMDevice *master;
 
 	switch (prop_id) {
 	case PROP_SERVICE_NAME:
@@ -286,6 +356,14 @@ get_property (GObject *object, guint prop_id,
 	case PROP_VPN:
 		g_value_set_boolean (value, FALSE);
 		break;
+	case PROP_MASTER:
+		if (priv->dep) {
+			master = NM_DEVICE (nm_act_request_get_device (priv->dep));
+			g_assert (master);
+			g_value_set_boxed (value, nm_device_get_path (master));
+		} else
+			g_value_set_boxed (value, "/");
+		break;
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -313,7 +391,8 @@ nm_act_request_class_init (NMActRequestClass *req_class)
                                              PROP_STATE,
                                              PROP_DEFAULT,
                                              PROP_DEFAULT6,
-                                             PROP_VPN);
+                                             PROP_VPN,
+                                             PROP_MASTER);
 
 	/* Signals */
 	signals[CONNECTION_SECRETS_UPDATED] =
@@ -340,6 +419,14 @@ nm_act_request_class_init (NMActRequestClass *req_class)
 		nm_properties_changed_signal_new (object_class,
 		                                  G_STRUCT_OFFSET (NMActRequestClass, properties_changed));
 
+	signals[DEP_RESULT] =
+		g_signal_new (NM_ACT_REQUEST_DEPENDENCY_RESULT,
+					  G_OBJECT_CLASS_TYPE (object_class),
+					  G_SIGNAL_RUN_FIRST,
+					  0, NULL, NULL,
+					  g_cclosure_marshal_VOID__UINT,
+					  G_TYPE_NONE, 1, G_TYPE_UINT);
+
 	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (req_class),
 	                                 &dbus_glib_nm_active_connection_object_info);
 }
@@ -651,3 +738,25 @@ nm_act_request_get_assumed (NMActRequest *req)
 	return NM_ACT_REQUEST_GET_PRIVATE (req)->assumed;
 }
 
+NMActRequest *
+nm_act_request_get_dependency (NMActRequest *req)
+{
+	g_return_val_if_fail (req != NULL, NULL);
+
+	return NM_ACT_REQUEST_GET_PRIVATE (req)->dep;
+}
+
+NMActRequestDependencyResult
+nm_act_request_get_dependency_result (NMActRequest *req)
+{
+	NMActRequestPrivate *priv = NM_ACT_REQUEST_GET_PRIVATE (req);
+
+	return priv->dep ? ac_state_to_dep_result (priv->dep) : NM_ACT_REQUEST_DEP_RESULT_READY;
+}
+
+NMActiveConnectionState
+nm_act_request_get_ac_state (NMActRequest *req)
+{
+	return NM_ACT_REQUEST_GET_PRIVATE (req)->state;
+}
+
diff --git a/src/nm-activation-request.h b/src/nm-activation-request.h
index a243694..81ed735 100644
--- a/src/nm-activation-request.h
+++ b/src/nm-activation-request.h
@@ -23,6 +23,7 @@
 
 #include <glib.h>
 #include <glib-object.h>
+#include "NetworkManager.h"
 #include "nm-connection.h"
 #include "nm-active-connection.h"
 #include "nm-secrets-provider-interface.h"
@@ -34,6 +35,15 @@
 #define NM_IS_ACT_REQUEST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_ACT_REQUEST))
 #define NM_ACT_REQUEST_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_ACT_REQUEST, NMActRequestClass))
 
+typedef enum {
+	NM_ACT_REQUEST_DEP_RESULT_UNKNOWN,
+	NM_ACT_REQUEST_DEP_RESULT_WAIT,
+	NM_ACT_REQUEST_DEP_RESULT_READY,
+	NM_ACT_REQUEST_DEP_RESULT_FAILED,
+} NMActRequestDependencyResult;
+
+#define NM_ACT_REQUEST_DEPENDENCY_RESULT "dependency-result"
+
 typedef struct {
 	GObject parent;
 } NMActRequest;
@@ -52,6 +62,8 @@ typedef struct {
 	                                RequestSecretsCaller caller);
 
 	void (*properties_changed) (NMActRequest *req, GHashTable *properties);
+
+	void (*dependency_result) (NMActRequest *req, NMActRequestDependencyResult result);
 } NMActRequestClass;
 
 GType nm_act_request_get_type (void);
@@ -60,7 +72,8 @@ NMActRequest *nm_act_request_new          (NMConnection *connection,
                                            const char *specific_object,
                                            gboolean user_requested,
                                            gboolean assumed,
-                                           gpointer *device);  /* An NMDevice */
+                                           gpointer *device,  /* An NMDevice */
+                                           NMActRequest *dependency);
 
 NMConnection *nm_act_request_get_connection     (NMActRequest *req);
 const char *  nm_act_request_get_specific_object (NMActRequest *req);
@@ -99,5 +112,11 @@ gboolean nm_act_request_get_secrets    (NMActRequest *req,
                                         const char *hint1,
                                         const char *hint2);
 
+NMActRequest *nm_act_request_get_dependency (NMActRequest *req);
+
+NMActRequestDependencyResult nm_act_request_get_dependency_result (NMActRequest *req);
+
+NMActiveConnectionState nm_act_request_get_ac_state (NMActRequest *req);
+
 #endif /* NM_ACTIVATION_REQUEST_H */
 
diff --git a/src/nm-active-connection.c b/src/nm-active-connection.c
index 90495bd..13ae2f1 100644
--- a/src/nm-active-connection.c
+++ b/src/nm-active-connection.c
@@ -62,7 +62,8 @@ nm_active_connection_install_properties (GObjectClass *object_class,
                                          guint prop_state,
                                          guint prop_default,
                                          guint prop_default6,
-                                         guint prop_vpn)
+                                         guint prop_vpn,
+                                         guint prop_master)
 {
 	g_object_class_install_property (object_class, prop_service_name,
 		g_param_spec_string (NM_ACTIVE_CONNECTION_SERVICE_NAME,
@@ -121,5 +122,12 @@ nm_active_connection_install_properties (GObjectClass *object_class,
 		                      "Is a VPN connection",
 		                      FALSE,
 		                      G_PARAM_READABLE));
+
+	g_object_class_install_property (object_class, prop_master,
+		g_param_spec_boxed (NM_ACTIVE_CONNECTION_MASTER,
+		                    "Master",
+		                    "Master",
+		                    DBUS_TYPE_G_OBJECT_PATH,
+		                    G_PARAM_READABLE));
 }
 
diff --git a/src/nm-active-connection.h b/src/nm-active-connection.h
index 5dde308..c68ee11 100644
--- a/src/nm-active-connection.h
+++ b/src/nm-active-connection.h
@@ -32,6 +32,7 @@
 #define NM_ACTIVE_CONNECTION_DEFAULT "default"
 #define NM_ACTIVE_CONNECTION_DEFAULT6 "default6"
 #define NM_ACTIVE_CONNECTION_VPN "vpn"
+#define NM_ACTIVE_CONNECTION_MASTER "master"
 
 char *nm_active_connection_get_next_object_path (void);
 
@@ -45,6 +46,7 @@ void nm_active_connection_install_properties (GObjectClass *object_class,
                                               guint prop_state,
                                               guint prop_default,
                                               guint prop_default6,
-                                              guint prop_vpn);
+                                              guint prop_vpn,
+                                              guint prop_master);
 
 #endif /* NM_ACTIVE_CONNECTION_H */
diff --git a/src/nm-device-bond.c b/src/nm-device-bond.c
new file mode 100644
index 0000000..3b5dc5f
--- /dev/null
+++ b/src/nm-device-bond.c
@@ -0,0 +1,569 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2011 - 2012 Red Hat, Inc.
+ */
+
+#include "config.h"
+
+#include <glib.h>
+#include <glib/gi18n.h>
+
+#include <netinet/ether.h>
+
+#include "nm-device-bond.h"
+#include "nm-device-interface.h"
+#include "nm-logging.h"
+#include "nm-properties-changed-signal.h"
+#include "nm-utils.h"
+#include "NetworkManagerUtils.h"
+#include "nm-device-private.h"
+#include "nm-netlink-monitor.h"
+#include "nm-system.h"
+
+#include "nm-device-bond-glue.h"
+
+G_DEFINE_TYPE (NMDeviceBond, nm_device_bond, NM_TYPE_DEVICE_WIRED)
+
+#define NM_DEVICE_BOND_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DEVICE_BOND, NMDeviceBondPrivate))
+
+#define NM_BOND_ERROR (nm_bond_error_quark ())
+
+typedef struct {
+	gboolean disposed;
+	GSList *slaves;
+} NMDeviceBondPrivate;
+
+enum {
+	PROPERTIES_CHANGED,
+
+	LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL] = { 0 };
+
+enum {
+	PROP_0,
+	PROP_HW_ADDRESS,
+	PROP_CARRIER,
+
+	LAST_PROP
+};
+
+/******************************************************************/
+
+typedef enum {
+	NM_BOND_ERROR_CONNECTION_NOT_BOND = 0,
+	NM_BOND_ERROR_CONNECTION_INVALID,
+	NM_BOND_ERROR_CONNECTION_INCOMPATIBLE,
+} NMBondError;
+
+#define NM_BOND_ERROR (nm_bond_error_quark ())
+#define NM_TYPE_BOND_ERROR (nm_bond_error_get_type ())
+
+static GQuark
+nm_bond_error_quark (void)
+{
+	static GQuark quark = 0;
+	if (!quark)
+		quark = g_quark_from_static_string ("nm-bond-error");
+	return quark;
+}
+
+/* This should really be standard. */
+#define ENUM_ENTRY(NAME, DESC) { NAME, "" #NAME "", DESC }
+
+static GType
+nm_bond_error_get_type (void)
+{
+	static GType etype = 0;
+
+	if (etype == 0) {
+		static const GEnumValue values[] = {
+			/* Connection was not a bond connection. */
+			ENUM_ENTRY (NM_BOND_ERROR_CONNECTION_NOT_BOND, "ConnectionNotBond"),
+			/* Connection was not a valid BT connection. */
+			ENUM_ENTRY (NM_BOND_ERROR_CONNECTION_INVALID, "ConnectionInvalid"),
+			/* Connection does not apply to this device. */
+			ENUM_ENTRY (NM_BOND_ERROR_CONNECTION_INCOMPATIBLE, "ConnectionIncompatible"),
+			{ 0, 0, 0 }
+		};
+		etype = g_enum_register_static ("NMBondError", values);
+	}
+	return etype;
+}
+
+/******************************************************************/
+
+static void
+device_state_changed (NMDevice *device,
+                      NMDeviceState new_state,
+                      NMDeviceState old_state,
+                      NMDeviceStateReason reason,
+                      gpointer user_data)
+{
+	if (new_state == NM_DEVICE_STATE_UNAVAILABLE) {
+		/* Use NM_DEVICE_STATE_REASON_CARRIER to make sure num retries is reset */
+		nm_device_queue_state (device, NM_DEVICE_STATE_DISCONNECTED, NM_DEVICE_STATE_REASON_CARRIER);
+	}
+}
+
+static void
+real_update_hw_address (NMDevice *dev)
+{
+	const guint8 *hw_addr;
+	guint8 old_addr[NM_UTILS_HWADDR_LEN_MAX];
+	int addrtype, addrlen;
+
+	addrtype = nm_device_wired_get_hwaddr_type (NM_DEVICE_WIRED (dev));
+	g_assert (addrtype >= 0);
+	addrlen = nm_utils_hwaddr_len (addrtype);
+	g_assert (addrlen > 0);
+
+	hw_addr = nm_device_wired_get_hwaddr (NM_DEVICE_WIRED (dev));
+	memcpy (old_addr, hw_addr, addrlen);
+
+	NM_DEVICE_CLASS (nm_device_bond_parent_class)->update_hw_address (dev);
+
+	hw_addr = nm_device_wired_get_hwaddr (NM_DEVICE_WIRED (dev));
+	if (memcmp (old_addr, hw_addr, addrlen))
+		g_object_notify (G_OBJECT (dev), NM_DEVICE_BOND_HW_ADDRESS);
+}
+
+static guint32
+real_get_generic_capabilities (NMDevice *dev)
+{
+	return NM_DEVICE_CAP_CARRIER_DETECT | NM_DEVICE_CAP_NM_SUPPORTED;
+}
+
+static gboolean
+is_available (NMDevice *dev)
+{
+	/* Carrier doesn't really matter for bond interfaces, we only care if it's IFF_UP */
+	if (NM_DEVICE_GET_CLASS (dev)->hw_is_up)
+		return NM_DEVICE_GET_CLASS (dev)->hw_is_up (dev);
+	return FALSE;
+}
+
+static gboolean
+match_bond_connection (NMDevice *device, NMConnection *connection, GError **error)
+{
+	const char *iface;
+	NMSettingBond *s_bond;
+
+	s_bond = nm_connection_get_setting_bond (connection);
+	if (!s_bond || !nm_connection_is_type (connection, NM_SETTING_BOND_SETTING_NAME)) {
+		g_set_error (error, NM_BOND_ERROR, NM_BOND_ERROR_CONNECTION_NOT_BOND,
+		             "The connection was not a bond connection.");
+		return FALSE;
+	}
+
+	/* Bond connections must specify the virtual interface name */
+	iface = nm_connection_get_virtual_iface_name (connection);
+	if (!iface || strcmp (nm_device_get_iface (device), iface)) {
+		g_set_error (error, NM_BOND_ERROR, NM_BOND_ERROR_CONNECTION_NOT_BOND,
+		             "The bond connection virtual interface name did not match.");
+		return FALSE;
+	}
+
+	/* FIXME: match bond properties like mode, etc? */
+
+	return TRUE;
+}
+
+static NMConnection *
+real_get_best_auto_connection (NMDevice *dev,
+                               GSList *connections,
+                               char **specific_object)
+{
+	GSList *iter;
+
+	for (iter = connections; iter; iter = g_slist_next (iter)) {
+		NMConnection *connection = NM_CONNECTION (iter->data);
+		NMSettingConnection *s_con;
+
+		s_con = nm_connection_get_setting_connection (connection);
+		g_assert (s_con);
+		if (   nm_setting_connection_get_autoconnect (s_con)
+		    && match_bond_connection (dev, connection, NULL))
+			return connection;
+	}
+	return NULL;
+}
+
+static gboolean
+real_check_connection_compatible (NMDevice *device,
+                                  NMConnection *connection,
+                                  GError **error)
+{
+	return match_bond_connection (device, connection, error);
+}
+
+static gboolean
+spec_match_list (NMDevice *device, const GSList *specs)
+{
+	char *hwaddr;
+	gboolean matched;
+
+	hwaddr = nm_utils_hwaddr_ntoa (nm_device_wired_get_hwaddr (NM_DEVICE_WIRED (device)), ARPHRD_ETHER);
+	matched = nm_match_spec_hwaddr (specs, hwaddr);
+	g_free (hwaddr);
+
+	return matched;
+}
+
+static gboolean
+bond_match_config (NMDevice *self, NMConnection *connection)
+{
+	NMSettingBond *s_bond;
+	const char *ifname;
+
+	s_bond = nm_connection_get_setting_bond (connection);
+	if (!s_bond)
+		return FALSE;
+
+	/* Interface name */
+	ifname = nm_setting_bond_get_interface_name (s_bond);
+	if (g_strcmp0 (ifname, nm_device_get_ip_iface (self)) != 0)
+		return FALSE;
+
+	return TRUE;
+}
+
+static NMConnection *
+connection_match_config (NMDevice *self, const GSList *connections)
+{
+	const GSList *iter;
+	GSList *bond_matches;
+	NMConnection *match;
+
+	/* First narrow @connections down to those that match in their
+	 * NMSettingBond configuration.
+	 */
+	bond_matches = NULL;
+	for (iter = connections; iter; iter = iter->next) {
+		NMConnection *candidate = NM_CONNECTION (iter->data);
+
+		if (!nm_connection_is_type (candidate, NM_SETTING_BOND_SETTING_NAME))
+			continue;
+		if (!bond_match_config (self, candidate))
+			continue;
+
+		bond_matches = g_slist_prepend (bond_matches, candidate);
+	}
+
+	/* Now pass those to the super method, which will check IP config */
+	bond_matches = g_slist_reverse (bond_matches);
+	match = NM_DEVICE_CLASS (nm_device_bond_parent_class)->connection_match_config (self, bond_matches);
+	g_slist_free (bond_matches);
+
+	return match;
+}
+
+/******************************************************************/
+
+static NMActStageReturn
+real_act_stage1_prepare (NMDevice *dev, NMDeviceStateReason *reason)
+{
+	NMActStageReturn ret = NM_ACT_STAGE_RETURN_SUCCESS;
+	NMConnection *connection;
+	NMSettingBond *s_bond;
+	gboolean no_firmware = FALSE;
+
+	g_return_val_if_fail (reason != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+
+	ret = NM_DEVICE_CLASS (nm_device_bond_parent_class)->act_stage1_prepare (dev, reason);
+	if (ret == NM_ACT_STAGE_RETURN_SUCCESS) {
+		connection = nm_device_get_connection (dev);
+		g_assert (connection);
+		s_bond = nm_connection_get_setting_bond (connection);
+		g_assert (s_bond);
+
+		/* Interface must be down to set bond options */
+		nm_device_hw_take_down (dev, TRUE);
+
+		if (!nm_system_apply_bonding_config (nm_device_get_ip_iface (dev), s_bond))
+			ret = NM_ACT_STAGE_RETURN_FAILURE;
+
+		nm_device_hw_bring_up (dev, TRUE, &no_firmware);
+	}
+	return ret;
+}
+
+static void
+slave_state_changed (NMDevice *slave,
+                     NMDeviceState new_state,
+                     NMDeviceState old_state,
+                     NMDeviceStateReason reason,
+                     gpointer user_data)
+{
+	NMDeviceBond *self = NM_DEVICE_BOND (user_data);
+	NMDeviceBondPrivate *priv = NM_DEVICE_BOND_GET_PRIVATE (self);
+	guint had_slaves;
+
+	nm_log_dbg (LOGD_DEVICE, "(%s): slave %s state change %d -> %d",
+	            nm_device_get_iface (NM_DEVICE (self)),
+	            nm_device_get_iface (slave),
+	            old_state,
+	            new_state);
+
+	had_slaves = !!priv->slaves;
+
+	if (   old_state > NM_DEVICE_STATE_DISCONNECTED
+	    && new_state <= NM_DEVICE_STATE_DISCONNECTED) {
+		/* Slave is no longer available or managed; can't use it */
+		nm_device_release_slave (NM_DEVICE (self), slave);
+	}
+
+	if (had_slaves && !priv->slaves) {
+		/* FIXME: just leave the interface up and connected without slaves? */
+		nm_log_dbg (LOGD_DEVICE, "(%s): last slave released, deactivating",
+		            nm_device_get_iface (NM_DEVICE (self)));
+		nm_device_queue_state (NM_DEVICE (self),
+		                       NM_DEVICE_STATE_DISCONNECTED,
+		                       NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED);
+	}
+}
+
+typedef struct {
+	NMDevice *slave;
+	guint state_id;
+} SlaveInfo;
+
+static SlaveInfo *
+find_slave_info_by_device (NMDeviceBond *self, NMDevice *slave)
+{
+	NMDeviceBondPrivate *priv = NM_DEVICE_BOND_GET_PRIVATE (self);
+	GSList *iter;
+
+	for (iter = priv->slaves; iter; iter = g_slist_next (iter)) {
+		if (((SlaveInfo *) iter->data)->slave == slave)
+			return iter->data;
+	}
+	return NULL;
+}
+
+static void
+free_slave_info (SlaveInfo *sinfo)
+{
+	g_return_if_fail (sinfo != NULL);
+	g_return_if_fail (sinfo->slave != NULL);
+
+	g_signal_handler_disconnect (sinfo->slave, sinfo->state_id);
+	g_object_unref (sinfo->slave);
+	memset (sinfo, 0, sizeof (*sinfo));
+	g_free (sinfo);
+}
+
+static gboolean
+enslave_slave (NMDevice *device, NMDevice *slave)
+{
+	NMDeviceBond *self = NM_DEVICE_BOND (device);
+	NMDeviceBondPrivate *priv = NM_DEVICE_BOND_GET_PRIVATE (self);
+	gboolean success, no_firmware = FALSE;
+
+	if (find_slave_info_by_device (self, slave))
+		return TRUE;
+
+	nm_device_hw_take_down (slave, TRUE);
+
+	success = nm_system_iface_enslave (nm_device_get_ip_ifindex (device),
+	                                   nm_device_get_ip_iface (device),
+	                                   nm_device_get_ip_ifindex (slave),
+	                                   nm_device_get_ip_iface (slave));
+	if (success) {
+		SlaveInfo *sinfo;
+
+		sinfo = g_malloc0 (sizeof (*slave));
+		sinfo->slave = g_object_ref (slave);
+		sinfo->state_id = g_signal_connect (slave,
+		                                    "state-changed",
+		                                    (GCallback) slave_state_changed,
+		                                    self);
+		priv->slaves = g_slist_append (priv->slaves, sinfo);
+
+		nm_log_dbg (LOGD_DEVICE, "(%s): enslaved bond slave %s",
+			        nm_device_get_ip_iface (device),
+			        nm_device_get_ip_iface (slave));
+	}
+
+	nm_device_hw_bring_up (slave, TRUE, &no_firmware);
+
+	return success;
+}
+
+static gboolean
+release_slave (NMDevice *device, NMDevice *slave)
+{
+	NMDeviceBond *self = NM_DEVICE_BOND (device);
+	NMDeviceBondPrivate *priv = NM_DEVICE_BOND_GET_PRIVATE (self);
+	gboolean success;
+	SlaveInfo *sinfo;
+
+	sinfo = find_slave_info_by_device (self, slave);
+	if (!sinfo)
+		return FALSE;
+
+	success = nm_system_iface_release (nm_device_get_ip_ifindex (device),
+	                                   nm_device_get_ip_iface (device),
+	                                   nm_device_get_ip_ifindex (slave),
+	                                   nm_device_get_ip_iface (slave));
+	nm_log_dbg (LOGD_DEVICE, "(%s): released bond slave %s (success %d)",
+	            nm_device_get_ip_iface (device),
+	            nm_device_get_ip_iface (slave),
+	            success);
+	priv->slaves = g_slist_remove (priv->slaves, sinfo);
+	free_slave_info (sinfo);
+	return success;
+}
+
+/******************************************************************/
+
+NMDevice *
+nm_device_bond_new (const char *udi, const char *iface)
+{
+	g_return_val_if_fail (udi != NULL, NULL);
+	g_return_val_if_fail (iface != NULL, NULL);
+
+	return (NMDevice *) g_object_new (NM_TYPE_DEVICE_BOND,
+	                                  NM_DEVICE_INTERFACE_UDI, udi,
+	                                  NM_DEVICE_INTERFACE_IFACE, iface,
+	                                  NM_DEVICE_INTERFACE_DRIVER, "bonding",
+	                                  NM_DEVICE_INTERFACE_TYPE_DESC, "Bond",
+	                                  NM_DEVICE_INTERFACE_DEVICE_TYPE, NM_DEVICE_TYPE_BOND,
+	                                  NULL);
+}
+
+static void
+constructed (GObject *object)
+{
+	G_OBJECT_CLASS (nm_device_bond_parent_class)->constructed (object);
+
+	nm_log_dbg (LOGD_HW | LOGD_DEVICE, "(%s): kernel ifindex %d",
+	            nm_device_get_iface (NM_DEVICE (object)),
+	            nm_device_get_ifindex (NM_DEVICE (object)));
+}
+
+static void
+nm_device_bond_init (NMDeviceBond * self)
+{
+	g_signal_connect (self, "state-changed", G_CALLBACK (device_state_changed), NULL);
+}
+
+static void
+get_property (GObject *object, guint prop_id,
+              GValue *value, GParamSpec *pspec)
+{
+	const guint8 *current_addr;
+
+	switch (prop_id) {
+	case PROP_HW_ADDRESS:
+		current_addr = nm_device_wired_get_hwaddr (NM_DEVICE_WIRED (object));
+		g_value_take_string (value, nm_utils_hwaddr_ntoa (current_addr, ARPHRD_ETHER));
+		break;
+	case PROP_CARRIER:
+		g_value_set_boolean (value, nm_device_wired_get_carrier (NM_DEVICE_WIRED (object)));
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+set_property (GObject *object, guint prop_id,
+			  const GValue *value, GParamSpec *pspec)
+{
+	switch (prop_id) {
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+dispose (GObject *object)
+{
+	NMDeviceBond *self = NM_DEVICE_BOND (object);
+	NMDeviceBondPrivate *priv = NM_DEVICE_BOND_GET_PRIVATE (self);
+	GSList *iter;
+
+	if (priv->disposed) {
+		G_OBJECT_CLASS (nm_device_bond_parent_class)->dispose (object);
+		return;
+	}
+	priv->disposed = TRUE;
+
+	for (iter = priv->slaves; iter; iter = g_slist_next (iter))
+		release_slave (NM_DEVICE (self), ((SlaveInfo *) iter->data)->slave);
+	g_slist_free (priv->slaves);
+}
+
+static void
+nm_device_bond_class_init (NMDeviceBondClass *klass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
+	NMDeviceClass *parent_class = NM_DEVICE_CLASS (klass);
+
+	g_type_class_add_private (object_class, sizeof (NMDeviceBondPrivate));
+
+	/* virtual methods */
+	object_class->constructed = constructed;
+	object_class->get_property = get_property;
+	object_class->set_property = set_property;
+	object_class->dispose = dispose;
+
+	parent_class->get_generic_capabilities = real_get_generic_capabilities;
+	parent_class->update_hw_address = real_update_hw_address;
+	parent_class->is_available = is_available;
+	parent_class->get_best_auto_connection = real_get_best_auto_connection;
+	parent_class->check_connection_compatible = real_check_connection_compatible;
+
+	parent_class->spec_match_list = spec_match_list;
+	parent_class->connection_match_config = connection_match_config;
+
+	parent_class->act_stage1_prepare = real_act_stage1_prepare;
+	parent_class->enslave_slave = enslave_slave;
+	parent_class->release_slave = release_slave;
+
+	/* properties */
+	g_object_class_install_property
+		(object_class, PROP_HW_ADDRESS,
+		 g_param_spec_string (NM_DEVICE_BOND_HW_ADDRESS,
+							  "Active MAC Address",
+							  "Currently set hardware MAC address",
+							  NULL,
+							  G_PARAM_READABLE));
+
+	g_object_class_install_property
+		(object_class, PROP_CARRIER,
+		 g_param_spec_boolean (NM_DEVICE_BOND_CARRIER,
+							   "Carrier",
+							   "Carrier",
+							   FALSE,
+							   G_PARAM_READABLE));
+
+	/* Signals */
+	signals[PROPERTIES_CHANGED] =
+		nm_properties_changed_signal_new (object_class,
+										  G_STRUCT_OFFSET (NMDeviceBondClass, properties_changed));
+
+	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (klass),
+									 &dbus_glib_nm_device_bond_object_info);
+
+	dbus_g_error_domain_register (NM_BOND_ERROR, NULL, NM_TYPE_BOND_ERROR);
+}
diff --git a/src/nm-device-bond.h b/src/nm-device-bond.h
new file mode 100644
index 0000000..b431e8d
--- /dev/null
+++ b/src/nm-device-bond.h
@@ -0,0 +1,59 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2012 Red Hat, Inc.
+ */
+
+#ifndef NM_DEVICE_BOND_H
+#define NM_DEVICE_BOND_H
+
+#include <glib-object.h>
+
+#include "nm-device-wired.h"
+
+G_BEGIN_DECLS
+
+#define NM_TYPE_DEVICE_BOND            (nm_device_bond_get_type ())
+#define NM_DEVICE_BOND(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DEVICE_BOND, NMDeviceBond))
+#define NM_DEVICE_BOND_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  NM_TYPE_DEVICE_BOND, NMDeviceBondClass))
+#define NM_IS_DEVICE_BOND(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_DEVICE_BOND))
+#define NM_IS_DEVICE_BOND_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  NM_TYPE_DEVICE_BOND))
+#define NM_DEVICE_BOND_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  NM_TYPE_DEVICE_BOND, NMDeviceBondClass))
+
+#define NM_DEVICE_BOND_HW_ADDRESS "hw-address"
+#define NM_DEVICE_BOND_CARRIER "carrier"
+
+typedef struct {
+	NMDeviceWired parent;
+} NMDeviceBond;
+
+typedef struct {
+	NMDeviceWiredClass parent;
+
+	/* Signals */
+	void (*properties_changed) (NMDeviceBond *device, GHashTable *properties);
+} NMDeviceBondClass;
+
+
+GType nm_device_bond_get_type (void);
+
+NMDevice *nm_device_bond_new (const char *udi,
+                              const char *iface);
+
+G_END_DECLS
+
+#endif	/* NM_DEVICE_BOND_H */
diff --git a/src/nm-device-ethernet.c b/src/nm-device-ethernet.c
index 30d6484..626e949 100644
--- a/src/nm-device-ethernet.c
+++ b/src/nm-device-ethernet.c
@@ -1226,16 +1226,19 @@ real_act_stage1_prepare (NMDevice *dev, NMDeviceStateReason *reason)
 
 	g_return_val_if_fail (reason != NULL, NM_ACT_STAGE_RETURN_FAILURE);
 
-	req = nm_device_get_act_request (NM_DEVICE (self));
-	g_return_val_if_fail (req != NULL, NM_ACT_STAGE_RETURN_FAILURE);
-
-	s_wired = NM_SETTING_WIRED (device_get_setting (dev, NM_TYPE_SETTING_WIRED));
-	g_assert (s_wired);
-
-	/* Set device MAC address if the connection wants to change it */
-	cloned_mac = nm_setting_wired_get_cloned_mac_address (s_wired);
-	if (cloned_mac && (cloned_mac->len == ETH_ALEN))
-		_set_hw_addr (self, (const guint8 *) cloned_mac->data, "set");
+	ret = NM_DEVICE_CLASS (nm_device_ethernet_parent_class)->act_stage1_prepare (dev, reason);
+	if (ret == NM_ACT_STAGE_RETURN_SUCCESS) {
+		req = nm_device_get_act_request (NM_DEVICE (self));
+		g_return_val_if_fail (req != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+
+		s_wired = NM_SETTING_WIRED (device_get_setting (dev, NM_TYPE_SETTING_WIRED));
+		g_assert (s_wired);
+
+		/* Set device MAC address if the connection wants to change it */
+		cloned_mac = nm_setting_wired_get_cloned_mac_address (s_wired);
+		if (cloned_mac && (cloned_mac->len == ETH_ALEN))
+			_set_hw_addr (self, (const guint8 *) cloned_mac->data, "set");
+	}
 
 	return ret;
 }
diff --git a/src/nm-device-infiniband.c b/src/nm-device-infiniband.c
index ec86d61..7fda1d0 100644
--- a/src/nm-device-infiniband.c
+++ b/src/nm-device-infiniband.c
@@ -260,7 +260,7 @@ real_act_stage1_prepare (NMDevice *dev, NMDeviceStateReason *reason)
 		return NM_ACT_STAGE_RETURN_FAILURE;
 	}
 
-	return NM_ACT_STAGE_RETURN_SUCCESS;
+	return NM_DEVICE_CLASS (nm_device_infiniband_parent_class)->act_stage1_prepare (dev, reason);
 }
 
 static NMActStageReturn
diff --git a/src/nm-device-interface.c b/src/nm-device-interface.c
index a0b9877..c8f8e38 100644
--- a/src/nm-device-interface.c
+++ b/src/nm-device-interface.c
@@ -82,7 +82,7 @@ nm_device_interface_init (gpointer g_iface)
 							  "UDI",
 							  "Unique Device Identifier",
 							  NULL,
-							  G_PARAM_READWRITE | G_PARAM_CONSTRUCT_ONLY));
+							  G_PARAM_READWRITE | G_PARAM_CONSTRUCT));
 
 	g_object_interface_install_property
 		(g_iface,
@@ -287,8 +287,6 @@ nm_device_interface_check_connection_compatible (NMDeviceInterface *device,
 {
 	g_return_val_if_fail (NM_IS_DEVICE_INTERFACE (device), FALSE);
 	g_return_val_if_fail (NM_IS_CONNECTION (connection), FALSE);
-	g_return_val_if_fail (error != NULL, FALSE);
-	g_return_val_if_fail (*error == NULL, FALSE);
 
 	if (NM_DEVICE_INTERFACE_GET_INTERFACE (device)->check_connection_compatible)
 		return NM_DEVICE_INTERFACE_GET_INTERFACE (device)->check_connection_compatible (device, connection, error);
diff --git a/src/nm-device-private.h b/src/nm-device-private.h
index f4f968a..c55f13c 100644
--- a/src/nm-device-private.h
+++ b/src/nm-device-private.h
@@ -46,4 +46,5 @@ gboolean nm_device_get_firmware_missing (NMDevice *self);
 
 void nm_device_set_firmware_missing (NMDevice *self, gboolean missing);
 
+gboolean nm_device_match_ip_config (NMDevice *device, NMConnection *connection);
 #endif	/* NM_DEVICE_PRIVATE_H */
diff --git a/src/nm-device-wired.c b/src/nm-device-wired.c
index 0df03d5..1061642 100644
--- a/src/nm-device-wired.c
+++ b/src/nm-device-wired.c
@@ -84,7 +84,7 @@ carrier_action_defer_cb (gpointer user_data)
 		if (priv->carrier)
 			nm_device_queue_state (NM_DEVICE (self), NM_DEVICE_STATE_DISCONNECTED, NM_DEVICE_STATE_REASON_CARRIER);
 	} else if (state >= NM_DEVICE_STATE_DISCONNECTED) {
-		if (!priv->carrier)
+		if (!priv->carrier && !nm_device_is_available (NM_DEVICE (self)))
 			nm_device_queue_state (NM_DEVICE (self), NM_DEVICE_STATE_UNAVAILABLE, NM_DEVICE_STATE_REASON_CARRIER);
 	}
 
@@ -176,6 +176,29 @@ carrier_off (NMNetlinkMonitor *monitor,
 	}
 }
 
+static gboolean
+get_carrier_sync (NMDeviceWired *self)
+{
+	NMDeviceWiredPrivate *priv = NM_DEVICE_WIRED_GET_PRIVATE (self);
+	GError *error = NULL;
+	guint32 ifflags = 0;
+
+	/* Get initial link state */
+	if (!nm_netlink_monitor_get_flags_sync (priv->monitor,
+	                                        nm_device_get_ip_ifindex (NM_DEVICE (self)),
+	                                        &ifflags,
+	                                        &error)) {
+		nm_log_warn (LOGD_HW | NM_DEVICE_WIRED_LOG_LEVEL (NM_DEVICE (self)),
+		             "(%s): couldn't get carrier state: (%d) %s",
+		             nm_device_get_ip_iface (NM_DEVICE (self)),
+		             error ? error->code : -1,
+		             (error && error->message) ? error->message : "unknown");
+		g_clear_error (&error);
+	}
+
+	return !!(ifflags & IFF_LOWER_UP);
+}
+
 static GObject*
 constructor (GType type,
 			 guint n_construct_params,
@@ -185,6 +208,7 @@ constructor (GType type,
 	NMDeviceWiredPrivate *priv;
 	NMDevice *self;
 	guint32 caps;
+	GError *error = NULL;
 
 	object = G_OBJECT_CLASS (nm_device_wired_parent_class)->constructor (type,
 	                                                                        n_construct_params,
@@ -201,14 +225,15 @@ constructor (GType type,
 	} else if (nm_device_get_device_type (self) == NM_DEVICE_TYPE_INFINIBAND) {
 		priv->hw_addr_type = ARPHRD_INFINIBAND;
 		priv->hw_addr_len = INFINIBAND_ALEN;
+	} else if (nm_device_get_device_type (self) == NM_DEVICE_TYPE_BOND) {
+		/* We may not know the hardware address type until a slave is added */
+		priv->hw_addr_type = ARPHRD_ETHER;
+		priv->hw_addr_len = ETH_ALEN;
 	} else
 		g_assert_not_reached ();
 
 	caps = nm_device_get_capabilities (self);
 	if (caps & NM_DEVICE_CAP_CARRIER_DETECT) {
-		GError *error = NULL;
-		guint32 ifflags = 0;
-
 		/* Only listen to netlink for cards that support carrier detect */
 		priv->monitor = nm_netlink_monitor_get ();
 
@@ -219,19 +244,7 @@ constructor (GType type,
 		                                               G_CALLBACK (carrier_off),
 		                                               self);
 
-		/* Get initial link state */
-		if (!nm_netlink_monitor_get_flags_sync (priv->monitor,
-		                                        nm_device_get_ifindex (NM_DEVICE (self)),
-		                                        &ifflags,
-		                                        &error)) {
-			nm_log_warn (LOGD_HW | NM_DEVICE_WIRED_LOG_LEVEL (NM_DEVICE (self)),
-			             "(%s): couldn't get initial carrier state: (%d) %s",
-			             nm_device_get_iface (NM_DEVICE (self)),
-			             error ? error->code : -1,
-			             (error && error->message) ? error->message : "unknown");
-			g_clear_error (&error);
-		} else
-			priv->carrier = !!(ifflags & IFF_LOWER_UP);
+		priv->carrier = get_carrier_sync (NM_DEVICE_WIRED (self));
 
 		nm_log_info (LOGD_HW | NM_DEVICE_WIRED_LOG_LEVEL (NM_DEVICE (self)),
 		             "(%s): carrier is %s",
@@ -274,7 +287,18 @@ real_hw_is_up (NMDevice *device)
 static gboolean
 real_hw_bring_up (NMDevice *dev, gboolean *no_firmware)
 {
-	return nm_system_device_set_up_down (dev, TRUE, no_firmware);
+	gboolean success, carrier;
+	guint32 caps;
+
+	success = nm_system_device_set_up_down (dev, TRUE, no_firmware);
+	if (success) {
+		caps = nm_device_get_capabilities (dev);
+		if (caps & NM_DEVICE_CAP_CARRIER_DETECT) {
+			carrier = get_carrier_sync (NM_DEVICE_WIRED (dev));
+			set_carrier (NM_DEVICE_WIRED (dev), carrier, carrier ? FALSE : TRUE);
+		}
+	}
+	return success;
 }
 
 static void
@@ -349,140 +369,6 @@ real_is_available (NMDevice *dev)
 	return TRUE;
 }
 
-typedef struct {
-	int ifindex;
-	NMIP4Address *addr;
-	gboolean found;
-} AddrData;
-
-static void
-check_one_address (struct nl_object *object, void *user_data)
-{
-	AddrData *data = user_data;
-	struct rtnl_addr *addr = (struct rtnl_addr *) object;
-	struct nl_addr *local;
-	struct in_addr tmp;
-
-	if (rtnl_addr_get_ifindex (addr) != data->ifindex)
-		return;
-	if (rtnl_addr_get_family (addr) != AF_INET)
-		return;
-
-	if (nm_ip4_address_get_prefix (data->addr) != rtnl_addr_get_prefixlen (addr))
-		return;
-
-	local = rtnl_addr_get_local (addr);
-	if (nl_addr_get_family (local) != AF_INET)
-		return;
-	if (nl_addr_get_len (local) != sizeof (struct in_addr))
-		return;
-	if (!nl_addr_get_binary_addr (local))
-		return;
-
-	memcpy (&tmp, nl_addr_get_binary_addr (local), nl_addr_get_len (local));
-	if (tmp.s_addr != nm_ip4_address_get_address (data->addr))
-		return;
-
-	/* Yay, found it */
-	data->found = TRUE;
-}
-
-static gboolean
-ip4_match_config (NMDevice *self, NMConnection *connection)
-{
-	NMSettingIP4Config *s_ip4;
-	NMSettingConnection *s_con;
-	struct nl_handle *nlh = NULL;
-	struct nl_cache *addr_cache = NULL;
-	int i, num;
-	GSList *leases, *iter;
-	NMDHCPManager *dhcp_mgr;
-	const char *method;
-	int ifindex;
-	AddrData check_data;
-
-	ifindex = nm_device_get_ifindex (self);
-
-	s_con = (NMSettingConnection *) nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION);
-	g_assert (s_con);
-	g_assert (nm_setting_connection_get_uuid (s_con));
-
-	s_ip4 = (NMSettingIP4Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP4_CONFIG);
-	if (!s_ip4)
-		return FALSE;
-
-	/* Read all the device's IP addresses */
-	nlh = nm_netlink_get_default_handle ();
-	if (!nlh)
-		return FALSE;
-
-	addr_cache = rtnl_addr_alloc_cache (nlh);
-	if (!addr_cache)
-		return FALSE;
-	nl_cache_mngt_provide (addr_cache);
-
-	/* Get any saved leases that apply to this connection */
-	dhcp_mgr = nm_dhcp_manager_get ();
-	leases = nm_dhcp_manager_get_lease_config (dhcp_mgr,
-	                                           nm_device_get_iface (self),
-	                                           nm_setting_connection_get_uuid (s_con));
-	g_object_unref (dhcp_mgr);
-
-	method = nm_setting_ip4_config_get_method (s_ip4);
-	if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_AUTO)) {
-		gboolean found = FALSE;
-
-		/* Find at least one lease's address on the device */
-		for (iter = leases; iter; iter = g_slist_next (iter)) {
-			NMIP4Config *addr = iter->data;
-
-			memset (&check_data, 0, sizeof (check_data));
-			check_data.ifindex = ifindex;
-			check_data.found = FALSE;
-			check_data.addr = nm_ip4_config_get_address (addr, 0);
-
-			nl_cache_foreach (addr_cache, check_one_address, &check_data);
-			if (check_data.found) {
-				found = TRUE; /* Yay, device has same address as a lease */
-				break;
-			}
-		}
-		g_slist_foreach (leases, (GFunc) g_object_unref, NULL);
-		g_slist_free (leases);
-		return found;
-	} else {
-		/* Maybe the connection used to be DHCP and there are stale leases; ignore them */
-		g_slist_foreach (leases, (GFunc) g_object_unref, NULL);
-		g_slist_free (leases);
-	}
-
-	/* 'shared' and 'link-local' aren't supported methods because 'shared'
-	 * requires too much iptables and dnsmasq state to be reclaimed, and
-	 * avahi-autoipd isn't smart enough to allow the link-local address to be
-	 * determined at any point other than when it was first assigned.
-	 */
-	if (strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_MANUAL))
-		return FALSE;
-
-	/* Everything below for static addressing */
-
-	/* Find all IP4 addresses of this connection in the device's address list */
-	num = nm_setting_ip4_config_get_num_addresses (s_ip4);
-	for (i = 0; i < num; i++) {
-		memset (&check_data, 0, sizeof (check_data));
-		check_data.ifindex = ifindex;
-		check_data.found = FALSE;
-		check_data.addr = nm_setting_ip4_config_get_address (s_ip4, i);
-
-		nl_cache_foreach (addr_cache, check_one_address, &check_data);
-		if (!check_data.found)
-			return FALSE;
-	}
-
-	/* Success; all the connection's static IP addresses are assigned to the device */
-	return TRUE;
-}
-
 static NMConnection *
 connection_match_config (NMDevice *self, const GSList *connections)
 {
@@ -491,7 +377,7 @@ connection_match_config (NMDevice *self, const GSList *connections)
 	for (iter = connections; iter; iter = iter->next) {
 		NMConnection *candidate = NM_CONNECTION (iter->data);
 
-		if (!ip4_match_config (self, candidate))
+		if (!nm_device_match_ip_config (self, candidate))
 			continue;
 
 		return candidate;
diff --git a/src/nm-device.c b/src/nm-device.c
index 8eaa23a..3ca7d50 100644
--- a/src/nm-device.c
+++ b/src/nm-device.c
@@ -46,9 +46,11 @@
 #include "nm-utils.h"
 #include "nm-logging.h"
 #include "nm-netlink-monitor.h"
+#include "nm-netlink-utils.h"
 #include "nm-setting-ip4-config.h"
 #include "nm-setting-ip6-config.h"
 #include "nm-setting-connection.h"
+#include "nm-setting-bond.h"
 #include "nm-dnsmasq-manager.h"
 #include "nm-dhcp4-config.h"
 #include "nm-ip6-manager.h"
@@ -73,12 +75,17 @@ static guint signals[LAST_SIGNAL] = { 0 };
 #define NM_DEVICE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DEVICE, NMDevicePrivate))
 
 typedef struct {
+	NMDeviceState state;
+	NMDeviceStateReason reason;
+	guint id;
+} QueuedState;
+
+typedef struct {
 	gboolean disposed;
 	gboolean initialized;
 
 	NMDeviceState state;
-	guint         failed_to_disconnected_id;
-	guint         unavailable_to_disconnected_id;
+	QueuedState   queued_state;
 
 	char *        udi;
 	char *        path;
@@ -101,6 +108,8 @@ typedef struct {
 	gpointer        act_source_func;
 	guint           act_source6_id;
 	gpointer        act_source6_func;
+	guint           act_dep_result_id;
+	guint           act_dep_timeout_id;
 	gulong          secrets_updated_id;
 	gulong          secrets_failed_id;
 
@@ -493,6 +502,51 @@ nm_device_get_type_desc (NMDevice *self)
 	return NM_DEVICE_GET_PRIVATE (self)->type_desc;
 }
 
+/**
+ * nm_device_enslave_slave:
+ * @dev: the master device
+ * @slave: the slave device to enslave
+ *
+ * If @dev is capable of enslaving other devices (ie it's a bridge, bond, etc)
+ * then this function enslaves @slave.
+ *
+ * Returns: %TRUE on success, %FALSE on failure or if this device cannot enslave
+ *  other devices.
+ */
+gboolean
+nm_device_enslave_slave (NMDevice *dev, NMDevice *slave)
+{
+	g_return_val_if_fail (dev != NULL, FALSE);
+	g_return_val_if_fail (slave != NULL, FALSE);
+	g_return_val_if_fail (nm_device_get_state (slave) >= NM_DEVICE_STATE_DISCONNECTED, FALSE);
+
+	if (NM_DEVICE_GET_CLASS (dev)->enslave_slave)
+		return NM_DEVICE_GET_CLASS (dev)->enslave_slave (dev, slave);
+	return FALSE;
+}
+
+/**
+ * nm_device_release_slave:
+ * @dev: the master device
+ * @slave: the slave device to release
+ *
+ * If @dev is capable of enslaving other devices (ie it's a bridge, bond, etc)
+ * then this function releases the previously enslaved @slave.
+ *
+ * Returns: %TRUE on success, %FALSE on failure, if this device cannot enslave
+ *  other devices, or if @slave was never enslaved.
+ */
+gboolean
+nm_device_release_slave (NMDevice *dev, NMDevice *slave)
+{
+	g_return_val_if_fail (dev != NULL, FALSE);
+	g_return_val_if_fail (slave != NULL, FALSE);
+
+	if (NM_DEVICE_GET_CLASS (dev)->release_slave)
+		return NM_DEVICE_GET_CLASS (dev)->release_slave (dev, slave);
+	return FALSE;
+}
+
 /*
  * nm_device_get_act_request
  *
@@ -507,6 +561,13 @@ nm_device_get_act_request (NMDevice *self)
 	return NM_DEVICE_GET_PRIVATE (self)->act_request;
 }
 
+NMConnection *
+nm_device_get_connection (NMDevice *self)
+{
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+
+	return priv->act_request ? nm_act_request_get_connection (priv->act_request) : NULL;
+}
 
 gboolean
 nm_device_is_available (NMDevice *self)
@@ -848,7 +909,26 @@ addrconf6_cleanup (NMDevice *self)
 static NMActStageReturn
 real_act_stage1_prepare (NMDevice *self, NMDeviceStateReason *reason)
 {
-	return NM_ACT_STAGE_RETURN_SUCCESS;
+	NMActRequest *req;
+	NMActRequest *master_ac;
+	NMDevice *master;
+	NMActStageReturn ret = NM_ACT_STAGE_RETURN_SUCCESS;
+
+	req = nm_device_get_act_request (self);
+	g_assert (req);
+
+	/* If the interface is going to be a slave, let the master enslave it here */
+	master_ac = nm_act_request_get_dependency (req);
+	if (master_ac) {
+		/* FIXME: handle VPNs here too */
+
+		master = NM_DEVICE (nm_act_request_get_device (master_ac));
+		g_assert (master);
+		if (!nm_device_enslave_slave (master, self))
+			ret = NM_ACT_STAGE_RETURN_FAILURE;
+	}
+
+	return ret;
 }
 
 /*
@@ -869,6 +949,11 @@ nm_device_activate_stage1_device_prepare (gpointer user_data)
 	/* Clear the activation source ID now that this stage has run */
 	activation_source_clear (self, FALSE, 0);
 
+	if (priv->act_dep_timeout_id) {
+		g_source_remove (priv->act_dep_timeout_id);
+		priv->act_dep_timeout_id = 0;
+	}
+
 	priv->ip4_ready = priv->ip6_ready = FALSE;
 
 	iface = nm_device_get_iface (self);
@@ -1511,6 +1596,8 @@ real_act_stage3_ip4_config_start (NMDevice *self, NMDeviceStateReason *reason)
 	/* If we did not receive IP4 configuration information, default to DHCP */
 	if (s_ip4)
 		method = nm_setting_ip4_config_get_method (s_ip4);
+	else if (nm_connection_is_type (connection, NM_SETTING_BOND_SETTING_NAME))
+		method = NM_SETTING_IP4_CONFIG_METHOD_DISABLED;
 
 	if (!s_ip4 || !method || !strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_AUTO)) {
 		guint8 *anycast = NULL;
@@ -1662,7 +1749,6 @@ static NMActStageReturn
 real_act_stage3_ip6_config_start (NMDevice *self, NMDeviceStateReason *reason)
 {
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
-	const char *ip_iface;
 	NMActStageReturn ret = NM_ACT_STAGE_RETURN_FAILURE;
 	NMActRequest *req;
 	NMConnection *connection;
@@ -1674,8 +1760,6 @@ real_act_stage3_ip6_config_start (NMDevice *self, NMDeviceStateReason *reason)
 	connection = nm_act_request_get_connection (req);
 	g_assert (connection);
 
-	ip_iface = nm_device_get_ip_iface (self);
-
 	update_accept_ra_save (self);
 
 	priv->dhcp6_mode = IP6_DHCP_OPT_NONE;
@@ -1728,6 +1812,7 @@ static gboolean
 nm_device_activate_stage3_ip_config_start (gpointer user_data)
 {
 	NMDevice *self = NM_DEVICE (user_data);
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 	const char *iface;
 	NMActStageReturn ret;
 	NMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;
@@ -1763,6 +1848,15 @@ nm_device_activate_stage3_ip_config_start (gpointer user_data)
 
 out:
 	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 3 of 5 (IP Configure Start) complete.", iface);
+
+	/* Handle interfaces (bond slaves, etc) that won't have any IP config; they
+	 * need to move to ACTIVATED.
+	 */
+	if (priv->ip4_ready && priv->ip6_ready) {
+		/* FIXME: call layer2 stuff to set MTU? */
+		nm_device_state_changed (self, NM_DEVICE_STATE_ACTIVATED, NM_DEVICE_STATE_REASON_NONE);
+	}
+
 	return FALSE;
 }
 
@@ -2122,15 +2216,11 @@ real_act_stage4_get_ip6_config (NMDevice *self,
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 	NMConnection *connection;
 	NMSettingIP6Config *s_ip6;
-	const char *ip_iface;
 
 	g_return_val_if_fail (config != NULL, NM_ACT_STAGE_RETURN_FAILURE);
 	g_return_val_if_fail (*config == NULL, NM_ACT_STAGE_RETURN_FAILURE);
 	g_return_val_if_fail (reason != NULL, NM_ACT_STAGE_RETURN_FAILURE);
 
-	/* Use the IP interface (not the control interface) for IP stuff */
-	ip_iface = nm_device_get_ip_iface (self);
-
 	connection = nm_act_request_get_connection (nm_device_get_act_request (self));
 	g_assert (connection);
 
@@ -2650,22 +2740,16 @@ clear_act_request (NMDevice *self)
 }
 
 static void
-delayed_transitions_clear (NMDevice *self)
+queued_state_clear (NMDevice *self)
 {
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
-
-	if (priv->failed_to_disconnected_id) {
-		nm_log_dbg (LOGD_DEVICE, "(%s): clearing failed->disconnected transition",
-		            nm_device_get_iface (self));
-		g_source_remove (priv->failed_to_disconnected_id);
-		priv->failed_to_disconnected_id = 0;
-	}
-	if (priv->unavailable_to_disconnected_id) {
-		nm_log_dbg (LOGD_DEVICE, "(%s): clearing unavailable->disconnected transition",
-		            nm_device_get_iface (self));
-		g_source_remove (priv->unavailable_to_disconnected_id);
-		priv->unavailable_to_disconnected_id = 0;
+	if (priv->queued_state.id) {
+		nm_log_dbg (LOGD_DEVICE, "(%s): clearing queued state transition (id %d)",
+		            nm_device_get_iface (self), priv->queued_state.id);
+		g_source_remove (priv->queued_state.id);
 	}
+
+	memset (&priv->queued_state, 0, sizeof (priv->queued_state));
 }
 
 static void
@@ -2770,8 +2854,17 @@ nm_device_deactivate_quickly (NMDevice *self)
 	activation_source_clear (self, TRUE, AF_INET);
 	activation_source_clear (self, TRUE, AF_INET6);
 
-	/* Clear any delayed transitions */
-	delayed_transitions_clear (self);
+	if (priv->act_dep_result_id) {
+		g_source_remove (priv->act_dep_result_id);
+		priv->act_dep_result_id = 0;
+	}
+	if (priv->act_dep_timeout_id) {
+		g_source_remove (priv->act_dep_timeout_id);
+		priv->act_dep_timeout_id = 0;
+	}
+
+	/* Clear any queued transitions */
+	queued_state_clear (self);
 
 	dhcp4_cleanup (self, TRUE);
 	dhcp6_cleanup (self, TRUE);
@@ -2906,6 +2999,61 @@ device_activation_precheck (NMDevice *self, NMConnection *connection, GError **e
 }
 
 static gboolean
+act_dep_timeout_cb (gpointer user_data)
+{
+	NMDevice *self = NM_DEVICE (user_data);
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+	NMConnection *connection;
+
+	connection = nm_act_request_get_connection (priv->act_request);
+	nm_log_warn (LOGD_DEVICE,
+	             "Activation (%s) connection '%s' dependency timed out",
+	             nm_device_get_iface (self),
+	             nm_connection_get_id (connection));
+
+	nm_device_queue_state (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED);
+	return FALSE;
+}
+
+static void
+act_dep_result_cb (NMActRequest *req,
+                   NMActRequestDependencyResult result,
+                   NMDevice *self)
+{
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+	NMConnection *connection;
+
+	connection = nm_act_request_get_connection (priv->act_request);
+
+	switch (result) {
+	case NM_ACT_REQUEST_DEP_RESULT_FAILED:
+		g_source_remove (priv->act_dep_result_id);
+		priv->act_dep_result_id = 0;
+
+		nm_log_warn (LOGD_DEVICE,
+			         "Activation (%s) connection '%s' dependency failed",
+			         nm_device_get_iface (self),
+			         nm_connection_get_id (connection));
+		nm_device_queue_state (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED);
+		break;
+	case NM_ACT_REQUEST_DEP_RESULT_READY:
+		g_warn_if_fail (priv->state == NM_DEVICE_STATE_PREPARE);
+		if (priv->state == NM_DEVICE_STATE_PREPARE) {
+			nm_log_info (LOGD_DEVICE,
+					     "Activation (%s) connection '%s' dependency ready, continuing activation",
+					     nm_device_get_iface (self),
+					     nm_connection_get_id (connection));
+			nm_device_activate_schedule_stage1_device_prepare (self);
+		}
+		break;
+	case NM_ACT_REQUEST_DEP_RESULT_WAIT:
+	default:
+		g_assert_not_reached ();
+		break;
+	}
+}
+
+static gboolean
 nm_device_activate (NMDeviceInterface *device,
                     NMActRequest *req,
                     GError **error)
@@ -2929,13 +3077,47 @@ nm_device_activate (NMDeviceInterface *device,
 									    device);
 
 	if (!nm_act_request_get_assumed (req)) {
+		NMActRequest *dep_ac;
+		NMConnection *dep_con, *connection;
+
+		connection = nm_act_request_get_connection (req);
+		g_assert (connection);
+
 		/* HACK: update the state a bit early to avoid a race between the 
 		 * scheduled stage1 handler and nm_policy_device_change_check() thinking
 		 * that the activation request isn't deferred because the deferred bit
 		 * gets cleared a bit too early, when the connection becomes valid.
 		 */
 		nm_device_state_changed (self, NM_DEVICE_STATE_PREPARE, NM_DEVICE_STATE_REASON_NONE);
-		nm_device_activate_schedule_stage1_device_prepare (self);
+
+		/* Handle any dependencies this connection might have */
+		switch (nm_act_request_get_dependency_result (priv->act_request)) {
+		case NM_ACT_REQUEST_DEP_RESULT_FAILED:
+			nm_device_queue_state (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED);
+			break;
+		case NM_ACT_REQUEST_DEP_RESULT_WAIT:
+			dep_ac = nm_act_request_get_dependency (priv->act_request);
+			g_assert (dep_ac);
+			dep_con = nm_act_request_get_connection (dep_ac);
+			g_assert (dep_con);
+			nm_log_info (LOGD_DEVICE, "Activation (%s) connection '%s' waiting on dependency '%s'",
+						 nm_device_get_iface (self),
+						 nm_connection_get_id (connection),
+						 nm_connection_get_id (dep_con));
+
+			priv->act_dep_result_id = g_signal_connect (priv->act_request,
+					                                    NM_ACT_REQUEST_DEPENDENCY_RESULT,
+					                                    G_CALLBACK (act_dep_result_cb),
+					                                    self);
+			priv->act_dep_timeout_id = g_timeout_add_seconds (60, act_dep_timeout_cb, self);
+			break;
+		default:
+			g_warn_if_reached ();
+			/* fall through */
+		case NM_ACT_REQUEST_DEP_RESULT_READY:
+			nm_device_activate_schedule_stage1_device_prepare (self);
+			break;
+		}
 	} else {
 		/* If it's an assumed connection, let the device subclass short-circuit
 		 * the normal connection process and just copy its IP configs from the
@@ -2983,7 +3165,6 @@ nm_device_is_activating (NMDevice *device)
 	return FALSE;
 }
 
-
 gboolean
 nm_device_can_interrupt_activation (NMDevice *self)
 {
@@ -3347,8 +3528,8 @@ dispose (GObject *object)
 		}
 	}
 
-	/* Clear any delayed transitions */
-	delayed_transitions_clear (self);
+	/* Clear any queued transitions */
+	queued_state_clear (self);
 
 	/* Clean up and stop DHCP */
 	dhcp4_cleanup (self, take_down);
@@ -3408,7 +3589,11 @@ set_property (GObject *object, guint prop_id,
  
 	switch (prop_id) {
 	case NM_DEVICE_INTERFACE_PROP_UDI:
-		/* construct-only */
+		/* Only virtual interfaces can set UDI post-construction */
+		if (priv->initialized)
+			g_return_if_fail (nm_system_get_iface_type (priv->ifindex, NULL) != NM_IFACE_TYPE_UNSPEC);
+
+		g_free (priv->udi);
 		priv->udi = g_strdup (g_value_get_string (value));
 		break;
 	case NM_DEVICE_INTERFACE_PROP_IFACE:
@@ -3654,32 +3839,6 @@ nm_device_class_init (NMDeviceClass *klass)
 		              G_TYPE_BOOLEAN, 0);
 }
 
-static gboolean
-failed_to_disconnected (gpointer user_data)
-{
-	NMDevice *self = NM_DEVICE (user_data);
-	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
-
-	nm_log_dbg (LOGD_DEVICE, "(%s): running failed->disconnected transition",
-	            nm_device_get_iface (self));
-	priv->failed_to_disconnected_id = 0;
-	nm_device_state_changed (self, NM_DEVICE_STATE_DISCONNECTED, NM_DEVICE_STATE_REASON_NONE);
-	return FALSE;
-}
-
-static gboolean
-unavailable_to_disconnected (gpointer user_data)
-{
-	NMDevice *self = NM_DEVICE (user_data);
-	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
-
-	nm_log_dbg (LOGD_DEVICE, "(%s): running unavailable->disconnected transition",
-	            nm_device_get_iface (self));
-	priv->unavailable_to_disconnected_id = 0;
-	nm_device_state_changed (self, NM_DEVICE_STATE_DISCONNECTED, NM_DEVICE_STATE_REASON_NONE);
-	return FALSE;
-}
-
 void
 nm_device_set_firmware_missing (NMDevice *self, gboolean new_missing)
 {
@@ -3727,8 +3886,8 @@ nm_device_state_changed (NMDevice *device,
 	nm_log_info (LOGD_DEVICE, "(%s): device state change: %d -> %d (reason %d)",
 	             nm_device_get_iface (device), old_state, state, reason);
 
-	/* Clear any delayed transitions */
-	delayed_transitions_clear (device);
+	/* Clear any queued transitions */
+	queued_state_clear (device);
 
 	/* Cache the activation request for the dispatcher */
 	req = priv->act_request ? g_object_ref (priv->act_request) : NULL;
@@ -3781,12 +3940,21 @@ nm_device_state_changed (NMDevice *device,
 		if (nm_device_is_available (device)) {
 			nm_log_dbg (LOGD_DEVICE, "(%s): device is available, will transition to DISCONNECTED",
 			            nm_device_get_iface (device));
-			priv->unavailable_to_disconnected_id = g_idle_add (unavailable_to_disconnected, device);
+			nm_device_queue_state (device, NM_DEVICE_STATE_DISCONNECTED, NM_DEVICE_STATE_REASON_NONE);
 		} else {
 			nm_log_dbg (LOGD_DEVICE, "(%s): device not yet available for transition to DISCONNECTED",
 			            nm_device_get_iface (device));
 		}
 		break;
+	case NM_DEVICE_STATE_DISCONNECTED:
+		if (old_state != NM_DEVICE_STATE_UNAVAILABLE) {
+			/* Sometimes disconnecting a device takes it down (like bond slaves)
+			 * so make sure it's back up here so carrier detection works.
+			 */
+			if (!nm_device_bring_up (device, TRUE, &no_firmware) && no_firmware)
+				nm_log_warn (LOGD_HW, "(%s): firmware may be missing.", nm_device_get_iface (device));
+		}
+		break;
 	case NM_DEVICE_STATE_ACTIVATED:
 		nm_log_info (LOGD_DEVICE, "Activation (%s) successful, device activated.",
 		             nm_device_get_iface (device));
@@ -3798,7 +3966,7 @@ nm_device_state_changed (NMDevice *device,
 		 * immediately becuase we can't change states again from the state
 		 * handler for a variety of reasons.
 		 */
-		priv->failed_to_disconnected_id = g_idle_add (failed_to_disconnected, device);
+		nm_device_queue_state (device, NM_DEVICE_STATE_DISCONNECTED, NM_DEVICE_STATE_REASON_NONE);
 		break;
 	default:
 		break;
@@ -3812,6 +3980,51 @@ nm_device_state_changed (NMDevice *device,
 		g_object_unref (req);
 }
 
+static gboolean
+queued_set_state (gpointer user_data)
+{
+	NMDevice *self = NM_DEVICE (user_data);
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+
+	if (priv->queued_state.id) {
+		priv->queued_state.id = 0;
+
+		nm_log_dbg (LOGD_DEVICE, "(%s): running queued state change to %d (id %d)",
+		            nm_device_get_iface (self),
+		            priv->queued_state.state,
+		            priv->queued_state.id);
+		nm_device_state_changed (self, priv->queued_state.state, priv->queued_state.reason);
+	}
+	queued_state_clear (self);
+	return FALSE;
+}
+
+void
+nm_device_queue_state (NMDevice *self,
+                       NMDeviceState state,
+                       NMDeviceStateReason reason)
+{
+	NMDevicePrivate *priv;
+
+	g_return_if_fail (self != NULL);
+	g_return_if_fail (NM_IS_DEVICE (self));
+
+	priv = NM_DEVICE_GET_PRIVATE (self);
+
+	/* We should only ever have one delayed state transition at a time */
+	if (priv->queued_state.id) {
+		g_warn_if_fail (priv->queued_state.id == 0);
+		queued_state_clear (self);
+	}
+
+	priv->queued_state.state = state;
+	priv->queued_state.reason = reason;
+	priv->queued_state.id = g_idle_add (queued_set_state, self);
+
+	nm_log_dbg (LOGD_DEVICE, "(%s): queued state change to (id %d)",
+	            nm_device_get_iface (self), priv->queued_state.id);
+}
+
 NMDeviceState
 nm_device_get_state (NMDevice *device)
 {
@@ -3869,6 +4082,96 @@ spec_match_list (NMDeviceInterface *device, const GSList *specs)
 	return FALSE;
 }
 
+static gboolean
+ip4_match_config (NMDevice *self, NMConnection *connection)
+{
+	NMSettingIP4Config *s_ip4;
+	int i, num;
+	GSList *leases, *iter;
+	NMDHCPManager *dhcp_mgr;
+	const char *method;
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	if (!s_ip4)
+		return FALSE;
+
+	/* Get any saved leases that apply to this connection */
+	dhcp_mgr = nm_dhcp_manager_get ();
+	leases = nm_dhcp_manager_get_lease_config (dhcp_mgr,
+	                                           nm_device_get_iface (self),
+	                                           nm_connection_get_uuid (connection));
+	g_object_unref (dhcp_mgr);
+
+	method = nm_setting_ip4_config_get_method (s_ip4);
+	if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_AUTO)) {
+		gboolean found = FALSE;
+
+		/* Find at least one lease's address on the device */
+		for (iter = leases; iter; iter = g_slist_next (iter)) {
+			NMIP4Config *ip4_config = iter->data;
+			NMIP4Address *addr = nm_ip4_config_get_address (ip4_config, 0);
+			struct in_addr tmp = { .s_addr = nm_ip4_address_get_address (addr) };
+
+			if (addr && nm_netlink_find_address (nm_device_get_ip_ifindex (self),
+			                                     AF_INET,
+			                                     &tmp,
+			                                     nm_ip4_address_get_prefix (addr))) {
+				found = TRUE; /* Yay, device has same address as a lease */
+				break;
+			}
+		}
+		g_slist_foreach (leases, (GFunc) g_object_unref, NULL);
+		g_slist_free (leases);
+		return found;
+	} else {
+		/* Maybe the connection used to be DHCP and there are stale leases; ignore them */
+		g_slist_foreach (leases, (GFunc) g_object_unref, NULL);
+		g_slist_free (leases);
+	}
+
+	if (!strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_DISABLED)) {
+		// FIXME: Enforce no ipv4 addresses?
+		return TRUE;
+	}
+
+	/* 'shared' and 'link-local' aren't supported methods because 'shared'
+	 * requires too much iptables and dnsmasq state to be reclaimed, and
+	 * avahi-autoipd isn't smart enough to allow the link-local address to be
+	 * determined at any point other than when it was first assigned.
+	 */
+	if (strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_MANUAL))
+		return FALSE;
+
+	/* Everything below for static addressing */
+
+	/* Find all IP4 addresses of this connection on the device */
+	num = nm_setting_ip4_config_get_num_addresses (s_ip4);
+	for (i = 0; i < num; i++) {
+		NMIP4Address *addr = nm_setting_ip4_config_get_address (s_ip4, i);
+		struct in_addr tmp = { .s_addr = nm_ip4_address_get_address (addr) };
+
+		if (!nm_netlink_find_address (nm_device_get_ip_ifindex (self),
+		                              AF_INET,
+		                              &tmp,
+		                              nm_ip4_address_get_prefix (addr)))
+			return FALSE;
+	}
+
+	/* Success; all the connection's static IP addresses are assigned to the device */
+	return TRUE;
+}
+
+gboolean
+nm_device_match_ip_config (NMDevice *device, NMConnection *connection)
+{
+	if (!ip4_match_config (device, connection))
+		return FALSE;
+
+	/* FIXME: match IPv6 config */
+
+	return TRUE;
+}
+
 static NMConnection *
 connection_match_config (NMDeviceInterface *device, const GSList *connections)
 {
diff --git a/src/nm-device.h b/src/nm-device.h
index ca067f4..84b4750 100644
--- a/src/nm-device.h
+++ b/src/nm-device.h
@@ -120,6 +120,12 @@ typedef struct {
 	gboolean        (* spec_match_list)     (NMDevice *self, const GSList *specs);
 
 	NMConnection *  (* connection_match_config) (NMDevice *self, const GSList *connections);
+
+	gboolean        (* enslave_slave) (NMDevice *self,
+	                                   NMDevice *slave);
+
+	gboolean        (* release_slave) (NMDevice *self,
+	                                   NMDevice *slave);
 } NMDeviceClass;
 
 
@@ -151,9 +157,13 @@ NMDHCP6Config * nm_device_get_dhcp6_config (NMDevice *dev);
 NMIP4Config *	nm_device_get_ip4_config	(NMDevice *dev);
 NMIP6Config *	nm_device_get_ip6_config	(NMDevice *dev);
 
+gboolean        nm_device_enslave_slave     (NMDevice *dev, NMDevice *slave);
+gboolean        nm_device_release_slave     (NMDevice *dev, NMDevice *slave);
+
 void *		nm_device_get_system_config_data	(NMDevice *dev);
 
 NMActRequest *	nm_device_get_act_request	(NMDevice *dev);
+NMConnection *  nm_device_get_connection	(NMDevice *dev);
 
 gboolean		nm_device_is_available (NMDevice *dev);
 
@@ -161,6 +171,10 @@ NMConnection * nm_device_get_best_auto_connection (NMDevice *dev,
                                                    GSList *connections,
                                                    char **specific_object);
 
+void nm_device_queue_state   (NMDevice *self,
+                              NMDeviceState state,
+                              NMDeviceStateReason reason);
+
 void			nm_device_activate_schedule_stage1_device_prepare		(NMDevice *device);
 void			nm_device_activate_schedule_stage2_device_config		(NMDevice *device);
 void			nm_device_activate_schedule_stage4_ip4_config_get		(NMDevice *device);
diff --git a/src/nm-manager.c b/src/nm-manager.c
index f151a83..4d03af7 100644
--- a/src/nm-manager.c
+++ b/src/nm-manager.c
@@ -38,6 +38,7 @@
 #include "nm-device-olpc-mesh.h"
 #include "nm-device-cdma.h"
 #include "nm-device-gsm.h"
+#include "nm-device-bond.h"
 #include "nm-system.h"
 #include "nm-properties-changed-signal.h"
 #include "nm-setting-bluetooth.h"
@@ -132,6 +133,7 @@ static const char *internal_activate_device (NMManager *manager,
                                              const char *specific_object,
                                              gboolean user_requested,
                                              gboolean assumed,
+                                             NMActRequest *dependency,
                                              GError **error);
 
 static NMDevice *find_device_by_iface (NMManager *self, const gchar *iface);
@@ -287,6 +289,7 @@ typedef enum
 	NM_MANAGER_ERROR_CONNECTION_NOT_ACTIVE,
 	NM_MANAGER_ERROR_ALREADY_ASLEEP_OR_AWAKE,
 	NM_MANAGER_ERROR_ALREADY_ENABLED_OR_DISABLED,
+	NM_MANAGER_ERROR_DEPENDENCY_FAILED,
 } NMManagerError;
 
 #define NM_MANAGER_ERROR (nm_manager_error_quark ())
@@ -331,6 +334,8 @@ nm_manager_error_get_type (void)
 			ENUM_ENTRY (NM_MANAGER_ERROR_ALREADY_ASLEEP_OR_AWAKE, "AlreadyAsleepOrAwake"),
 			/* The manager is already in the requested enabled/disabled state */
 			ENUM_ENTRY (NM_MANAGER_ERROR_ALREADY_ENABLED_OR_DISABLED, "AlreadyEnabledOrDisabled"),
+			/* A dependency of this connection failed. */
+			ENUM_ENTRY (NM_MANAGER_ERROR_DEPENDENCY_FAILED, "DependencyFailed"),
 			{ 0, 0, 0 },
 		};
 		etype = g_enum_register_static ("NMManagerError", values);
@@ -695,13 +700,14 @@ pending_activation_new (NMManager *manager,
 	pending->context = context;
 	pending->callback = callback;
 
-	pending->device_path = g_strdup (device_path);
 	pending->scope = scope;
 	pending->connection_path = g_strdup (connection_path);
 
 	/* "/" is special-cased to NULL to get through D-Bus */
 	if (specific_object_path && strcmp (specific_object_path, "/"))
 		pending->specific_object_path = g_strdup (specific_object_path);
+	if (device_path && strcmp (device_path, "/"))
+		pending->device_path = g_strdup (device_path);
 
 	return pending;
 }
@@ -1455,6 +1461,133 @@ user_proxy_init (NMManager *self)
 /* System settings stuff via NMSysconfigSettings                   */
 /*******************************************************************/
 
+/**
+ * get_virtual_iface_name:
+ * @self: the #NMManager
+ * @connection: the #NMConnection representing a virtual interface
+ * @out_parent: on success, the parent device if any
+ *
+ * Given @connection, returns the interface name that the connection
+ * would represent.  If the interface name is not given by the connection,
+ * this may require constructing it based on information in the connection
+ * and existing network interfaces.
+ *
+ * Returns: the expected interface name (caller takes ownership), or %NULL
+ */
+static char *
+get_virtual_iface_name (NMManager *self,
+                        NMConnection *connection,
+                        NMDevice **out_parent)
+{
+	char *vname = NULL;
+
+	if (out_parent)
+		*out_parent = NULL;
+
+	if (nm_connection_is_type (connection, NM_SETTING_BOND_SETTING_NAME))
+		return g_strdup (nm_connection_get_virtual_iface_name (connection));
+
+	return vname;
+}
+
+static gboolean
+connection_needs_virtual_device (NMConnection *connection)
+{
+	if (nm_connection_is_type (connection, NM_SETTING_BOND_SETTING_NAME))
+		return TRUE;
+
+	return FALSE;
+}
+
+static char *
+get_virtual_iface_placeholder_udi (void)
+{
+	static guint32 id = 0;
+
+	return g_strdup_printf ("/virtual/device/placeholder/%d", id++);
+}
+
+/**
+ * system_create_virtual_device:
+ * @self: the #NMManager
+ * @connection: the connection which might require a virtual device
+ *
+ * If @connection requires a virtual device and one does not yet exist for it,
+ * creates that device.
+ *
+ * Returns: the #NMDevice if successfully created, NULL if not
+ */
+static NMDevice *
+system_create_virtual_device (NMManager *self, NMConnection *connection)
+{
+	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
+	GSList *iter;
+	char *iface = NULL, *udi;
+	NMDevice *device = NULL, *parent = NULL;
+
+	iface = get_virtual_iface_name (self, connection, &parent);
+	if (!iface) {
+		nm_log_warn (LOGD_DEVICE, "(%s) failed to determine virtual interface name",
+		             nm_connection_get_id (connection));
+		return NULL;
+	}
+
+	/* Make sure we didn't create a device for this connection already */
+	for (iter = priv->devices; iter; iter = g_slist_next (iter)) {
+		NMDevice *candidate = iter->data;
+		GError *error = NULL;
+
+		if (   g_strcmp0 (nm_device_get_iface (candidate), iface) == 0
+		    || nm_device_interface_check_connection_compatible (NM_DEVICE_INTERFACE (candidate), connection, &error)) {
+			g_clear_error (&error);
+			goto out;
+		}
+		g_clear_error (&error);
+	}
+
+	if (nm_connection_is_type (connection, NM_SETTING_BOND_SETTING_NAME)) {
+		if (!nm_system_add_bonding_master (iface)) {
+			nm_log_warn (LOGD_DEVICE, "(%s): failed to add bonding master interface for '%s'",
+			             iface, nm_connection_get_id (connection));
+			goto out;
+		}
+
+		udi = get_virtual_iface_placeholder_udi ();
+		device = nm_device_bond_new (udi, iface);
+		g_free (udi);
+	}
+
+	if (device)
+		add_device (self, device);
+
+out:
+	g_free (iface);
+	return device;
+}
+
+static void
+system_create_virtual_devices (NMManager *self)
+{
+	GSList *iter, *connections;
+
+	nm_log_dbg (LOGD_CORE, "creating virtual devices...");
+
+	connections = nm_manager_get_connections (self, NM_CONNECTION_SCOPE_SYSTEM, FALSE);
+	connections = g_slist_concat (connections,  nm_manager_get_connections (self, NM_CONNECTION_SCOPE_USER, FALSE));
+	for (iter = connections; iter; iter = g_slist_next (iter)) {
+		NMConnection *connection = iter->data;
+		NMSettingConnection *s_con = nm_connection_get_setting_connection (connection);
+
+		g_assert (s_con);
+		if (connection_needs_virtual_device (connection)) {
+			/* We only create a virtual interface if the connection can autoconnect */
+			if (nm_setting_connection_get_autoconnect (s_con))
+				system_create_virtual_device (self, connection);
+		}
+	}
+	g_slist_free (connections);
+}
+
 static void
 system_connection_updated_cb (NMSettingsConnectionInterface *connection,
                               gpointer unused,
@@ -1531,6 +1664,9 @@ system_new_connection_cb (NMSysconfigSettings *settings,
                           NMManager *manager)
 {
 	system_internal_new_connection (manager, connection);
+
+	if (connection_needs_virtual_device (NM_CONNECTION (connection)))
+		system_create_virtual_device (manager, NM_CONNECTION (connection));
 }
 
 static void
@@ -1619,6 +1755,24 @@ nm_manager_get_device_by_path (NMManager *manager, const char *path)
 	return NULL;
 }
 
+NMDevice *
+nm_manager_get_device_by_master (NMManager *manager, const char *master, const char *driver)
+{
+	GSList *iter;
+
+	g_return_val_if_fail (master != NULL, NULL);
+
+	for (iter = NM_MANAGER_GET_PRIVATE (manager)->devices; iter; iter = iter->next) {
+		NMDevice *device = NM_DEVICE (iter->data);
+
+		if (!strcmp (nm_device_get_iface (device), master) &&
+		    (!driver || !strcmp (nm_device_get_driver (device), driver)))
+			return device;
+	}
+
+	return NULL;
+}
+
 static void
 nm_manager_name_owner_changed (NMDBusManager *mgr,
                                const char *name,
@@ -2230,6 +2384,11 @@ add_device (NMManager *self, NMDevice *device)
 	nm_sysconfig_settings_device_added (priv->sys_settings, device);
 	g_signal_emit (self, signals[DEVICE_ADDED], 0, device);
 
+	/* New devices might be master interfaces for virtual interfaces; so we may
+	 * need to create new virtual interfaces now.
+	 */
+	system_create_virtual_devices (self);
+
 	/* If the device has a connection it can assume, do that now */
 	if (existing && managed && nm_device_is_available (device)) {
 		const char *ac_path;
@@ -2238,7 +2397,7 @@ add_device (NMManager *self, NMDevice *device)
 		nm_log_dbg (LOGD_DEVICE, "(%s): will attempt to assume existing connection",
 		            nm_device_get_iface (device));
 
-		ac_path = internal_activate_device (self, device, existing, NULL, FALSE, TRUE, &error);
+		ac_path = internal_activate_device (self, device, existing, NULL, FALSE, TRUE, NULL, &error);
 		if (ac_path)
 			g_object_notify (G_OBJECT (self), NM_MANAGER_ACTIVE_CONNECTIONS);
 		else {
@@ -2448,6 +2607,21 @@ find_device_by_iface (NMManager *self, const gchar *iface)
 }
 
 static NMDevice *
+find_device_by_ip_iface (NMManager *self, const gchar *iface)
+{
+	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
+	GSList *iter;
+
+	for (iter = priv->devices; iter; iter = g_slist_next (iter)) {
+		NMDevice *candidate = iter->data;
+
+		if (g_strcmp0 (nm_device_get_ip_iface (candidate), iface) == 0)
+			return candidate;
+	}
+	return NULL;
+}
+
+static NMDevice *
 find_device_by_ifindex (NMManager *self, guint32 ifindex)
 {
 	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
@@ -2538,8 +2712,6 @@ nm_manager_get_act_request_by_path (NMManager *manager,
 
 	g_return_val_if_fail (manager != NULL, NULL);
 	g_return_val_if_fail (path != NULL, NULL);
-	g_return_val_if_fail (device != NULL, NULL);
-	g_return_val_if_fail (*device == NULL, NULL);
 
 	for (iter = priv->devices; iter; iter = g_slist_next (iter)) {
 		NMActRequest *req;
@@ -2551,7 +2723,8 @@ nm_manager_get_act_request_by_path (NMManager *manager,
 
 		ac_path = nm_act_request_get_active_connection_path (req);
 		if (!strcmp (path, ac_path)) {
-			*device = NM_DEVICE (iter->data);
+			if (device)
+				*device = NM_DEVICE (iter->data);
 			return req;
 		}
 	}
@@ -2856,6 +3029,7 @@ internal_activate_device (NMManager *manager,
                           const char *specific_object,
                           gboolean user_requested,
                           gboolean assumed,
+                          NMActRequest *dependency,
                           GError **error)
 {
 	NMActRequest *req;
@@ -2879,7 +3053,7 @@ internal_activate_device (NMManager *manager,
 		                         NM_DEVICE_STATE_REASON_NONE);
 	}
 
-	req = nm_act_request_new (connection, specific_object, user_requested, assumed, (gpointer) device);
+	req = nm_act_request_new (connection, specific_object, user_requested, assumed, (gpointer) device, dependency);
 	g_signal_connect (req, "manager-get-secrets", G_CALLBACK (provider_get_secrets), manager);
 	g_signal_connect (req, "manager-cancel-secrets", G_CALLBACK (provider_cancel_secrets), manager);
 	success = nm_device_interface_activate (dev_iface, req, error);
@@ -2909,6 +3083,354 @@ wait_for_connection_expired (gpointer data)
 	return FALSE;
 }
 
+static NMConnection *
+get_connection_by_uuid (NMManager *self, const char *uuid)
+{
+	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
+	NMConnection *connection;
+	GHashTableIter iter;
+
+	g_return_val_if_fail (uuid != NULL, NULL);
+
+	/* Try system connections first */
+	g_hash_table_iter_init (&iter, priv->system_connections);
+	while (g_hash_table_iter_next (&iter, NULL, (gpointer) &connection)) {
+		if (g_strcmp0 (nm_connection_get_uuid (connection), uuid) == 0)
+			return connection;
+	}
+
+	/* Then user connections */
+	g_hash_table_iter_init (&iter, priv->user_connections);
+	while (g_hash_table_iter_next (&iter, NULL, (gpointer) &connection)) {
+		if (g_strcmp0 (nm_connection_get_uuid (connection), uuid) == 0)
+			return connection;
+	}
+
+	return NULL;
+}
+
+/**
+ * find_master:
+ * @self: #NMManager object
+ * @connection: the #NMConnection to find the master connection and device for
+ * @device: the #NMDevice, if any, which will activate @connection
+ * @out_master_connection: on success, the master connection of @connection if
+ *   that master connection was found
+ * @out_master_device: on success, the master device of @connection if that
+ *   master device was found
+ *
+ * Given an #NMConnection, attempts to find its master connection and/or its
+ * master device.  This function may return a master connection, a master device,
+ * or both.  If only a connection is returned, that master connection is not
+ * currently active on any device.  If only a device is returned, that device
+ * is not currently activated with any connection.  If both are returned, then
+ * the device is currently activated or activating with the returned master
+ * connection.
+ *
+ * Returns: %TRUE if the master device and/or connection could be found or if
+ *  the connection did not require a master, %FALSE otherwise
+ **/
+static gboolean
+find_master (NMManager *self,
+             NMConnection *connection,
+             NMDevice *device,
+             NMConnection **out_master_connection,
+             NMDevice **out_master_device)
+{
+	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
+	NMSettingConnection *s_con;
+	const char *master;
+	NMDevice *master_device = NULL;
+	NMConnection *master_connection = NULL;
+	GSList *iter, *connections = NULL;
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	master = nm_setting_connection_get_master (s_con);
+
+	if (master == NULL)
+		return TRUE;  /* success, but no master */
+
+	/* Try as an interface name first */
+	master_device = find_device_by_ip_iface (self, master);
+	if (master_device) {
+		/* A device obviously can't be its own master */
+		if (master_device == device)
+			return FALSE;
+	} else {
+		/* Try master as a connection UUID */
+		master_connection = get_connection_by_uuid (self, master);
+		if (master_connection) {
+			/* Check if the master connection is activated on some device already */
+			for (iter = priv->devices; iter; iter = g_slist_next (iter)) {
+				NMDevice *candidate = NM_DEVICE (iter->data);
+
+				if (candidate == device)
+					continue;
+
+				if (nm_device_get_connection (candidate) == master_connection) {
+					master_device = candidate;
+					break;
+				}
+			}
+		} else {
+			/* Might be a virtual interface that hasn't been created yet, so
+			 * look through the interface names of connections that require
+			 * virtual interfaces and see if one of their virtual interface
+			 * names matches the master.
+			 */
+			connections = nm_manager_get_connections (self, NM_CONNECTION_SCOPE_SYSTEM, FALSE);
+			connections = g_slist_concat (connections, nm_manager_get_connections (self, NM_CONNECTION_SCOPE_USER, FALSE));
+			for (iter = connections; iter && !master_connection; iter = g_slist_next (iter)) {
+				NMConnection *candidate = iter->data;
+				char *vname;
+
+				if (connection_needs_virtual_device (candidate)) {
+					vname = get_virtual_iface_name (self, candidate, NULL);
+					if (g_strcmp0 (master, vname) == 0)
+						master_connection = candidate;
+					g_free (vname);
+				}
+			}
+			g_slist_free (connections);
+		}
+	}
+
+	if (out_master_connection)
+		*out_master_connection = master_connection;
+	if (out_master_device)
+		*out_master_device = master_device;
+
+    return master_device || master_connection;
+}
+
+static gboolean
+is_compatible_with_slave (NMConnection *master, NMConnection *slave)
+{
+	NMSettingConnection *s_con;
+
+	g_return_val_if_fail (master, FALSE);
+	g_return_val_if_fail (slave, FALSE);
+
+	s_con = nm_connection_get_setting_connection (slave);
+	g_assert (s_con);
+
+	return nm_connection_is_type (master, nm_setting_connection_get_slave_type (s_con));
+}
+
+/**
+ * ensure_master_active_connection:
+ *
+ * @self: the #NMManager
+ * @user_requested: whether this operation was requested by a user
+ * @connection: the connection that should depend on @master_connection
+ * @device: the #NMDevice, if any, which will activate @connection
+ * @master_connection: the master connection
+ * @master_device: the master device
+ * @error: the error, if an error occurred
+ *
+ * Determines whether a given #NMConnection depends on another connection to
+ * be activated, and if so, finds that master connection or creates it.
+ *
+ * Returns: the master #NMActiveConnection that the caller should depend on, or
+ * %NULL if an error occurred
+ */
+static NMActRequest *
+ensure_master_active_connection (NMManager *self,
+                                 gboolean user_requested,
+                                 NMConnection *connection,
+                                 NMDevice *device,
+                                 NMConnection *master_connection,
+                                 NMDevice *master_device,
+                                 GError **error)
+{
+	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
+	NMActRequest *master_ac = NULL;
+	NMDeviceState master_state;
+	GSList *iter;
+
+	g_assert (connection);
+	g_assert (master_connection || master_device);
+
+	/* If the master device isn't activated then we need to activate it using
+	 * compatible connection.  If it's already activating we can just proceed.
+	 */
+	if (master_device) {
+		/* If we're passed a connection and a device, we require that connection
+		 * be already activated on the device, eg returned from find_master().
+		 */
+		if (master_connection)
+			g_assert (nm_device_get_connection (master_device) == master_connection);
+
+		master_state = nm_device_get_state (master_device);
+		if (   (master_state == NM_DEVICE_STATE_ACTIVATED)
+		    || nm_device_is_activating (master_device)) {
+			/* Device already using master_connection */
+			return nm_device_get_act_request (master_device);
+		}
+
+		/* If the device is disconnected, find a compabile connection and
+		 * activate it on the device.
+		 */
+		if (master_state == NM_DEVICE_STATE_DISCONNECTED) {
+			GSList *connections;
+
+			g_assert (master_connection == NULL);
+
+			/* Find a compatible connection and activate this device using it */
+			connections = nm_manager_get_connections (self, NM_CONNECTION_SCOPE_SYSTEM, FALSE);
+			connections = g_slist_concat (connections, nm_manager_get_connections (self, NM_CONNECTION_SCOPE_USER, FALSE));
+			for (iter = connections; iter; iter = g_slist_next (iter)) {
+				NMConnection *candidate = NM_CONNECTION (iter->data);
+				const char *ac_path;
+
+				/* Ensure eg bond slave and the candidate master is a bond master */
+				if (!is_compatible_with_slave (candidate, connection))
+					continue;
+
+				if (nm_device_interface_check_connection_compatible (NM_DEVICE_INTERFACE (master_device), candidate, NULL)) {
+					ac_path = nm_manager_activate_connection (self,
+					                                            candidate,
+					                                            NULL,
+					                                            nm_device_get_path (master_device),
+					                                            user_requested,
+					                                            error);
+					master_ac = ac_path ? nm_manager_get_act_request_by_path (self, ac_path, NULL) : NULL;
+					g_slist_free (connections);
+					return master_ac;
+				}
+			}
+			g_slist_free (connections);
+
+			g_set_error (error,
+			             NM_MANAGER_ERROR,
+			             NM_MANAGER_ERROR_UNKNOWN_CONNECTION,
+			             "No compatible connection found for master device %s.",
+			             nm_device_get_iface (master_device));
+			return NULL;
+		}
+
+		/* Otherwise, the device is unmanaged, unavailable, or disconnecting */
+		g_set_error (error,
+		             NM_MANAGER_ERROR,
+		             NM_MANAGER_ERROR_UNMANAGED_DEVICE,
+		             "Master device %s unmanaged or not available for activation",
+		             nm_device_get_iface (master_device));
+	} else if (master_connection) {
+		gboolean found_device = FALSE;
+		const char *ac_path;
+
+		/* Find a compatible device and activate it using this connection */
+		for (iter = priv->devices; iter; iter = g_slist_next (iter)) {
+			NMDevice *candidate = NM_DEVICE (iter->data);
+
+			if (candidate == device) {
+				/* A device obviously can't be its own master */
+				continue;
+			}
+
+			if (!nm_device_interface_check_connection_compatible (NM_DEVICE_INTERFACE (candidate), master_connection, NULL))
+				continue;
+
+			found_device = TRUE;
+			master_state = nm_device_get_state (candidate);
+			if (master_state != NM_DEVICE_STATE_DISCONNECTED)
+				continue;
+
+			ac_path = nm_manager_activate_connection (self,
+			                                       master_connection,
+			                                       NULL,
+			                                       nm_device_get_path (candidate),
+			                                       user_requested,
+			                                       error);
+			return ac_path ? nm_manager_get_act_request_by_path (self, ac_path, NULL) : NULL;
+		}
+
+		/* Device described by master_connection may be a virtual one that's
+		 * not created yet.
+		 */
+		if (!found_device && connection_needs_virtual_device (master_connection)) {
+			ac_path = nm_manager_activate_connection (self,
+			                                       master_connection,
+			                                       NULL,
+			                                       NULL,
+			                                       user_requested,
+			                                       error);
+			return ac_path ? nm_manager_get_act_request_by_path (self, ac_path, NULL) : NULL;
+		}
+
+		g_set_error (error,
+		             NM_MANAGER_ERROR,
+		             NM_MANAGER_ERROR_UNKNOWN_DEVICE,
+		             "No compatible disconnected device found for master connection %s.",
+		             nm_connection_get_uuid (master_connection));
+	} else
+		g_assert_not_reached ();
+
+	return NULL;
+}
+
+static const char *
+activate_vpn_connection (NMManager *manager,
+                         NMConnection *connection,
+                         const char *specific_object,
+                         const char *device_path,
+                         GError **error)
+{
+	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (manager);
+	NMVPNConnection *vpn_connection;
+	NMActRequest *req = NULL;
+	NMVPNManager *vpn_manager;
+	NMDevice *device = NULL;
+	const char *path;
+
+	if (specific_object) {
+		/* Find the specifc connection the client requested we use */
+		req = nm_manager_get_act_request_by_path (manager, specific_object, &device);
+		if (!req) {
+			g_set_error_literal (error, NM_MANAGER_ERROR, NM_MANAGER_ERROR_CONNECTION_NOT_ACTIVE,
+			                     "Base connection for VPN connection not active.");
+			return NULL;
+		}
+	} else {
+		GSList *iter;
+
+		/* Just find the current default connection */
+		for (iter = priv->devices; iter; iter = g_slist_next (iter)) {
+			NMDevice *candidate = NM_DEVICE (iter->data);
+			NMActRequest *candidate_req;
+
+			candidate_req = nm_device_get_act_request (candidate);
+			if (candidate_req && nm_act_request_get_default (candidate_req)) {
+				device = candidate;
+				req = candidate_req;
+				break;
+			}
+		}
+	}
+
+	if (!device || !req) {
+		g_set_error_literal (error, NM_MANAGER_ERROR, NM_MANAGER_ERROR_UNKNOWN_DEVICE,
+		                     "Could not find source connection, or the source connection had no active device.");
+		return NULL;
+	}
+
+	vpn_manager = nm_vpn_manager_get ();
+	vpn_connection = nm_vpn_manager_activate_connection (vpn_manager,
+	                                                     connection,
+	                                                     req,
+	                                                     device,
+	                                                     error);
+	g_signal_connect (vpn_connection, "manager-get-secrets",
+	                  G_CALLBACK (provider_get_secrets), manager);
+	g_signal_connect (vpn_connection, "manager-cancel-secrets",
+	                  G_CALLBACK (provider_cancel_secrets), manager);
+	path = nm_vpn_connection_get_active_connection_path (vpn_connection);
+	g_object_unref (vpn_manager);
+
+	return path;
+}
+
 const char *
 nm_manager_activate_connection (NMManager *manager,
                                 NMConnection *connection,
@@ -2920,8 +3442,11 @@ nm_manager_activate_connection (NMManager *manager,
 	NMManagerPrivate *priv;
 	NMDevice *device = NULL;
 	NMSettingConnection *s_con;
-	NMVPNConnection *vpn_connection;
-	const char *path;
+	NMDeviceState state;
+	char *iface;
+	NMDevice *master_device = NULL;
+	NMConnection *master_connection = NULL;
+	NMActRequest *master_ac = NULL;
 
 	g_return_val_if_fail (manager != NULL, NULL);
 	g_return_val_if_fail (connection != NULL, NULL);
@@ -2933,87 +3458,139 @@ nm_manager_activate_connection (NMManager *manager,
 	s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
 	g_assert (s_con);
 
-	if (!strcmp (nm_setting_connection_get_connection_type (s_con), NM_SETTING_VPN_SETTING_NAME)) {
-		NMActRequest *req = NULL;
-		NMVPNManager *vpn_manager;
+	if (!strcmp (nm_setting_connection_get_connection_type (s_con), NM_SETTING_VPN_SETTING_NAME))
+		return activate_vpn_connection (manager, connection, specific_object, device_path, error);
 
-		/* VPN connection */
+	/* Device-based connection */
+	if (device_path) {
+		device = nm_manager_get_device_by_path (manager, device_path);
+		if (!device) {
+			g_set_error_literal (error, NM_MANAGER_ERROR, NM_MANAGER_ERROR_UNKNOWN_DEVICE,
+			                     "Device not found");
+			return NULL;
+		}
 
-		if (specific_object) {
-			/* Find the specifc connection the client requested we use */
-			req = nm_manager_get_act_request_by_path (manager, specific_object, &device);
-			if (!req) {
-				g_set_error (error,
-				             NM_MANAGER_ERROR, NM_MANAGER_ERROR_CONNECTION_NOT_ACTIVE,
-				             "%s", "Base connection for VPN connection not active.");
+		/* If it's a virtual interface make sure the device given by the
+		 * path matches the connection's interface details.
+		 */
+		if (connection_needs_virtual_device (connection)) {
+			iface = get_virtual_iface_name (manager, connection, NULL);
+			if (!iface) {
+				g_set_error_literal (error, NM_MANAGER_ERROR, NM_MANAGER_ERROR_UNKNOWN_DEVICE,
+					                 "Failed to determine connection's virtual interface name");
+				return NULL;
+			} else if (g_strcmp0 (iface, nm_device_get_ip_iface (device)) != 0) {
+				g_set_error_literal (error, NM_MANAGER_ERROR, NM_MANAGER_ERROR_UNKNOWN_DEVICE,
+					                 "Device given by path did not match connection's virtual interface name");
+				g_free (iface);
 				return NULL;
 			}
-		} else {
-			GSList *iter;
+			g_free (iface);
+		}
+	} else {
+		/* Virtual connections (VLAN, bond, etc) may not specify a device
+		 * path because the device may not be created yet, or it be given
+		 * by the connection's properties instead.  Find the device the
+		 * connection refers to, or create it if needed.
+		 */
+		if (!connection_needs_virtual_device (connection)) {
+			g_set_error_literal (error, NM_MANAGER_ERROR, NM_MANAGER_ERROR_UNKNOWN_DEVICE,
+				                 "This connection requires an existing device.");
+			return NULL;
+		}
 
-			/* Just find the current default connection */
-			for (iter = priv->devices; iter; iter = g_slist_next (iter)) {
-				NMDevice *candidate = NM_DEVICE (iter->data);
-				NMActRequest *candidate_req;
+		iface = get_virtual_iface_name (manager, connection, NULL);
+		if (!iface) {
+			g_set_error_literal (error, NM_MANAGER_ERROR, NM_MANAGER_ERROR_UNKNOWN_DEVICE,
+				                 "Failed to determine connection's virtual interface name");
+			return NULL;
+		}
 
-				candidate_req = nm_device_get_act_request (candidate);
-				if (candidate_req && nm_act_request_get_default (candidate_req)) {
-					device = candidate;
-					req = candidate_req;
-					break;
-				}
+		device = find_device_by_iface (manager, iface);
+		if (!device) {
+			/* Create it */
+			device = system_create_virtual_device (manager, connection);
+			if (!device) {
+				g_set_error_literal (error, NM_MANAGER_ERROR, NM_MANAGER_ERROR_UNKNOWN_DEVICE,
+						             "Failed to create virtual interface");
+				return NULL;
 			}
-		}
 
-		if (!device || !req) {
-			g_set_error (error,
-			             NM_MANAGER_ERROR, NM_MANAGER_ERROR_UNKNOWN_DEVICE,
-			             "%s", "Could not find source connection, or the source connection had no active device.");
-			return NULL;
+			/* A newly created device, if allowed to be managed by NM, will be
+			 * in the UNAVAILABLE state here.  Since we want to use it right
+			 * away, we transition it immediately to DISCONNECTED.
+			 */
+			if (   nm_device_is_available (device)
+			    && (nm_device_get_state (device) == NM_DEVICE_STATE_UNAVAILABLE)) {
+				nm_device_state_changed (device,
+				                         NM_DEVICE_STATE_DISCONNECTED,
+				                         NM_DEVICE_STATE_REASON_NONE);
+			}
 		}
+	}
 
-		vpn_manager = nm_vpn_manager_get ();
-		vpn_connection = nm_vpn_manager_activate_connection (vpn_manager,
-		                                                     connection,
-		                                                     req,
-		                                                     device,
-		                                                     error);
-		g_signal_connect (vpn_connection, "manager-get-secrets",
-		                  G_CALLBACK (provider_get_secrets), manager);
-		g_signal_connect (vpn_connection, "manager-cancel-secrets",
-		                  G_CALLBACK (provider_cancel_secrets), manager);
-		path = nm_vpn_connection_get_active_connection_path (vpn_connection);
-		g_object_unref (vpn_manager);
-	} else {
-		NMDeviceState state;
+	state = nm_device_get_state (device);
+	if (state < NM_DEVICE_STATE_DISCONNECTED) {
+		g_set_error_literal (error, NM_MANAGER_ERROR, NM_MANAGER_ERROR_UNMANAGED_DEVICE,
+			                 "Device not managed by NetworkManager or unavailable");
+		return NULL;
+	}
 
-		/* Device-based connection */
-		device = nm_manager_get_device_by_path (manager, device_path);
-		if (!device) {
-			g_set_error (error,
-			             NM_MANAGER_ERROR, NM_MANAGER_ERROR_UNKNOWN_DEVICE,
-			             "%s", "Device not found");
+	/* Try to find the master connection/device if the connection has a dependency */
+	if (!find_master (manager, connection, device, &master_connection, &master_device)) {
+		g_set_error_literal (error, NM_MANAGER_ERROR, NM_MANAGER_ERROR_UNKNOWN_DEVICE,
+			                 "Master connection not found or invalid");
+		return NULL;
+	}
+
+	/* Ensure there's a master active connection the new connection we're
+	 * activating can depend on.
+	 */
+	if (master_connection || master_device) {
+		if (master_connection) {
+			nm_log_dbg (LOGD_CORE, "Activation of '%s' requires master connection '%s'",
+			            nm_connection_get_id (connection),
+			            nm_connection_get_id (master_connection));
+		}
+		if (master_device) {
+			nm_log_dbg (LOGD_CORE, "Activation of '%s' requires master device '%s'",
+			            nm_connection_get_id (connection),
+			            nm_device_get_ip_iface (master_device));
+		}
+
+		/* Ensure eg bond slave and the candidate master is a bond master */
+		if (master_connection && !is_compatible_with_slave (master_connection, connection)) {
+			g_set_error_literal (error, NM_MANAGER_ERROR, NM_MANAGER_ERROR_DEPENDENCY_FAILED,
+					             "The master connection was not compatible");
 			return NULL;
 		}
 
-		state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (device));
-		if (state < NM_DEVICE_STATE_DISCONNECTED) {
-			g_set_error (error,
-			             NM_MANAGER_ERROR, NM_MANAGER_ERROR_UNMANAGED_DEVICE,
-			             "%s", "Device not managed by NetworkManager");
+		master_ac = ensure_master_active_connection (manager,
+		                                             user_requested,
+		                                             connection,
+		                                             device,
+		                                             master_connection,
+		                                             master_device,
+		                                             error);
+		if (!master_ac) {
+			if (error)
+				g_assert (*error);
 			return NULL;
 		}
 
-		path = internal_activate_device (manager,
-		                                 device,
-		                                 connection,
-		                                 specific_object,
-		                                 user_requested,
-		                                 FALSE,
-		                                 error);
+		nm_log_dbg (LOGD_CORE, "Activation of '%s' depends on active connection %s",
+		            nm_connection_get_id (connection),
+		            nm_act_request_get_active_connection_path (master_ac));
 	}
 
-	return path;
+	return internal_activate_device (manager,
+	                                 device,
+	                                 connection,
+	                                 specific_object,
+	                                 user_requested,
+	                                 FALSE,
+	                                 master_ac,
+	                                 error);
 }
 
 static PendingActivation *
@@ -4053,6 +4630,12 @@ nm_manager_start (NMManager *self)
 
 	nm_udev_manager_query_devices (priv->udev_mgr);
 	bluez_manager_resync_devices (self);
+
+	/*
+	 * Connections added before the manager is started do not emit
+	 * connection-added signals thus devices have to be created manually.
+	 */
+	system_create_virtual_devices (self);
 }
 
 static gboolean
diff --git a/src/nm-manager.h b/src/nm-manager.h
index 35c9a57..0f6b714 100644
--- a/src/nm-manager.h
+++ b/src/nm-manager.h
@@ -91,6 +91,10 @@ void nm_manager_start (NMManager *manager);
 
 GSList *nm_manager_get_devices (NMManager *manager);
 
+NMDevice *nm_manager_get_device_by_master (NMManager *manager,
+					   const char *master,
+					   const char *driver);
+
 const char * nm_manager_activate_connection (NMManager *manager,
                                              NMConnection *connection,
                                              const char *specific_object,
diff --git a/src/nm-netlink-monitor.c b/src/nm-netlink-monitor.c
index 13b3ab9..15faf6a 100644
--- a/src/nm-netlink-monitor.c
+++ b/src/nm-netlink-monitor.c
@@ -32,6 +32,7 @@
 #include <string.h>
 #include <sys/types.h>
 #include <sys/socket.h>
+#include <sys/stat.h>
 #include <linux/types.h>
 #include <linux/netlink.h>
 #include <linux/rtnetlink.h>
@@ -47,6 +48,7 @@
 
 #include "nm-netlink-monitor.h"
 #include "nm-logging.h"
+#include "nm-system.h"
 
 #define EVENT_CONDITIONS      ((GIOCondition) (G_IO_IN | G_IO_PRI))
 #define ERROR_CONDITIONS      ((GIOCondition) (G_IO_ERR | G_IO_NVAL))
@@ -756,6 +758,71 @@ nm_netlink_index_to_rtnl_link (int idx)
 	return ret;
 }
 
+int
+nm_netlink_get_iface_type (int ifindex, const char *name)
+{
+	NMNetlinkMonitor *self;
+	NMNetlinkMonitorPrivate *priv;
+	struct rtnl_link *ret;
+	int res = NM_IFACE_TYPE_UNSPEC;
+	char *type;
+	char *path, *ifname;
+	guint flags;
+	struct stat st;
+
+	self = nm_netlink_monitor_get ();
+	priv = NM_NETLINK_MONITOR_GET_PRIVATE (self);
+
+	nl_cache_refill (priv->nlh_sync, priv->link_cache);
+
+	if (ifindex >= 0)
+		ret = rtnl_link_get (priv->link_cache, ifindex);
+	else
+		ret = rtnl_link_get_by_name (priv->link_cache, name);
+
+	if (!ret)
+		goto out;
+
+	type = rtnl_link_get_info_type (ret);
+	if (type) {
+		if (!g_strcmp0 (type, "bond"))
+			res = NM_IFACE_TYPE_BOND;
+		else if (!g_strcmp0 (type, "vlan"))
+			res = NM_IFACE_TYPE_VLAN;
+		else if (!g_strcmp0 (type, "dummy"))
+			res = NM_IFACE_TYPE_DUMMY;
+		goto out;
+	}
+
+	/* 'type' might only be valid on newer kernels, so fall back to checking
+	 * interface flags and various type-specific directories.
+	 */
+	ifname = nm_netlink_index_to_iface (ifindex);
+	if (ifname == NULL) {
+		nm_log_err (LOGD_HW, "Failed to look up interface name for index %d", ifindex);
+		goto out;
+	}
+
+	flags = rtnl_link_get_flags (ret);
+	if (flags & IFF_MASTER) {
+		/* Both the 'bonding' and the 'eql' driver set IFF_MASTER, and we
+		 * don't want 'eql' devices, so check sysfs for the bonding directory.
+		 */
+		path = g_strdup_printf ("/sys/class/net/%s/bonding", ifname);
+		g_assert (path);
+		if ((stat (path, &st) == 0) && S_ISDIR (st.st_mode))
+			res = NM_IFACE_TYPE_BOND;
+		g_free (path);
+	}
+	g_free (ifname);
+
+out:
+	if (ret)
+		rtnl_link_put (ret);
+	g_object_unref (self);
+	return res;
+}
+
 /***************************************************************/
 
 NMNetlinkMonitor *
diff --git a/src/nm-netlink-monitor.h b/src/nm-netlink-monitor.h
index 8b57a31..c520db2 100644
--- a/src/nm-netlink-monitor.h
+++ b/src/nm-netlink-monitor.h
@@ -95,5 +95,6 @@ int               nm_netlink_iface_to_index     (const char *iface);
 char *            nm_netlink_index_to_iface     (int idx);
 struct rtnl_link *nm_netlink_index_to_rtnl_link (int idx);
 struct nl_handle *nm_netlink_get_default_handle (void);
+int               nm_netlink_get_iface_type     (int ifindex, const char *name);
 
 #endif  /* NM_NETLINK_MONITOR_H */
diff --git a/src/nm-netlink-utils.c b/src/nm-netlink-utils.c
new file mode 100644
index 0000000..451e22d
--- /dev/null
+++ b/src/nm-netlink-utils.c
@@ -0,0 +1,123 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2011 Red Hat, Inc.
+ */
+
+#include "logging/nm-logging.h"
+#include "nm-netlink-utils.h"
+#include "nm-netlink-monitor.h"
+
+#include <arpa/inet.h>
+#include <netinet/in.h>
+#include <netlink/netlink.h>
+#include <netlink/addr.h>
+#include <netlink/route/addr.h>
+
+#include <errno.h>
+
+typedef struct {
+	int ifindex;
+	int family;
+	void *addr;
+	int addrlen;
+	int prefix;
+	gboolean found;
+} FindAddrInfo;
+
+static void
+find_one_address (struct nl_object *object, void *user_data)
+{
+	FindAddrInfo *info = user_data;
+	struct rtnl_addr *addr = (struct rtnl_addr *) object;
+	struct nl_addr *local;
+	void *binaddr;
+
+	if (info->found)
+		return;
+
+	if (rtnl_addr_get_ifindex (addr) != info->ifindex)
+		return;
+	if (rtnl_addr_get_family (addr) != info->family)
+		return;
+
+	if (rtnl_addr_get_prefixlen (addr) != info->prefix)
+		return;
+
+	local = rtnl_addr_get_local (addr);
+	if (nl_addr_get_family (local) != info->family)
+		return;
+	if (nl_addr_get_len (local) != info->addrlen)
+		return;
+	binaddr = nl_addr_get_binary_addr (local);
+	if (binaddr) {
+		if (memcmp (binaddr, info->addr, info->addrlen) == 0)
+			info->found = TRUE; /* Yay, found it */
+	}
+}
+
+/**
+ * nm_netlink_find_address:
+ * @ifindex: interface index
+ * @family: address family, either AF_INET or AF_INET6
+ * @addr: binary address, either struct in_addr* or struct in6_addr*
+ * @prefix: prefix length
+ *
+ * Searches for a matching address on the given interface.
+ *
+ * Returns: %TRUE if the given address was found on the interface, %FALSE if it
+ * was not found or an error occurred.
+ **/
+gboolean
+nm_netlink_find_address (int ifindex,
+                         int family,
+                         void *addr,  /* struct in_addr or struct in6_addr */
+                         int prefix)
+{
+	struct nl_handle *nlh = NULL;
+	struct nl_cache *cache = NULL;
+	FindAddrInfo info;
+
+	g_return_val_if_fail (ifindex > 0, FALSE);
+	g_return_val_if_fail (family == AF_INET || family == AF_INET6, FALSE);
+	g_return_val_if_fail (addr != NULL, FALSE);
+	g_return_val_if_fail (prefix >= 0, FALSE);
+
+	memset (&info, 0, sizeof (info));
+	info.ifindex = ifindex;
+	info.family = family;
+	info.prefix = prefix;
+	info.addr = addr;
+	if (family == AF_INET)
+		info.addrlen = sizeof (struct in_addr);
+	else if (family == AF_INET6)
+		info.addrlen = sizeof (struct in6_addr);
+	else
+		g_assert_not_reached ();
+
+	nlh = nm_netlink_get_default_handle ();
+	if (nlh) {
+		cache = rtnl_addr_alloc_cache(nlh);
+		if (cache) {
+			nl_cache_mngt_provide (cache);
+			nl_cache_foreach (cache, find_one_address, &info);
+			nl_cache_free (cache);
+		}
+	}
+	return info.found;
+}
+
diff --git a/src/nm-netlink-utils.h b/src/nm-netlink-utils.h
new file mode 100644
index 0000000..93a6457
--- /dev/null
+++ b/src/nm-netlink-utils.h
@@ -0,0 +1,32 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2011 Red Hat, Inc.
+ */
+
+#ifndef NM_NETLINK_UTILS_H
+#define NM_NETLINK_UTILS_H
+
+#include <glib.h>
+
+gboolean nm_netlink_find_address (int ifindex,
+                                  int family,
+                                  void *addr,  /* struct in_addr or struct in6_addr */
+                                  int prefix_);
+
+#endif  /* NM_NETLINK_UTILS_H */
+
diff --git a/src/nm-policy.c b/src/nm-policy.c
index a53b9f8..d8e24d7 100644
--- a/src/nm-policy.c
+++ b/src/nm-policy.c
@@ -837,6 +837,40 @@ get_device_connection (NMDevice *device)
 	return nm_act_request_get_connection (req);
 }
 
+static void schedule_activate_all (NMPolicy *policy);
+
+static void
+activate_slave_connections (NMPolicy *policy, NMConnection *connection,
+                            NMDevice *device)
+{
+#if 0
+	const char *master_device;
+	GSList *connections, *iter;
+
+	master_device = nm_device_get_iface (device);
+	g_assert (master_device);
+
+	connections = nm_settings_get_connections (policy->settings);
+	for (iter = connections; iter; iter = g_slist_next (iter)) {
+		NMConnection *slave;
+		NMSettingConnection *s_slave_con;
+
+		slave = NM_CONNECTION (iter->data);
+		g_assert (slave);
+
+		s_slave_con = nm_connection_get_setting_connection (slave);
+		g_assert (s_slave_con);
+
+		if (!g_strcmp0 (nm_setting_connection_get_master (s_slave_con), master_device))
+			set_connection_auto_retries (slave, RETRIES_DEFAULT);
+	}
+
+	g_slist_free (connections);
+#endif
+
+	schedule_activate_all (policy);
+}
+
 static void
 device_state_changed (NMDevice *device,
                       NMDeviceState new_state,
@@ -878,6 +912,11 @@ device_state_changed (NMDevice *device,
 		update_routing_and_dns (policy, FALSE);
 		schedule_activate_check (policy, device, 0);
 		break;
+	case NM_DEVICE_STATE_PREPARE:
+		/* Reset auto-connect retries of all slaves and schedule them for
+		 * activation. */
+		activate_slave_connections (policy, connection, device);
+		break;
 	default:
 		break;
 	}
diff --git a/src/nm-system.c b/src/nm-system.c
index 24c31c2..5574cef 100644
--- a/src/nm-system.c
+++ b/src/nm-system.c
@@ -40,7 +40,9 @@
 #include <netdb.h>
 #include <glib.h>
 #include <ctype.h>
-#include <net/if.h>
+#include <linux/if.h>
+#include <linux/sockios.h>
+#include <linux/if_bonding.h>
 
 #include "nm-system.h"
 #include "nm-device.h"
@@ -660,6 +662,31 @@ nm_system_apply_ip6_config (const char *iface,
 	return TRUE;
 }
 
+static guint32
+nm_system_iface_get_flags (int ifindex)
+{
+	struct rtnl_link *l;
+	guint32 flags;
+
+	g_return_val_if_fail (ifindex > 0, FALSE);
+
+	l = nm_netlink_index_to_rtnl_link (ifindex);
+	if (l == NULL) {
+		char *iface = nm_netlink_index_to_iface (ifindex);
+
+		g_warn_if_fail (iface != NULL);
+		nm_log_err (LOGD_HW, "(%s): failed to get interface link object",
+		            iface ? iface : "unknown");
+		g_free (iface);
+		return FALSE;
+	}
+
+	flags = rtnl_link_get_flags (l);
+	rtnl_link_put (l);
+
+	return flags;
+}
+
 /*
  * nm_system_device_set_up_down
  *
@@ -1464,3 +1491,290 @@ nm_system_device_set_priority (const char *iface,
 		rtnl_route_put (info.route);
 	}
 }
+
+static gboolean
+set_bond_attr (const char *iface, const char *attr, const char *value)
+{
+	char file[FILENAME_MAX];
+	gboolean ret;
+
+	snprintf (file, sizeof (file), "/sys/class/net/%s/bonding/%s", iface, attr);
+	ret = nm_utils_do_sysctl (file, value);
+	if (!ret) {
+		nm_log_warn (LOGD_HW, "(%s): failed to set bonding attribute "
+		             "'%s' to '%s'", iface, attr, value);
+	}
+
+	return ret;
+}
+
+gboolean
+nm_system_apply_bonding_config (const char *iface, NMSettingBond *s_bond)
+{
+	const char **opts, **iter;
+
+	g_return_val_if_fail (iface != NULL, FALSE);
+
+	/*
+	 * FIXME:
+	 *
+	 * ifup-eth contains code to append targets if the value is prefixed
+	 * with '+':
+	 *
+	 *  if [ "${key}" = "arp_ip_target" -a "${value:0:1}" != "+" ]; then
+	 *  OLDIFS=$IFS;
+	 *  IFS=',';
+	 *  for arp_ip in $value; do
+	 *      if ! grep -q $arp_ip /sys/class/net/${DEVICE}/bonding/$key; then
+	 *          echo +$arp_ip > /sys/class/net/${DEVICE}/bonding/$key
+	 *      fi
+	 *  done
+	 *
+	 * Not sure if this is actually being used and it seems dangerous as
+	 * the result is pretty much unforeseeable.
+	 */
+
+	/* Set bonding options; if the setting didn't specify a value for the
+	 * option then use the default value to ensure there's no leakage of
+	 * options from any previous connections to this one.
+	 */
+	opts = nm_setting_bond_get_valid_options (s_bond);
+	for (iter = opts; iter && *iter; iter++) {
+		const char *value;
+		gboolean is_default = FALSE;
+
+		value = nm_setting_bond_get_option_by_name (s_bond, *iter);
+		if (!value) {
+			value = nm_setting_bond_get_option_default (s_bond, *iter);  /* use the default value */
+			is_default = TRUE;
+		}
+
+		nm_log_dbg (LOGD_DEVICE, "(%s): setting bond option '%s' to %s'%s'",
+			        iface,
+			        *iter,
+			        is_default ? "default " : "",
+			        value);
+
+		set_bond_attr (iface, *iter, value);
+	}
+
+	return TRUE;
+}
+
+/**
+ * nm_system_add_bonding_master:
+ * @iface: the interface name for the new bond master
+ *
+ * Adds a virtual bonding device if it does not exist yet.
+ *
+ * Returns: %TRUE on success, %FALSE on failure
+ */
+gboolean
+nm_system_add_bonding_master (const char *iface)
+{
+	char cmd[IFNAMSIZ+2];
+	struct stat st;
+	int ignored;
+
+	g_return_val_if_fail (iface != NULL, FALSE);
+
+	/* Make sure bonding module is loaded */
+	if (stat ("/sys/class/net/bonding_masters", &st) || !S_ISREG (st.st_mode))
+		ignored = system ("/sbin/modprobe bonding");
+
+	snprintf (cmd, sizeof (cmd), "+%s", iface);
+	return nm_utils_do_sysctl ("/sys/class/net/bonding_masters", cmd);
+}
+
+static gboolean
+nm_system_iface_compat_enslave (const char *master_iface, const char *slave_iface)
+{
+	struct ifreq ifr;
+	int fd;
+	gboolean ret = FALSE;
+
+	memset (&ifr, 0, sizeof (ifr));
+
+	fd = socket (PF_INET, SOCK_DGRAM, 0);
+	if (fd < 0) {
+		nm_log_err (LOGD_DEVICE, "couldn't open control socket.");
+		return FALSE;
+	}
+
+	strncpy (ifr.ifr_name, master_iface, IFNAMSIZ);
+	strncpy (ifr.ifr_slave, slave_iface, IFNAMSIZ);
+
+	if (ioctl (fd, SIOCBONDENSLAVE, &ifr) < 0 &&
+	    ioctl (fd, BOND_ENSLAVE_OLD, &ifr) < 0) {
+		char *path, *val;
+		size_t written;
+		int slaves_fd;
+
+		nm_log_warn (LOGD_DEVICE, "(%s): error enslaving %s: %d (%s) (falling back to sysfs)",
+		            master_iface, slave_iface, errno, strerror (errno));
+
+		/* RHEL6 doesn't contain c20811a79e671a6a1fe86a8c1afe04aca8a7f085 which
+		 * causes these ioctls to return -EADDRNOTAVAIL when the first slave is
+		 * added because the bond's MAC is all zeros.  The ioctl doesn't update
+		 * the bond master's MAC address the same way that adding via sysfs does.
+		 */
+		path = g_strdup_printf ("/sys/class/net/%s/bonding/slaves", master_iface);
+		g_assert (path);
+		val = g_strdup_printf ("+%s", slave_iface);
+		g_assert (val);
+
+		errno = 0;
+		slaves_fd = open (path, O_WRONLY);
+		if (slaves_fd >= 0) {
+			written = write (slaves_fd, val, strlen (val));
+			if (written == strlen (val))
+				ret = TRUE;
+			else {
+				nm_log_err (LOGD_DEVICE, "(%s): error enslaving %s (failed to write slave name): %d (%s)",
+					        master_iface, slave_iface, errno, strerror (errno));
+			}
+			close (slaves_fd);
+		} else {
+			nm_log_err (LOGD_DEVICE, "(%s): error enslaving %s (failed to open slaves file): %d (%s)",
+			            master_iface, slave_iface, errno, strerror (errno));
+		}
+		g_free (path);
+		g_free (val);
+
+		nm_log_err (LOGD_DEVICE, "(%s): error enslaving %s: %d (%s)",
+		            master_iface, slave_iface, errno, strerror (errno));
+	} else
+		ret = TRUE;
+
+	close (fd);
+
+	return ret;
+}
+
+/**
+ * nm_system_iface_enslave:
+ * @master_ifindex: master device interface index
+ * @master_iface: master device interface name
+ * @slave_ifindex: slave device interface index
+ * @slave_iface: slave device interface name
+ *
+ * Enslaves the 'slave' to 'master. This function targets implementing a
+ * generic interface to attaching all kinds of slaves to masters. Currently
+ * only bonding is properly supported due to the backwards compatibility
+ * function being bonding specific.
+ *
+ * The slave device needs to be down as a prerequisite.
+ *
+ * Returns: %TRUE on success, or %FALSE
+ */
+gboolean
+nm_system_iface_enslave (gint master_ifindex,
+                         const char *master_iface,
+                         gint slave_ifindex,
+                         const char *slave_iface)
+{
+	struct nl_handle *sock;
+
+	g_return_val_if_fail (master_ifindex >= 0, FALSE);
+	g_return_val_if_fail (master_iface != NULL, FALSE);
+	g_return_val_if_fail (slave_ifindex >= 0, FALSE);
+	g_return_val_if_fail (slave_iface != NULL, FALSE);
+
+	sock = nm_netlink_get_default_handle ();
+
+	if (!(nm_system_iface_get_flags (master_ifindex) & IFF_MASTER)) {
+		nm_log_err (LOGD_DEVICE, "(%s): interface is not a master", master_iface);
+		return FALSE;
+	}
+
+	g_assert (!nm_system_device_is_up_with_iface (slave_iface));
+
+	if (nm_system_iface_get_flags (slave_ifindex) & IFF_SLAVE) {
+		nm_log_err (LOGD_DEVICE, "(%s): %s is already a slave",
+		            master_iface, slave_iface);
+		return FALSE;
+	}
+
+	return nm_system_iface_compat_enslave (master_iface, slave_iface);
+}
+
+static gboolean
+nm_system_iface_compat_release (const char *master_iface, const char *slave_iface)
+{
+	struct ifreq ifr;
+	int fd;
+	gboolean ret = FALSE;
+
+	memset (&ifr, 0, sizeof (ifr));
+
+	fd = socket (PF_INET, SOCK_DGRAM, 0);
+	if (fd < 0) {
+		nm_log_err (LOGD_DEVICE, "couldn't open control socket.");
+		return FALSE;
+	}
+
+	strncpy (ifr.ifr_name, master_iface, IFNAMSIZ);
+	strncpy (ifr.ifr_slave, slave_iface, IFNAMSIZ);
+
+	if (ioctl (fd, SIOCBONDRELEASE, &ifr) < 0 &&
+	    ioctl (fd, BOND_RELEASE_OLD, &ifr) < 0) {
+		nm_log_err (LOGD_DEVICE, "(%s): error releasing slave %s: %d (%s)",
+		            master_iface, slave_iface, errno, strerror (errno));
+	} else
+		ret = TRUE;
+
+	close (fd);
+	return ret;
+}
+
+/**
+ * nm_system_iface_release:
+ * @master_ifindex: master device interface index
+ * @master_iface: master device interface name
+ * @slave_ifindex: slave device interface index
+ * @slave_iface: slave device interface name
+ *
+ * Releases the 'slave' which is attached to 'master. This function targets
+ * implementing a generic interface to releasing all kinds of slaves. Currently
+ * only bonding is properly supported due to the backwards compatibility
+ * function being bonding specific.
+ *
+ * Returns: %TRUE on success, or %FALSE
+ */
+gboolean
+nm_system_iface_release (gint master_ifindex,
+                         const char *master_iface,
+                         gint slave_ifindex,
+                         const char *slave_iface)
+{
+	struct nl_handle *sock;
+
+	g_return_val_if_fail (master_ifindex >= 0, FALSE);
+	g_return_val_if_fail (master_iface != NULL, FALSE);
+	g_return_val_if_fail (slave_ifindex >= 0, FALSE);
+	g_return_val_if_fail (slave_iface != NULL, FALSE);
+
+	sock = nm_netlink_get_default_handle ();
+
+	/* Only release if this is actually a slave */
+	if (!(nm_system_iface_get_flags (slave_ifindex) & IFF_SLAVE))
+		return TRUE;
+
+	return nm_system_iface_compat_release (master_iface, slave_iface);
+}
+
+/**
+ * nm_system_get_iface_type:
+ * @ifindex: interface index
+ * @name: name of interface
+ *
+ * Lookup the type of an interface.  At least one of @ifindex or @name must
+ * be provided.
+ *
+ * Returns: Interface type (NM_IFACE_TYPE_*) or NM_IFACE_TYPE_UNSPEC.
+ **/
+int
+nm_system_get_iface_type (int ifindex, const char *name)
+{
+	return nm_netlink_get_iface_type (ifindex, name);
+}
diff --git a/src/nm-system.h b/src/nm-system.h
index 8cb22d7..76606c4 100644
--- a/src/nm-system.h
+++ b/src/nm-system.h
@@ -94,4 +94,26 @@ gboolean        nm_system_device_is_up_with_iface (const char *iface);
 gboolean		nm_system_device_set_mtu (const char *iface, guint32 mtu);
 gboolean		nm_system_device_set_mac (const char *iface, const struct ether_addr *mac);
 
+gboolean        nm_system_apply_bonding_config          (const char *iface,
+                                                         NMSettingBond *s_bond);
+gboolean        nm_system_add_bonding_master            (const char *iface);
+
+gboolean        nm_system_iface_enslave                 (gint master_ifindex,
+                                                         const char *master_iface,
+                                                         gint slave_ifindex,
+                                                         const char *slave_iface);
+gboolean        nm_system_iface_release                 (gint master_ifindex,
+                                                         const char *master_iface,
+                                                         gint slave_ifindex,
+                                                         const char *slave_iface);
+
+enum {
+		NM_IFACE_TYPE_UNSPEC = 0,
+		NM_IFACE_TYPE_BOND,
+		NM_IFACE_TYPE_VLAN,
+		NM_IFACE_TYPE_DUMMY,
+};
+
+int             nm_system_get_iface_type      (int ifindex, const char *name);
+
 #endif
diff --git a/src/nm-udev-manager.c b/src/nm-udev-manager.c
index 661fed1..84d2e3a 100644
--- a/src/nm-udev-manager.c
+++ b/src/nm-udev-manager.c
@@ -40,6 +40,8 @@
 #include "nm-device-olpc-mesh.h"
 #include "nm-device-infiniband.h"
 #include "nm-device-ethernet.h"
+#include "nm-device-bond.h"
+#include "nm-system.h"
 
 typedef struct {
 	GUdevClient *client;
@@ -344,6 +346,11 @@ is_infiniband (GUdevDevice *device)
 	return etype == ARPHRD_INFINIBAND;
 }
 
+static gboolean
+is_bond (int ifindex)
+{
+	return (nm_system_get_iface_type (ifindex, NULL) == NM_IFACE_TYPE_BOND);
+}
 static GObject *
 device_creator (NMUdevManager *manager,
                 GUdevDevice *udev_device,
@@ -381,11 +388,6 @@ device_creator (NMUdevManager *manager,
 		}
 	}
 
-	if (!driver) {
-		nm_log_warn (LOGD_HW, "%s: couldn't determine device driver; ignoring...", path);
-		goto out;
-	}
-
 	ifindex = g_udev_device_get_sysfs_attr_as_int (udev_device, "ifindex");
 	if (ifindex <= 0) {
 		nm_log_warn (LOGD_HW, "%s: device had invalid ifindex %d; ignoring...", path, (guint32) ifindex);
@@ -398,6 +400,8 @@ device_creator (NMUdevManager *manager,
 		device = (GObject *) nm_device_wifi_new (path, ifname, driver);
 	else if (is_infiniband (udev_device))
 		device = (GObject *) nm_device_infiniband_new (path, ifname, driver);
+	else if (is_bond (ifindex))
+		device = (GObject *) nm_device_bond_new (path, ifname);
 	else
 		device = (GObject *) nm_device_ethernet_new (path, ifname, driver);
 
diff --git a/src/system-settings/nm-sysconfig-settings.c b/src/system-settings/nm-sysconfig-settings.c
index fbd7305..36dd582 100644
--- a/src/system-settings/nm-sysconfig-settings.c
+++ b/src/system-settings/nm-sysconfig-settings.c
@@ -1059,7 +1059,7 @@ get_permissions (NMSettingsSystemInterface *settings,
 }
 
 static gboolean
-have_connection_for_device (NMSysconfigSettings *self, GByteArray *mac)
+have_connection_for_device (NMSysconfigSettings *self, GByteArray *mac, const char *iface)
 {
 	NMSysconfigSettingsPrivate *priv = NM_SYSCONFIG_SETTINGS_GET_PRIVATE (self);
 	GHashTableIter iter;
@@ -1077,7 +1077,14 @@ have_connection_for_device (NMSysconfigSettings *self, GByteArray *mac)
 	g_hash_table_iter_init (&iter, priv->connections);
 	while (g_hash_table_iter_next (&iter, &key, NULL)) {
 		NMConnection *connection = NM_CONNECTION (key);
-		const char *connection_type;
+		const char *connection_type, *vname;
+
+		/* Catch virtual interfaces specified by interface name */
+		vname = nm_connection_get_virtual_iface_name (connection);
+		if (vname && g_strcmp0 (vname, iface) == 0) {
+			ret = TRUE;
+			break;
+		}
 
 		s_con = NM_SETTING_CONNECTION (nm_connection_get_setting (connection, NM_TYPE_SETTING_CONNECTION));
 		connection_type = nm_setting_connection_get_connection_type (s_con);
@@ -1336,7 +1343,7 @@ nm_sysconfig_settings_device_added (NMSysconfigSettings *self, NMDevice *device)
 	mac = g_byte_array_new ();
 	g_byte_array_append (mac, hwaddr, nm_utils_hwaddr_len (hwaddr_type));
  
-	if (   have_connection_for_device (self, mac)
+	if (   have_connection_for_device (self, mac, nm_device_get_ip_iface (device))
 		|| is_mac_auto_wired_blacklisted (self, mac, hwaddr_type))
 		goto ignore;
 
diff --git a/src/vpn-manager/nm-vpn-connection-base.c b/src/vpn-manager/nm-vpn-connection-base.c
index e05c0c0..a2390e9 100644
--- a/src/vpn-manager/nm-vpn-connection-base.c
+++ b/src/vpn-manager/nm-vpn-connection-base.c
@@ -52,6 +52,7 @@ enum {
 	PROP_DEFAULT,
 	PROP_DEFAULT6,
 	PROP_VPN,
+	PROP_MASTER,
 
 	LAST_PROP
 };
@@ -177,6 +178,9 @@ get_property (GObject *object, guint prop_id,
 	case PROP_VPN:
 		g_value_set_boolean (value, TRUE);
 		break;
+	case PROP_MASTER:
+		g_value_set_boxed (value, "/");
+		break;
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -203,7 +207,8 @@ nm_vpn_connection_base_class_init (NMVpnConnectionBaseClass *vpn_class)
                                              PROP_STATE,
                                              PROP_DEFAULT,
                                              PROP_DEFAULT6,
-                                             PROP_VPN);
+                                             PROP_VPN,
+                                             PROP_MASTER);
 
 	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (vpn_class),
 									 &dbus_glib_nm_vpn_connection_base_object_info);
diff --git a/system-settings/plugins/ifcfg-rh/common.h b/system-settings/plugins/ifcfg-rh/common.h
index 4bd4e31..d4de95b 100644
--- a/system-settings/plugins/ifcfg-rh/common.h
+++ b/system-settings/plugins/ifcfg-rh/common.h
@@ -45,6 +45,7 @@
 #define TYPE_WIRELESS   "Wireless"
 #define TYPE_INFINIBAND "InfiniBand"
 #define TYPE_BRIDGE     "Bridge"
+#define TYPE_BOND       "Bond"
 
 #define IFCFG_PLUGIN_ERROR (ifcfg_plugin_error_quark ())
 GQuark ifcfg_plugin_error_quark (void);
diff --git a/system-settings/plugins/ifcfg-rh/reader.c b/system-settings/plugins/ifcfg-rh/reader.c
index fcace48..f8574fa 100644
--- a/system-settings/plugins/ifcfg-rh/reader.c
+++ b/system-settings/plugins/ifcfg-rh/reader.c
@@ -43,6 +43,7 @@
 #include <glib/gi18n.h>
 #include <nm-connection.h>
 #include <NetworkManager.h>
+#include <nm-setting-bond.h>
 #include <nm-setting-connection.h>
 #include <nm-setting-ip4-config.h>
 #include <nm-setting-ip6-config.h>
@@ -112,16 +113,46 @@ get_int (const char *str, int *value)
 	return TRUE;
 }
 
+static char *
+make_connection_name (shvarFile *ifcfg,
+                      const char *ifcfg_name,
+                      const char *suggested,
+                      const char *prefix)
+{
+	char *full_name = NULL, *name;
+
+	/* If the ifcfg file already has a NAME, always use that */
+	name = svGetValue (ifcfg, "NAME", FALSE);
+	if (name && strlen (name))
+		return name;
+
+	/* Otherwise construct a new NAME */
+	g_free (name);
+	if (!prefix)
+		prefix = _("System");
+
+	/* For cosmetic reasons, if the suggested name is the same as
+	 * the ifcfg files name, don't use it.  Mainly for wifi so that
+	 * the SSID is shown in the connection ID instead of just "wlan0".
+	 */
+	if (suggested && strcmp (ifcfg_name, suggested))
+		full_name = g_strdup_printf ("%s %s (%s)", prefix, suggested, ifcfg_name);
+	else
+		full_name = g_strdup_printf ("%s %s", prefix, ifcfg_name);
+
+	return full_name;
+}
+
 static NMSetting *
 make_connection_setting (const char *file,
                          shvarFile *ifcfg,
                          const char *type,
-                         const char *suggested)
+                         const char *suggested,
+			 const char *prefix)
 {
 	NMSettingConnection *s_con;
 	const char *ifcfg_name = NULL;
-	char *new_id = NULL, *uuid = NULL, *value;
-	char *ifcfg_id;
+	char *new_id, *uuid = NULL, *value;
 
 	ifcfg_name = utils_get_ifcfg_name (file, TRUE);
 	if (!ifcfg_name)
@@ -129,32 +160,9 @@ make_connection_setting (const char *file,
 
 	s_con = NM_SETTING_CONNECTION (nm_setting_connection_new ());
 
-	/* Try the ifcfg file's internally defined name if available */
-	ifcfg_id = svGetValue (ifcfg, "NAME", FALSE);
-	if (ifcfg_id && strlen (ifcfg_id))
-		g_object_set (s_con, NM_SETTING_CONNECTION_ID, ifcfg_id, NULL);
-
-	if (!nm_setting_connection_get_id (s_con)) {
-		if (suggested) {
-			/* For cosmetic reasons, if the suggested name is the same as
-			 * the ifcfg files name, don't use it.  Mainly for wifi so that
-			 * the SSID is shown in the connection ID instead of just "wlan0".
-			 */
-			if (strcmp (ifcfg_name, suggested)) {
-				new_id = g_strdup_printf ("%s %s (%s)", reader_get_prefix (), suggested, ifcfg_name);
-				g_object_set (s_con, NM_SETTING_CONNECTION_ID, new_id, NULL);
-			}
-		}
-
-		/* Use the ifcfg file's name as a last resort */
-		if (!nm_setting_connection_get_id (s_con)) {
-			new_id = g_strdup_printf ("%s %s", reader_get_prefix (), ifcfg_name);
-			g_object_set (s_con, NM_SETTING_CONNECTION_ID, new_id, NULL);
-		}
-	}
-
+	new_id = make_connection_name (ifcfg, ifcfg_name, suggested, prefix);
+	g_object_set (s_con, NM_SETTING_CONNECTION_ID, new_id, NULL);
 	g_free (new_id);
-	g_free (ifcfg_id);
 
 	/* Try for a UUID key before falling back to hashing the file name */
 	uuid = svGetValue (ifcfg, "UUID", FALSE);
@@ -1152,7 +1160,7 @@ static NMSetting *
 make_ip4_setting (shvarFile *ifcfg,
                   const char *network_file,
                   const char *iscsiadm_path,
-                  gboolean valid_ip6_config,
+                  gboolean can_disable_ip4,
                   GError **error)
 {
 	NMSettingIP4Config *s_ip4 = NULL;
@@ -1251,7 +1259,7 @@ make_ip4_setting (shvarFile *ifcfg,
 		tmp_prefix = svGetValue (ifcfg, "PREFIX", FALSE);
 		tmp_netmask = svGetValue (ifcfg, "NETMASK", FALSE);
 		if (!tmp_ip4 && !tmp_prefix && !tmp_netmask) {
-			if (valid_ip6_config) {
+			if (can_disable_ip4) {
 				/* Nope, no IPv4 */
 				g_object_set (s_ip4,
 				              NM_SETTING_IP4_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_DISABLED,
@@ -3052,7 +3060,7 @@ wireless_connection_from_ifcfg (const char *file,
 	/* Connection */
 	con_setting = make_connection_setting (file, ifcfg,
 	                                       NM_SETTING_WIRELESS_SETTING_NAME,
-	                                       printable_ssid);
+	                                       printable_ssid, NULL);
 	g_free (printable_ssid);
 	if (!con_setting) {
 		g_set_error (error, IFCFG_PLUGIN_ERROR, 0,
@@ -3252,6 +3260,7 @@ wired_connection_from_ifcfg (const char *file,
 	NMSetting *con_setting = NULL;
 	NMSetting *wired_setting = NULL;
 	NMSetting8021x *s_8021x = NULL;
+	char *value;
 
 	g_return_val_if_fail (file != NULL, NULL);
 	g_return_val_if_fail (ifcfg != NULL, NULL);
@@ -3263,7 +3272,7 @@ wired_connection_from_ifcfg (const char *file,
 		return NULL;
 	}
 
-	con_setting = make_connection_setting (file, ifcfg, NM_SETTING_WIRED_SETTING_NAME, NULL);
+	con_setting = make_connection_setting (file, ifcfg, NM_SETTING_WIRED_SETTING_NAME, NULL, NULL);
 	if (!con_setting) {
 		g_set_error (error, IFCFG_PLUGIN_ERROR, 0,
 		             "Failed to create connection setting.");
@@ -3272,6 +3281,15 @@ wired_connection_from_ifcfg (const char *file,
 	}
 	nm_connection_add_setting (connection, con_setting);
 
+	/* Might be a bond slave; handle master device or connection */
+	value = svGetValue (ifcfg, "MASTER", FALSE);
+	if (value) {
+		g_object_set (con_setting, NM_SETTING_CONNECTION_MASTER, value, NULL);
+		g_object_set (con_setting, NM_SETTING_CONNECTION_SLAVE_TYPE,
+		              NM_SETTING_BOND_SETTING_NAME, NULL);
+		g_free (value);
+	}
+
 	wired_setting = make_wired_setting (ifcfg, file, nm_controlled, unmanaged, &s_8021x, error);
 	if (!wired_setting) {
 		g_object_unref (connection);
@@ -3368,7 +3386,7 @@ infiniband_connection_from_ifcfg (const char *file,
 		return NULL;
 	}
 
-	con_setting = make_connection_setting (file, ifcfg, NM_SETTING_INFINIBAND_SETTING_NAME, NULL);
+	con_setting = make_connection_setting (file, ifcfg, NM_SETTING_INFINIBAND_SETTING_NAME, NULL, NULL);
 	if (!con_setting) {
 		g_set_error (error, IFCFG_PLUGIN_ERROR, 0,
 		             "Failed to create connection setting.");
@@ -3439,6 +3457,154 @@ enum {
 	IGNORE_REASON_VLAN = 0x02,
 };
 
+static void
+handle_bond_option (NMSettingBond *s_bond,
+                    const char *key,
+                    const char *value)
+{
+	if (!nm_setting_bond_add_option (s_bond, key, value))
+		PLUGIN_WARN (IFCFG_PLUGIN_NAME, "    warning: invalid bonding option '%s'", key);
+}
+
+static NMSetting *
+make_bond_setting (shvarFile *ifcfg,
+                   const char *file,
+                   gboolean nm_controlled,
+                   char **unmanaged,
+                   GError **error)
+{
+	NMSettingBond *s_bond;
+	char *value;
+
+	s_bond = NM_SETTING_BOND (nm_setting_bond_new ());
+
+	value = svGetValue (ifcfg, "DEVICE", FALSE);
+	if (!value || !strlen (value)) {
+		g_set_error (error, ifcfg_plugin_error_quark (), 0,
+		             "mandatory DEVICE keyword missing");
+		goto error;
+	}
+
+	g_object_set (s_bond, NM_SETTING_BOND_INTERFACE_NAME, value, NULL);
+	g_free (value);
+
+	value = svGetValue (ifcfg, "BONDING_OPTS", FALSE);
+	if (value) {
+		char **items, **iter;
+
+		items = g_strsplit_set (value, " ", -1);
+		for (iter = items; iter && *iter; iter++) {
+			if (strlen (*iter)) {
+				char **keys, *key, *val;
+
+				keys = g_strsplit_set (*iter, "=", 2);
+				if (keys && *keys) {
+					key = *keys;
+					val = *(keys + 1);
+					if (val && strlen(key) && strlen(val))
+						handle_bond_option (s_bond, key, val);
+				}
+
+				g_strfreev (keys);
+			}
+		}
+		g_free (value);
+		g_strfreev (items);
+	}
+
+	return (NMSetting *) s_bond;
+
+error:
+	g_object_unref (s_bond);
+	return NULL;
+}
+
+static NMConnection *
+bond_connection_from_ifcfg (const char *file,
+                            shvarFile *ifcfg,
+                            gboolean nm_controlled,
+                            char **unmanaged,
+                            GError **error)
+{
+	NMConnection *connection = NULL;
+	NMSetting *con_setting = NULL;
+	NMSetting *bond_setting = NULL;
+	NMSetting *wired_setting = NULL;
+	NMSetting8021x *s_8021x = NULL;
+
+	g_return_val_if_fail (file != NULL, NULL);
+	g_return_val_if_fail (ifcfg != NULL, NULL);
+
+	connection = nm_connection_new ();
+	if (!connection) {
+		g_set_error (error, ifcfg_plugin_error_quark (), 0,
+		             "Failed to allocate new connection for %s.", file);
+		return NULL;
+	}
+
+	con_setting = make_connection_setting (file, ifcfg, NM_SETTING_BOND_SETTING_NAME, NULL, _("Bond"));
+	if (!con_setting) {
+		g_set_error (error, ifcfg_plugin_error_quark (), 0,
+		             "Failed to create connection setting.");
+		g_object_unref (connection);
+		return NULL;
+	}
+	nm_connection_add_setting (connection, con_setting);
+
+	bond_setting = make_bond_setting (ifcfg, file, nm_controlled, unmanaged, error);
+	if (!bond_setting) {
+		g_object_unref (connection);
+		return NULL;
+	}
+	nm_connection_add_setting (connection, bond_setting);
+
+	wired_setting = make_wired_setting (ifcfg, file, nm_controlled, unmanaged, &s_8021x, error);
+	if (!wired_setting) {
+		g_object_unref (connection);
+		return NULL;
+	}
+	nm_connection_add_setting (connection, wired_setting);
+
+	if (s_8021x)
+		nm_connection_add_setting (connection, NM_SETTING (s_8021x));
+
+	if (!nm_connection_verify (connection, error)) {
+		g_object_unref (connection);
+		return NULL;
+	}
+
+	return connection;
+}
+
+static gboolean
+disabling_ip4_config_allowed (NMConnection *connection)
+{
+	NMSettingConnection *s_con;
+
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+
+	/* bonding slaves are allowed to have no ip configuration */
+	if (nm_setting_connection_is_slave_type (s_con, NM_SETTING_BOND_SETTING_NAME))
+		return TRUE;
+
+	return FALSE;
+}
+
+static gboolean
+is_bond_device (const char *name, shvarFile *parsed)
+{
+	g_return_val_if_fail (name != NULL, FALSE);
+	g_return_val_if_fail (parsed != NULL, FALSE);
+
+	if (svTrueValue (parsed, "BONDING_MASTER", FALSE))
+		return TRUE;
+	
+	/* XXX: Check for "bond[\d]+"? */
+
+	return FALSE;
+}
+
 NMConnection *
 connection_from_file (const char *filename,
                       const char *network_file,  /* for unit tests only */
@@ -3457,7 +3623,7 @@ connection_from_file (const char *filename,
 	NMSetting *s_ip4, *s_ip6;
 	const char *ifcfg_name = NULL;
 	gboolean nm_controlled = TRUE;
-	gboolean ip6_used = FALSE;
+	gboolean can_disable_ip4 = FALSE;
 	GError *error = NULL;
 	guint32 ignore_reason = IGNORE_REASON_NONE;
 
@@ -3516,8 +3682,10 @@ connection_from_file (const char *filename,
 		}
 
 		if (!test_type) {
+			if (is_bond_device (device, parsed))
+				type = g_strdup (TYPE_BOND);
 			/* Test wireless extensions */
-			if (is_wireless_device (device))
+			else if (is_wireless_device (device))
 				type = g_strdup (TYPE_WIRELESS);
 			else
 				type = g_strdup (TYPE_ETHERNET);
@@ -3574,6 +3742,8 @@ connection_from_file (const char *filename,
 		connection = wireless_connection_from_ifcfg (filename, parsed, nm_controlled, unmanaged, &error);
 	else if (!strcasecmp (type, TYPE_INFINIBAND))
 		connection = infiniband_connection_from_ifcfg (filename, parsed, nm_controlled, unmanaged, &error);
+	else if (!strcasecmp (type, TYPE_BOND))
+		connection = bond_connection_from_ifcfg (filename, parsed, nm_controlled, unmanaged, &error);
 	else if (!strcasecmp (type, TYPE_BRIDGE)) {
 		g_set_error (&error, IFCFG_PLUGIN_ERROR, 0,
 		             "Bridge connections are not yet supported");
@@ -3620,10 +3790,13 @@ connection_from_file (const char *filename,
 		nm_connection_add_setting (connection, s_ip6);
 		method = nm_setting_ip6_config_get_method (NM_SETTING_IP6_CONFIG (s_ip6));
 		if (method && strcmp (method, NM_SETTING_IP6_CONFIG_METHOD_IGNORE))
-			ip6_used = TRUE;
+			can_disable_ip4 = TRUE;
 	}
 
-	s_ip4 = make_ip4_setting (parsed, network_file, iscsiadm_path, ip6_used, &error);
+	if (disabling_ip4_config_allowed (connection))
+		can_disable_ip4 = TRUE;
+
+	s_ip4 = make_ip4_setting (parsed, network_file, iscsiadm_path, can_disable_ip4, &error);
 	if (error) {
 		g_object_unref (connection);
 		connection = NULL;
diff --git a/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-bond-main b/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-bond-main
new file mode 100644
index 0000000..4c4834d
--- /dev/null
+++ b/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-bond-main
@@ -0,0 +1,5 @@
+DEVICE=bond0
+ONBOOT=no
+TYPE=Bond
+BOOTPROTO=dhcp
+BONDING_OPTS="miimon=100"
diff --git a/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-bond-slave b/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-bond-slave
new file mode 100644
index 0000000..cfef2b1
--- /dev/null
+++ b/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-bond-slave
@@ -0,0 +1,4 @@
+DEVICE=eth0
+HWADDR=00:22:15:59:62:97
+ONBOOT=no
+MASTER=bond0
diff --git a/system-settings/plugins/ifcfg-rh/tests/test-ifcfg-rh.c b/system-settings/plugins/ifcfg-rh/tests/test-ifcfg-rh.c
index a9cf555..0907b70 100644
--- a/system-settings/plugins/ifcfg-rh/tests/test-ifcfg-rh.c
+++ b/system-settings/plugins/ifcfg-rh/tests/test-ifcfg-rh.c
@@ -35,6 +35,7 @@
 
 #include <nm-utils.h>
 #include <nm-setting-connection.h>
+#include <nm-setting-bond.h>
 #include <nm-setting-wired.h>
 #include <nm-setting-wireless.h>
 #include <nm-setting-wireless-security.h>
@@ -9896,6 +9897,381 @@ test_write_infiniband (void)
 	g_object_unref (reread);
 }
 
+#define TEST_IFCFG_BOND_MAIN TEST_IFCFG_DIR"/network-scripts/ifcfg-test-bond-main"
+
+static void
+test_read_bond_main (void)
+{
+	NMConnection *connection;
+	NMSettingBond *s_bond;
+	char *unmanaged = NULL;
+	char *keyfile = NULL;
+	char *routefile = NULL;
+	char *route6file = NULL;
+	gboolean ignore_error = FALSE;
+	GError *error = NULL;
+
+	connection = connection_from_file (TEST_IFCFG_BOND_MAIN,
+	                                   NULL,
+	                                   TYPE_ETHERNET,
+	                                   NULL,
+	                                   &unmanaged,
+	                                   &keyfile,
+	                                   &routefile,
+	                                   &route6file,
+	                                   &error,
+	                                   &ignore_error);
+	ASSERT (connection != NULL,
+	        "bond-main-read", "unexpected failure reading %s", TEST_IFCFG_BOND_MAIN);
+
+	ASSERT (nm_connection_verify (connection, &error),
+	        "bond-main-read", "failed to verify %s: %s", TEST_IFCFG_BOND_MAIN, error->message);
+
+	/* ===== Bonding SETTING ===== */
+
+	s_bond = nm_connection_get_setting_bond (connection);
+	ASSERT (s_bond != NULL,
+	        "bond-main", "failed to verify %s: missing %s setting",
+	        TEST_IFCFG_BOND_MAIN,
+	        NM_SETTING_BOND_SETTING_NAME);
+
+	ASSERT (g_strcmp0 (nm_setting_bond_get_interface_name (s_bond), "bond0") == 0,
+	        "bond-main", "failed to verify %s: DEVICE=%s does not match bond0",
+	        TEST_IFCFG_BOND_MAIN, nm_setting_bond_get_interface_name (s_bond));
+
+	ASSERT (g_strcmp0 (nm_setting_bond_get_option_by_name (s_bond, NM_SETTING_BOND_OPTION_MIIMON), "100") == 0,
+	        "bond-main", "failed to verify %s: miimon=%s does not match 100",
+	        TEST_IFCFG_BOND_MAIN, nm_setting_bond_get_option_by_name (s_bond, NM_SETTING_BOND_OPTION_MIIMON));
+
+	g_free (unmanaged);
+	g_free (keyfile);
+	g_free (routefile);
+	g_free (route6file);
+	g_object_unref (connection);
+}
+
+static void
+test_write_bond_main (void)
+{
+	NMConnection *connection;
+	NMConnection *reread;
+	NMSettingConnection *s_con;
+	NMSettingBond *s_bond;
+	NMSettingIP4Config *s_ip4;
+	NMSettingIP6Config *s_ip6;
+	NMSettingWired *s_wired;
+	char *uuid;
+	const guint32 ip1 = htonl (0x01010103);
+	const guint32 gw = htonl (0x01010101);
+	const guint32 prefix = 24;
+	NMIP4Address *addr;
+	gboolean success;
+	GError *error = NULL;
+	char *testfile = NULL;
+	char *unmanaged = NULL;
+	char *keyfile = NULL;
+	char *routefile = NULL;
+	char *route6file = NULL;
+	gboolean ignore_error = FALSE;
+
+	connection = nm_connection_new ();
+	ASSERT (connection != NULL,
+	        "bond-main-write", "failed to allocate new connection");
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	ASSERT (s_con != NULL,
+	        "bond-main-write", "failed to allocate new %s setting",
+	        NM_SETTING_CONNECTION_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	uuid = nm_utils_uuid_generate ();
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Bond Main",
+	              NM_SETTING_CONNECTION_UUID, uuid,
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_BOND_SETTING_NAME,
+	              NULL);
+	g_free (uuid);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	ASSERT (s_wired != NULL,
+	        "bond-main-write", "failed to allocate new %s setting",
+	        NM_SETTING_WIRED_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	/* bond setting */
+	s_bond = (NMSettingBond *) nm_setting_bond_new ();
+	ASSERT (s_bond != NULL,
+	        "bond-main-write", "failed to allocate new %s setting",
+	        NM_SETTING_BOND_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_bond));
+
+	g_object_set (s_bond,
+	              NM_SETTING_BOND_INTERFACE_NAME, "bond0",
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIP4Config *) nm_setting_ip4_config_new ();
+	ASSERT (s_ip4 != NULL,
+			"bond-main-write", "failed to allocate new %s setting",
+			NM_SETTING_IP4_CONFIG_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP4_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP4_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	addr = nm_ip4_address_new ();
+	nm_ip4_address_set_address (addr, ip1);
+	nm_ip4_address_set_prefix (addr, prefix);
+	nm_ip4_address_set_gateway (addr, gw);
+	nm_setting_ip4_config_add_address (s_ip4, addr);
+	nm_ip4_address_unref (addr);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIP6Config *) nm_setting_ip6_config_new ();
+	ASSERT (s_ip6 != NULL,
+	        "bond-main-write", "failed to allocate new %s setting",
+	        NM_SETTING_IP6_CONFIG_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP6_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NULL);
+
+	ASSERT (nm_connection_verify (connection, &error) == TRUE,
+	        "bond-main-write", "failed to verify connection: %s",
+	        (error && error->message) ? error->message : "(unknown)");
+
+	/* Save the ifcfg */
+	success = writer_new_connection (connection,
+	                                 TEST_SCRATCH_DIR "/network-scripts/",
+	                                 &testfile,
+	                                 &error);
+	ASSERT (success == TRUE,
+	        "bond-main-write", "failed to write connection to disk: %s",
+	        (error && error->message) ? error->message : "(unknown)");
+
+	ASSERT (testfile != NULL,
+	        "bond-main-write", "didn't get ifcfg file path back after writing connection");
+
+	/* re-read the connection for comparison */
+	reread = connection_from_file (testfile,
+	                               NULL,
+	                               TYPE_BOND,
+	                               NULL,
+	                               &unmanaged,
+	                               &keyfile,
+	                               &routefile,
+	                               &route6file,
+	                               &error,
+	                               &ignore_error);
+	unlink (testfile);
+
+	ASSERT (reread != NULL,
+	        "bond-main-write-reread", "failed to read %s: %s", testfile, error->message);
+
+	ASSERT (nm_connection_verify (reread, &error),
+	        "bond-main-write-reread-verify", "failed to verify %s: %s", testfile, error->message);
+
+	ASSERT (nm_connection_compare (connection, reread, NM_SETTING_COMPARE_FLAG_EXACT) == TRUE,
+	        "bond-main-write", "written and re-read connection weren't the same.");
+
+	g_free (testfile);
+	g_free (unmanaged);
+	g_free (keyfile);
+	g_free (routefile);
+	g_free (route6file);
+	g_object_unref (connection);
+	g_object_unref (reread);
+}
+
+#define TEST_IFCFG_BOND_SLAVE TEST_IFCFG_DIR"/network-scripts/ifcfg-test-bond-slave"
+
+static void
+test_read_bond_slave (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	char *unmanaged = NULL;
+	char *keyfile = NULL;
+	char *routefile = NULL;
+	char *route6file = NULL;
+	gboolean ignore_error = FALSE;
+	GError *error = NULL;
+
+	connection = connection_from_file (TEST_IFCFG_BOND_SLAVE,
+	                                   NULL,
+	                                   TYPE_ETHERNET,
+	                                   NULL,
+	                                   &unmanaged,
+	                                   &keyfile,
+	                                   &routefile,
+	                                   &route6file,
+	                                   &error,
+	                                   &ignore_error);
+	ASSERT (connection != NULL,
+	        "bond-slave-read", "unexpected failure reading %s", TEST_IFCFG_BOND_MAIN);
+
+	ASSERT (nm_connection_verify (connection, &error),
+	        "bond-slave-read", "failed to verify %s: %s", TEST_IFCFG_BOND_MAIN, error->message);
+
+	s_con = nm_connection_get_setting_connection (connection);
+	ASSERT (s_con != NULL,
+	        "bond-slave-read", "failed to verify %s: missing %s setting",
+	        TEST_IFCFG_BOND_SLAVE, NM_SETTING_CONNECTION_SETTING_NAME);
+
+	ASSERT (g_strcmp0 (nm_setting_connection_get_master (s_con), "bond0") == 0,
+	        "bond-slave-read", "failed to verify %s: master is not bond0",
+	        TEST_IFCFG_BOND_SLAVE);
+
+	ASSERT (g_strcmp0 (nm_setting_connection_get_slave_type (s_con), NM_SETTING_BOND_SETTING_NAME) == 0,
+	        "bond-slave-read", "failed to verify %s: slave-type is not bond",
+	        TEST_IFCFG_BOND_SLAVE);
+
+	g_free (unmanaged);
+	g_free (keyfile);
+	g_free (routefile);
+	g_free (route6file);
+	g_object_unref (connection);
+}
+
+static void
+test_write_bond_slave (void)
+{
+	NMConnection *connection;
+	NMConnection *reread;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSettingIP4Config *s_ip4;
+	NMSettingIP6Config *s_ip6;
+	static unsigned char tmpmac[] = { 0x31, 0x33, 0x33, 0x37, 0xbe, 0xcd };
+	GByteArray *mac;
+	guint32 mtu = 1492;
+	char *uuid;
+	gboolean success;
+	GError *error = NULL;
+	char *testfile = NULL;
+	char *unmanaged = NULL;
+	char *keyfile = NULL;
+	char *routefile = NULL;
+	char *route6file = NULL;
+	gboolean ignore_error = FALSE;
+
+	connection = nm_connection_new ();
+	ASSERT (connection != NULL,
+	        "bond-slave-write", "failed to allocate new connection");
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	ASSERT (s_con != NULL,
+	        "bond-slave-write", "failed to allocate new %s setting",
+	        NM_SETTING_CONNECTION_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	uuid = nm_utils_uuid_generate ();
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Bond Slave",
+	              NM_SETTING_CONNECTION_UUID, uuid,
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+				  NM_SETTING_CONNECTION_MASTER, "bond0",
+				  NM_SETTING_CONNECTION_SLAVE_TYPE, NM_SETTING_BOND_SETTING_NAME,
+	              NULL);
+	g_free (uuid);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	ASSERT (s_wired != NULL,
+	        "bond-main-write", "failed to allocate new %s setting",
+	        NM_SETTING_WIRED_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	mac = g_byte_array_sized_new (sizeof (tmpmac));
+	g_byte_array_append (mac, &tmpmac[0], sizeof (tmpmac));
+
+	g_object_set (s_wired,
+	              NM_SETTING_WIRED_MAC_ADDRESS, mac,
+	              NM_SETTING_WIRED_MTU, mtu,
+	              NULL);
+	g_byte_array_free (mac, TRUE);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIP4Config *) nm_setting_ip4_config_new ();
+	ASSERT (s_ip4 != NULL,
+			"bond-slave-write", "failed to allocate new %s setting",
+			NM_SETTING_IP4_CONFIG_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP4_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_DISABLED,
+	              NULL);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIP6Config *) nm_setting_ip6_config_new ();
+	ASSERT (s_ip6 != NULL,
+	        "bond-slave-write", "failed to allocate new %s setting",
+	        NM_SETTING_IP6_CONFIG_SETTING_NAME);
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP6_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NM_SETTING_IP6_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	ASSERT (nm_connection_verify (connection, &error) == TRUE,
+	        "bond-slave-write", "failed to verify connection: %s",
+	        (error && error->message) ? error->message : "(unknown)");
+
+	/* Save the ifcfg */
+	success = writer_new_connection (connection,
+	                                 TEST_SCRATCH_DIR "/network-scripts/",
+	                                 &testfile,
+	                                 &error);
+	ASSERT (success == TRUE,
+	        "bond-slave-write", "failed to write connection to disk: %s",
+	        (error && error->message) ? error->message : "(unknown)");
+
+	ASSERT (testfile != NULL,
+	        "bond-slave-write", "didn't get ifcfg file path back after writing connection");
+
+	/* re-read the connection for comparison */
+	reread = connection_from_file (testfile,
+	                               NULL,
+	                               TYPE_ETHERNET,
+	                               NULL,
+	                               &unmanaged,
+	                               &keyfile,
+	                               &routefile,
+	                               &route6file,
+	                               &error,
+	                               &ignore_error);
+	unlink (testfile);
+
+	ASSERT (reread != NULL,
+	        "bond-slave-write-reread", "failed to read %s: %s", testfile, error->message);
+
+	ASSERT (nm_connection_verify (reread, &error),
+	        "bond-slave-write-reread-verify", "failed to verify %s: %s", testfile, error->message);
+
+	ASSERT (nm_connection_compare (connection, reread, NM_SETTING_COMPARE_FLAG_EXACT) == TRUE,
+	        "bond-slave-write", "written and re-read connection weren't the same.");
+
+	if (route6file)
+		unlink (route6file);
+
+	g_free (testfile);
+	g_free (unmanaged);
+	g_free (keyfile);
+	g_free (routefile);
+	g_free (route6file);
+	g_object_unref (connection);
+	g_object_unref (reread);
+}
+
 #define TEST_IFCFG_WIFI_OPEN_SSID_BAD_HEX TEST_IFCFG_DIR"/network-scripts/ifcfg-test-wifi-open-ssid-bad-hex"
 #define TEST_IFCFG_WIFI_OPEN_SSID_LONG_QUOTED TEST_IFCFG_DIR"/network-scripts/ifcfg-test-wifi-open-ssid-long-quoted"
 #define TEST_IFCFG_WIFI_OPEN_SSID_LONG_HEX TEST_IFCFG_DIR"/network-scripts/ifcfg-test-wifi-open-ssid-long-hex"
@@ -10025,6 +10401,12 @@ int main (int argc, char **argv)
 	test_read_ibft_malformed ("ibft-bad-dns1-read", TEST_IFCFG_DIR "/iscsiadm-test-bad-dns1");
 	test_read_ibft_malformed ("ibft-bad-dns2-read", TEST_IFCFG_DIR "/iscsiadm-test-bad-dns2");
 
+	/* bonding */
+	test_read_bond_main ();
+	test_read_bond_slave ();
+	test_write_bond_main ();
+	test_write_bond_slave ();
+
 	/* Stuff we expect to fail for now */
 	test_write_wired_pppoe ();
 	test_write_vpn ();
diff --git a/system-settings/plugins/ifcfg-rh/writer.c b/system-settings/plugins/ifcfg-rh/writer.c
index 0b46a4f..4097caf 100644
--- a/system-settings/plugins/ifcfg-rh/writer.c
+++ b/system-settings/plugins/ifcfg-rh/writer.c
@@ -31,6 +31,7 @@
 #include <netinet/ether.h>
 #include <nm-setting-infiniband.h>
 
+#include <nm-setting-bond.h>
 #include <nm-setting-connection.h>
 #include <nm-setting-wired.h>
 #include <nm-setting-wireless.h>
@@ -1000,10 +1001,62 @@ write_wired_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
 	return TRUE;
 }
 
+static gboolean
+write_bonding_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+{
+	NMSettingBond *s_bond;
+	const char *iface;
+	guint32 i, num_opts;
+
+	s_bond = nm_connection_get_setting_bond (connection);
+	if (!s_bond) {
+		g_set_error (error, IFCFG_PLUGIN_ERROR, 0,
+		             "Missing '%s' setting", NM_SETTING_BOND_SETTING_NAME);
+		return FALSE;
+	}
+
+	iface = nm_setting_bond_get_interface_name (s_bond);
+	if (!iface) {
+		g_set_error (error, IFCFG_PLUGIN_ERROR, 0, "Missing interface name");
+		return FALSE;
+	}
+
+	svSetValue (ifcfg, "DEVICE", iface, FALSE);
+	svSetValue (ifcfg, "BONDING_OPTS", NULL, FALSE);
+
+	num_opts = nm_setting_bond_get_num_options (s_bond);
+	if (num_opts > 0) {
+		GString *str = g_string_sized_new (64);
+
+		for (i = 0; i < nm_setting_bond_get_num_options (s_bond); i++) {
+			const char *key, *value;
+
+			if (!nm_setting_bond_get_option (s_bond, i, &key, &value))
+				continue;
+
+			if (str->len)
+				g_string_append_c (str, ' ');
+
+			g_string_append_printf (str, "%s=%s", key, value);
+		}
+
+		if (str->len)
+			svSetValue (ifcfg, "BONDING_OPTS", str->str, FALSE);
+
+		g_string_free (str, TRUE);
+	}
+
+	svSetValue (ifcfg, "TYPE", TYPE_BOND, FALSE);
+	svSetValue (ifcfg, "BONDING_MASTER", "yes", FALSE);
+
+	return TRUE;
+}
+
 static void
 write_connection_setting (NMSettingConnection *s_con, shvarFile *ifcfg)
 {
 	char *tmp;
+	const char *master;
 
 	svSetValue (ifcfg, "NAME", nm_setting_connection_get_id (s_con), FALSE);
 	svSetValue (ifcfg, "UUID", nm_setting_connection_get_uuid (s_con), FALSE);
@@ -1017,6 +1070,12 @@ write_connection_setting (NMSettingConnection *s_con, shvarFile *ifcfg)
 		svSetValue (ifcfg, "LAST_CONNECT", tmp, FALSE);
 		g_free (tmp);
 	}
+
+	master = nm_setting_connection_get_master (s_con);
+	if (master) {
+		if (nm_setting_connection_is_slave_type (s_con, NM_SETTING_BOND_SETTING_NAME))
+			svSetValue (ifcfg, "MASTER", master, FALSE);
+	}
 }
 
 static gboolean
@@ -1649,6 +1708,9 @@ write_connection (NMConnection *connection,
 	} else if (!strcmp (type, NM_SETTING_INFINIBAND_SETTING_NAME)) {
 		if (!write_infiniband_setting (connection, ifcfg, error))
 			goto out;
+	} else if (!strcmp (type, NM_SETTING_BOND_SETTING_NAME)) {
+		if (!write_bonding_setting (connection, ifcfg, error))
+			goto out;
 	} else {
 		g_set_error (error, IFCFG_PLUGIN_ERROR, 0,
 		             "Can't write connection type '%s'", type);
