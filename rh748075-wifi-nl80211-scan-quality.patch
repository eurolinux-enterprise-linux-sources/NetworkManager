diff -up NetworkManager-0.8.1/src/nm-device-wifi.c.qual NetworkManager-0.8.1/src/nm-device-wifi.c
--- NetworkManager-0.8.1/src/nm-device-wifi.c.qual	2011-10-21 13:37:03.956759492 -0700
+++ NetworkManager-0.8.1/src/nm-device-wifi.c	2011-10-21 15:43:28.572006724 -0700
@@ -1618,53 +1618,51 @@ wireless_qual_to_percent (const struct i
 	 * bounded by 0 and max_qual->qual, and MUST change in a linear fashion.  Within those bounds, drivers
 	 * are free to use whatever they want to calculate "Link Quality".
 	 */
-	if ((max_qual->qual != 0) && !(max_qual->updated & IW_QUAL_QUAL_INVALID) && !(qual->updated & IW_QUAL_QUAL_INVALID))
+	if (   (max_qual->qual != 0)
+	    && !(max_qual->updated & IW_QUAL_QUAL_INVALID)
+	    && !(qual->updated & IW_QUAL_QUAL_INVALID)) {
 		percent = (int)(100 * ((double)qual->qual / (double)max_qual->qual));
+		goto done;
+	}
 
-	/* If the driver doesn't specify a complete and valid quality, we have two options:
-	 *
-	 * 1) dBm: driver must specify max_qual->level = 0, and have valid values for
-	 *        qual->level and (qual->noise OR max_qual->noise)
-	 * 2) raw RSSI: driver must specify max_qual->level > 0, and have valid values for
-	 *        qual->level and max_qual->level
-	 *
-	 * This is the WEXT spec.  If this interpretation is wrong, I'll fix it.  Otherwise,
-	 * If drivers don't conform to it, they are wrong and need to be fixed.
+	/* Try with 'level' as dBm; max_qual->level must be 0 or driver must
+	 * flag levels as being dBm with IW_QUAL_DBM
 	 */
-
-	if (    (max_qual->level == 0) && !(max_qual->updated & IW_QUAL_LEVEL_INVALID)          /* Valid max_qual->level == 0 */
-		&& !(qual->updated & IW_QUAL_LEVEL_INVALID)                                     /* Must have valid qual->level */
-		&& (    ((max_qual->noise > 0) && !(max_qual->updated & IW_QUAL_NOISE_INVALID)) /* Must have valid max_qual->noise */
-			|| ((qual->noise > 0) && !(qual->updated & IW_QUAL_NOISE_INVALID)))     /*    OR valid qual->noise */
-	   ) {
-		/* Absolute power values (dBm) */
-
+	if (    (max_qual->level == 0 || max_qual->updated & IW_QUAL_DBM) /* max_qual->level == 0 means dBm, or flagged as dBm */
+	    && !(max_qual->updated & IW_QUAL_LEVEL_INVALID)               /* Valid max level */
+	    && !(qual->updated & IW_QUAL_LEVEL_INVALID)) {                /* Valid current level */
 		/* Reasonable fallbacks for dumb drivers that don't specify either level. */
-		#define FALLBACK_NOISE_FLOOR_DBM  -90
-		#define FALLBACK_SIGNAL_MAX_DBM   -20
-		int max_level = FALLBACK_SIGNAL_MAX_DBM;
-		int noise = FALLBACK_NOISE_FLOOR_DBM;
-		int level = qual->level - 0x100;
-
-		level = CLAMP (level, FALLBACK_NOISE_FLOOR_DBM, FALLBACK_SIGNAL_MAX_DBM);
+		#define FALLBACK_NOISE_FLOOR_DBM  -100
+		#define FALLBACK_SIGNAL_MAX_DBM   -25
+		double max_level = FALLBACK_SIGNAL_MAX_DBM;
+		double noise = FALLBACK_NOISE_FLOOR_DBM;
+		double level = (double) (qual->level - 0x100);
 
+		/* Use driver-provided noise level if it's valid; but clamp it to a 
+		 * range of reasonable noise floor values.
+		 */
 		if ((qual->noise > 0) && !(qual->updated & IW_QUAL_NOISE_INVALID))
-			noise = qual->noise - 0x100;
+			noise = (double) (qual->noise - 0x100);
 		else if ((max_qual->noise > 0) && !(max_qual->updated & IW_QUAL_NOISE_INVALID))
-			noise = max_qual->noise - 0x100;
-		noise = CLAMP (noise, FALLBACK_NOISE_FLOOR_DBM, FALLBACK_SIGNAL_MAX_DBM);
+			noise = (double) (max_qual->noise - 0x100);
+		noise = CLAMP (noise, -110, FALLBACK_NOISE_FLOOR_DBM);
 
-		/* A sort of signal-to-noise ratio calculation */
-		level_percent = (int)(100 - 70 *(
-		                                ((double)max_level - (double)level) /
-		                                ((double)max_level - (double)noise)));
+		/* Bill Moss' formula where roam level is 20%; ie when the card would
+		 * start looking for a better AP.
+		 * http://www.ces.clemson.edu/linux/dbm-rssi.shtml
+		 *
+		 * % = 100 - 80 * (max_signal - signal) / (max_signal - roam_signal)
+		 */
+		level_percent = (int) 100.0 - 80.0 * ((max_level - level) / (max_level - -85));
 		nm_log_dbg (LOGD_WIFI, "QL1: level_percent is %d.  max_level %d, level %d, noise_floor %d.",
-		            level_percent, max_level, level, noise);
-	} else if (   (max_qual->level != 0)
-	           && !(max_qual->updated & IW_QUAL_LEVEL_INVALID) /* Valid max_qual->level as upper bound */
-	           && !(qual->updated & IW_QUAL_LEVEL_INVALID)) {
-		/* Relative power values (RSSI) */
+		            level_percent, (int) max_level, (int) level, (int) noise);
+		goto done;
+	}
 
+	/* Otherwise it might be raw RSSI */
+	if (   (max_qual->level != 0) && !(max_qual->updated & IW_QUAL_DBM) /* 'level' is RSSI */
+	    && !(max_qual->updated & IW_QUAL_LEVEL_INVALID)
+	    && !(qual->updated & IW_QUAL_LEVEL_INVALID)) {
 		int level = qual->level;
 
 		/* Signal level is relavtive (0 -> max_qual->level) */
@@ -1672,10 +1670,12 @@ wireless_qual_to_percent (const struct i
 		level_percent = (int)(100 * ((double)level / (double)max_qual->level));
 		nm_log_dbg (LOGD_WIFI, "QL2: level_percent is %d.  max_level %d, level %d.",
 		            level_percent, max_qual->level, level);
-	} else if (percent == -1) {
-		nm_log_dbg (LOGD_WIFI, "QL: Could not get quality %% value from driver.  Driver is probably buggy.");
+		goto done;
 	}
 
+	nm_log_dbg (LOGD_WIFI, "QL: Could not get quality %% value from driver.  Driver is probably buggy.");
+
+done:
 	/* If the quality percent was 0 or doesn't exist, then try to use signal levels instead */
 	if ((percent < 1) && (level_percent >= 0))
 		percent = level_percent;
