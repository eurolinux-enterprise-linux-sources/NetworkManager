From 0951db3975e753ce92d31938a01b1a07eedf7cef Mon Sep 17 00:00:00 2001
From: Dan Williams <dcbw@redhat.com>
Date: Wed, 14 Nov 2012 18:00:22 -0600
Subject: [PATCH 1/3] core: add support for bridge interfaces (rh #558983)

Squash of Thomas Graf's bridging patches to the NetworkManager
mailing list backported to RHEL6, along with fixes from upstream.
---
 cli/src/connections.c                              |   28 +-
 cli/src/devices.c                                  |    5 +
 cli/src/settings.c                                 |  100 +++
 cli/src/settings.h                                 |    4 +
 docs/generate-settings-spec.c                      |    4 +
 docs/libnm-glib/Makefile.am                        |    1 +
 docs/libnm-glib/libnm-glib-docs.sgml               |    1 +
 docs/libnm-glib/libnm-glib.types                   |    2 +
 docs/libnm-util/libnm-util-docs.sgml               |    2 +
 include/NetworkManager.h                           |    2 +
 introspection/Makefile.am                          |    1 +
 introspection/all.xml                              |    1 +
 introspection/nm-device-bond.xml                   |    7 +
 introspection/nm-device-bridge.xml                 |   34 +
 introspection/nm-device.xml                        |    5 +
 libnm-glib/Makefile.am                             |    8 +-
 libnm-glib/libnm-glib.ver                          |    9 +
 libnm-glib/nm-active-connection.c                  |   46 ++
 libnm-glib/nm-active-connection.h                  |    2 +
 libnm-glib/nm-device-bond.c                        |   75 ++
 libnm-glib/nm-device-bond.h                        |    6 +-
 libnm-glib/nm-device-bridge.c                      |  358 +++++++++
 libnm-glib/nm-device-bridge.h                      |   84 ++
 libnm-glib/nm-device.c                             |    4 +
 libnm-util/Makefile.am                             |    6 +-
 libnm-util/libnm-util.ver                          |   20 +
 libnm-util/nm-connection.c                         |   48 ++-
 libnm-util/nm-connection.h                         |    4 +
 libnm-util/nm-setting-bridge-port.c                |  298 ++++++++
 libnm-util/nm-setting-bridge-port.h                |   89 +++
 libnm-util/nm-setting-bridge.c                     |  515 +++++++++++++
 libnm-util/nm-setting-bridge.h                     |  101 +++
 src/Makefile.am                                    |    6 +
 src/NetworkManagerUtils.c                          |   62 ++-
 src/ip6-manager/nm-ip6-manager.c                   |   10 +-
 src/nm-activation-request.c                        |  102 +---
 src/nm-activation-request.h                        |   17 +-
 src/nm-device-bond.c                               |  384 +++++++---
 src/nm-device-bond.h                               |    1 +
 src/nm-device-bridge.c                             |  791 ++++++++++++++++++++
 src/nm-device-bridge.h                             |   60 ++
 src/nm-device-infiniband.c                         |    6 +-
 src/nm-device-interface.c                          |   17 +-
 src/nm-device-interface.h                          |    8 +-
 src/nm-device-private.h                            |    3 +
 src/nm-device-wired.c                              |   39 +-
 src/nm-device-wired.h                              |    3 +
 src/nm-device.c                                    |  639 +++++++++++------
 src/nm-device.h                                    |   15 +-
 src/nm-manager.c                                   |  114 +++-
 src/nm-netlink-monitor.c                           |   62 ++-
 src/nm-system.c                                    |  295 +++++++-
 src/nm-system.h                                    |   19 +-
 src/nm-udev-manager.c                              |    3 +
 system-settings/plugins/ifcfg-rh/reader.c          |  305 +++++++-
 .../network-scripts/ifcfg-test-bridge-component    |    2 +-
 .../tests/network-scripts/ifcfg-test-bridge-main   |    2 +-
 .../plugins/ifcfg-rh/tests/test-ifcfg-rh.c         |  274 +++++++-
 system-settings/plugins/ifcfg-rh/utils.c           |    3 +-
 system-settings/plugins/ifcfg-rh/writer.c          |  138 ++++
 .../plugins/keyfile/tests/keyfiles/Makefile.am     |    2 +
 .../keyfile/tests/keyfiles/Test_Bridge_Component   |   15 +
 .../keyfile/tests/keyfiles/Test_Bridge_Main        |   17 +
 .../plugins/keyfile/tests/test-keyfile.c           |  260 +++++++
 64 files changed, 4934 insertions(+), 610 deletions(-)
 create mode 100644 introspection/nm-device-bridge.xml
 create mode 100644 libnm-glib/nm-device-bridge.c
 create mode 100644 libnm-glib/nm-device-bridge.h
 create mode 100644 libnm-util/nm-setting-bridge-port.c
 create mode 100644 libnm-util/nm-setting-bridge-port.h
 create mode 100644 libnm-util/nm-setting-bridge.c
 create mode 100644 libnm-util/nm-setting-bridge.h
 create mode 100644 src/nm-device-bridge.c
 create mode 100644 src/nm-device-bridge.h
 create mode 100644 system-settings/plugins/keyfile/tests/keyfiles/Test_Bridge_Component
 create mode 100644 system-settings/plugins/keyfile/tests/keyfiles/Test_Bridge_Main

diff --git a/cli/src/connections.c b/cli/src/connections.c
index 006eda3..3db7bf6 100644
--- a/cli/src/connections.c
+++ b/cli/src/connections.c
@@ -40,6 +40,7 @@
 #include <nm-setting-olpc-mesh.h>
 #include <nm-setting-infiniband.h>
 #include <nm-device-bond.h>
+#include <nm-device-bridge.h>
 #include <nm-device-vlan.h>
 #include <nm-device-ethernet.h>
 #include <nm-device-wifi.h>
@@ -114,6 +115,8 @@ static NmcOutputField nmc_fields_settings_names[] = {
 	SETTING_FIELD (NM_SETTING_INFINIBAND_SETTING_NAME, 0),            /* 15 */
 	SETTING_FIELD (NM_SETTING_BOND_SETTING_NAME, 0),                  /* 16 */
 	SETTING_FIELD (NM_SETTING_VLAN_SETTING_NAME, 0),                  /* 17 */
+	SETTING_FIELD (NM_SETTING_BRIDGE_SETTING_NAME, 0),                /* 18 */
+	SETTING_FIELD (NM_SETTING_BRIDGE_PORT_SETTING_NAME, 0),           /* 19 */
 	{NULL, NULL, 0, NULL, 0}
 };
 #define NMC_FIELDS_SETTINGS_NAMES_ALL    NM_SETTING_CONNECTION_SETTING_NAME","\
@@ -133,7 +136,9 @@ static NmcOutputField nmc_fields_settings_names[] = {
                                          NM_SETTING_VPN_SETTING_NAME"," \
                                          NM_SETTING_INFINIBAND_SETTING_NAME"," \
                                          NM_SETTING_BOND_SETTING_NAME"," \
-                                         NM_SETTING_VLAN_SETTING_NAME
+                                         NM_SETTING_VLAN_SETTING_NAME","\
+                                         NM_SETTING_BRIDGE_SETTING_NAME","\
+                                         NM_SETTING_BRIDGE_PORT_SETTING_NAME
 
 
 typedef struct {
@@ -390,6 +395,24 @@ nmc_connection_detail (NMConnection *connection, NmCli *nmc)
 				continue;
 			}
 		}
+
+		if (!strcasecmp (nmc_fields_settings_names[section_idx].name, nmc_fields_settings_names[18].name)) {
+			NMSettingBridge *s_bridge = nm_connection_get_setting_bridge (connection);
+			if (s_bridge) {
+				setting_bridge_details (s_bridge, nmc);
+				was_output = TRUE;
+				continue;
+			}
+		}
+
+		if (!strcasecmp (nmc_fields_settings_names[section_idx].name, nmc_fields_settings_names[19].name)) {
+			NMSettingBridgePort *s_bridge_port = nm_connection_get_setting_bridge_port (connection);
+			if (s_bridge_port) {
+				setting_bridge_port_details (s_bridge_port, nmc);
+				was_output = TRUE;
+				continue;
+			}
+		}
 	}
 
 	if (print_settings_array)
@@ -1581,7 +1604,8 @@ do_connection_up (NmCli *nmc, int argc, char **argv)
 	con_type = nm_setting_connection_get_connection_type (s_con);
 
 	if (   nm_connection_is_type (connection, NM_SETTING_BOND_SETTING_NAME)
-	    || nm_connection_is_type (connection, NM_SETTING_VLAN_SETTING_NAME))
+	    || nm_connection_is_type (connection, NM_SETTING_VLAN_SETTING_NAME)
+	    || nm_connection_is_type (connection, NM_SETTING_BRIDGE_SETTING_NAME))
 		is_virtual = TRUE;
 
 	device_found = find_device_for_connection (nmc, connection, iface, ap, &device, &spec_object, &error);
diff --git a/cli/src/devices.c b/cli/src/devices.c
index f10bd07..e1490e5 100644
--- a/cli/src/devices.c
+++ b/cli/src/devices.c
@@ -41,6 +41,7 @@
 //#include <nm-device-olpc-mesh.h>
 #include <nm-device-infiniband.h>
 #include <nm-device-bond.h>
+#include <nm-device-bridge.h>
 #include <nm-device-vlan.h>
 #include <nm-utils.h>
 #include <nm-setting-ip4-config.h>
@@ -275,6 +276,8 @@ get_device_type (NMDevice * device)
 		return NM_SETTING_BOND_SETTING_NAME;
 	else if (NM_IS_DEVICE_VLAN (device))
 		return NM_SETTING_VLAN_SETTING_NAME;
+	else if (NM_IS_DEVICE_BRIDGE (device))
+		return NM_SETTING_BRIDGE_SETTING_NAME;
 	else
 		return _("Unknown");
 }
@@ -538,6 +541,8 @@ show_device_info (gpointer data, gpointer user_data)
 				hwaddr = nm_device_bond_get_hw_address (NM_DEVICE_BOND (device));
 			else if (NM_IS_DEVICE_VLAN (device))
 				hwaddr = nm_device_vlan_get_hw_address (NM_DEVICE_VLAN (device));
+			else if (NM_IS_DEVICE_BRIDGE (device))
+				hwaddr = nm_device_bridge_get_hw_address (NM_DEVICE_BRIDGE (device));
 
 			nmc->allowed_fields[0].value = nmc_fields_dev_list_sections[0].name;  /* "GENERAL"*/
 			nmc->allowed_fields[1].value = nm_device_get_iface (device);
diff --git a/cli/src/settings.c b/cli/src/settings.c
index ab0ec11..8cbfc8d 100644
--- a/cli/src/settings.c
+++ b/cli/src/settings.c
@@ -454,6 +454,42 @@ static NmcOutputField nmc_fields_setting_vlan[] = {
                                         NM_SETTING_VLAN_EGRESS_PRIORITY_MAP
 #define NMC_FIELDS_SETTING_VLAN_COMMON  NMC_FIELDS_SETTING_VLAN_ALL
 
+/* Available fields for NM_SETTING_BRIDGE_SETTING_NAME */
+static NmcOutputField nmc_fields_setting_bridge[] = {
+	SETTING_FIELD ("name",  8),                                        /* 0 */
+	SETTING_FIELD (NM_SETTING_BRIDGE_INTERFACE_NAME, 15),              /* 1 */
+	SETTING_FIELD (NM_SETTING_BRIDGE_STP, 5),                          /* 2 */
+	SETTING_FIELD (NM_SETTING_BRIDGE_PRIORITY, 6),                     /* 3 */
+	SETTING_FIELD (NM_SETTING_BRIDGE_FORWARD_DELAY, 6),                /* 4 */
+	SETTING_FIELD (NM_SETTING_BRIDGE_HELLO_TIME, 6),                   /* 5 */
+	SETTING_FIELD (NM_SETTING_BRIDGE_MAX_AGE, 6),                      /* 6 */
+	SETTING_FIELD (NM_SETTING_BRIDGE_AGEING_TIME, 6),                  /* 7 */
+	{NULL, NULL, 0, NULL, 0}
+};
+#define NMC_FIELDS_SETTING_BRIDGE_ALL    "name"","\
+                                         NM_SETTING_BRIDGE_INTERFACE_NAME","\
+                                         NM_SETTING_BRIDGE_STP","\
+                                         NM_SETTING_BRIDGE_PRIORITY","\
+                                         NM_SETTING_BRIDGE_FORWARD_DELAY","\
+                                         NM_SETTING_BRIDGE_HELLO_TIME","\
+                                         NM_SETTING_BRIDGE_MAX_AGE","\
+                                         NM_SETTING_BRIDGE_AGEING_TIME
+#define NMC_FIELDS_SETTING_BRIDGE_COMMON NMC_FIELDS_SETTING_BRIDGE_ALL
+
+/* Available fields for NM_SETTING_BRIDGE_PORT_SETTING_NAME */
+static NmcOutputField nmc_fields_setting_bridge_port[] = {
+	SETTING_FIELD ("name",  8),                                        /* 0 */
+	SETTING_FIELD (NM_SETTING_BRIDGE_PORT_PRIORITY, 10),               /* 1 */
+	SETTING_FIELD (NM_SETTING_BRIDGE_PORT_PATH_COST, 12),              /* 2 */
+	SETTING_FIELD (NM_SETTING_BRIDGE_PORT_HAIRPIN_MODE, 15),           /* 3 */
+	{NULL, NULL, 0, NULL, 0}
+};
+#define NMC_FIELDS_SETTING_BRIDGE_PORT_ALL    "name"","\
+                                              NM_SETTING_BRIDGE_PORT_PRIORITY","\
+                                              NM_SETTING_BRIDGE_PORT_PATH_COST","\
+                                              NM_SETTING_BRIDGE_PORT_HAIRPIN_MODE
+#define NMC_FIELDS_SETTING_BRIDGE_PORT_COMMON NMC_FIELDS_SETTING_BRIDGE_PORT_ALL
+
 
 static char *
 wep_key_type_to_string (NMWepKeyType type)
@@ -1598,3 +1634,67 @@ setting_vlan_details (NMSetting *setting, NmCli *nmc)
 	return TRUE;
 }
 
+gboolean
+setting_bridge_details (NMSettingBridge *s_bridge, NmCli *nmc)
+{
+	guint32 mode_flag = (nmc->print_output == NMC_PRINT_PRETTY) ? NMC_PF_FLAG_PRETTY : (nmc->print_output == NMC_PRINT_TERSE) ? NMC_PF_FLAG_TERSE : 0;
+	guint32 multiline_flag = nmc->multiline_output ? NMC_PF_FLAG_MULTILINE : 0;
+	guint32 escape_flag = nmc->escape_values ? NMC_PF_FLAG_ESCAPE : 0;
+
+	g_return_val_if_fail (NM_IS_SETTING_BRIDGE (s_bridge), FALSE);
+
+	nmc->allowed_fields = nmc_fields_setting_bridge;
+	nmc->print_fields.indices = parse_output_fields (NMC_FIELDS_SETTING_BRIDGE_ALL, nmc->allowed_fields, NULL);
+	nmc->print_fields.flags = multiline_flag | mode_flag | escape_flag | NMC_PF_FLAG_FIELD_NAMES;
+	print_fields (nmc->print_fields, nmc->allowed_fields);  /* Print field names */
+
+	nmc->allowed_fields[0].value = NM_SETTING_BRIDGE_SETTING_NAME;
+	nmc->allowed_fields[1].value = nm_setting_bridge_get_interface_name (s_bridge);
+	nmc->allowed_fields[2].value = nm_setting_bridge_get_stp (s_bridge) ? _("yes") : _("no");
+	nmc->allowed_fields[3].value = g_strdup_printf ("%u", nm_setting_bridge_get_priority (s_bridge));
+	nmc->allowed_fields[4].value = g_strdup_printf ("%u", nm_setting_bridge_get_forward_delay (s_bridge));
+	nmc->allowed_fields[5].value = g_strdup_printf ("%u", nm_setting_bridge_get_hello_time (s_bridge));
+	nmc->allowed_fields[6].value = g_strdup_printf ("%u", nm_setting_bridge_get_max_age (s_bridge));
+	nmc->allowed_fields[7].value = g_strdup_printf ("%u", nm_setting_bridge_get_ageing_time (s_bridge));
+
+	nmc->print_fields.flags = multiline_flag | mode_flag | escape_flag | NMC_PF_FLAG_SECTION_PREFIX;
+	print_fields (nmc->print_fields, nmc->allowed_fields); /* Print values */
+
+	/* free values */
+	g_free ((char*) nmc->allowed_fields[3].value);
+	g_free ((char*) nmc->allowed_fields[4].value);
+	g_free ((char*) nmc->allowed_fields[5].value);
+	g_free ((char*) nmc->allowed_fields[6].value);
+	g_free ((char*) nmc->allowed_fields[7].value);
+
+	return TRUE;
+}
+
+gboolean
+setting_bridge_port_details (NMSettingBridgePort *s_bridge_port, NmCli *nmc)
+{
+	guint32 mode_flag = (nmc->print_output == NMC_PRINT_PRETTY) ? NMC_PF_FLAG_PRETTY : (nmc->print_output == NMC_PRINT_TERSE) ? NMC_PF_FLAG_TERSE : 0;
+	guint32 multiline_flag = nmc->multiline_output ? NMC_PF_FLAG_MULTILINE : 0;
+	guint32 escape_flag = nmc->escape_values ? NMC_PF_FLAG_ESCAPE : 0;
+
+	g_return_val_if_fail (NM_IS_SETTING_BRIDGE_PORT (s_bridge_port), FALSE);
+
+	nmc->allowed_fields = nmc_fields_setting_bridge_port;
+	nmc->print_fields.indices = parse_output_fields (NMC_FIELDS_SETTING_BRIDGE_PORT_ALL, nmc->allowed_fields, NULL);
+	nmc->print_fields.flags = multiline_flag | mode_flag | escape_flag | NMC_PF_FLAG_FIELD_NAMES;
+	print_fields (nmc->print_fields, nmc->allowed_fields);  /* Print field names */
+
+	nmc->allowed_fields[0].value = NM_SETTING_BRIDGE_PORT_SETTING_NAME;
+	nmc->allowed_fields[1].value = g_strdup_printf ("%u", nm_setting_bridge_port_get_priority (s_bridge_port));
+	nmc->allowed_fields[2].value = g_strdup_printf ("%u", nm_setting_bridge_port_get_path_cost (s_bridge_port));
+	nmc->allowed_fields[3].value = nm_setting_bridge_port_get_hairpin_mode (s_bridge_port) ? _("yes") : _("no");
+
+	nmc->print_fields.flags = multiline_flag | mode_flag | escape_flag | NMC_PF_FLAG_SECTION_PREFIX;
+	print_fields (nmc->print_fields, nmc->allowed_fields); /* Print values */
+
+	g_free ((char*) nmc->allowed_fields[1].value);
+	g_free ((char*) nmc->allowed_fields[2].value);
+
+	return TRUE;
+}
+
diff --git a/cli/src/settings.h b/cli/src/settings.h
index e7ba3df..ced3c4a 100644
--- a/cli/src/settings.h
+++ b/cli/src/settings.h
@@ -37,6 +37,8 @@
 #include <nm-setting-vpn.h>
 #include <nm-setting-infiniband.h>
 #include <nm-setting-bond.h>
+#include <nm-setting-bridge.h>
+#include <nm-setting-bridge-port.h>
 #include <nm-setting-vlan.h>
 
 #include "nmcli.h"
@@ -61,5 +63,7 @@ gboolean setting_vpn_details (NMSetting *setting, NmCli *nmc);
 gboolean setting_infiniband_details (NMSetting *setting, NmCli *nmc);
 gboolean setting_bond_details (NMSetting *setting, NmCli *nmc);
 gboolean setting_vlan_details (NMSetting *setting, NmCli *nmc);
+gboolean setting_bridge_details (NMSettingBridge *s_bridge, NmCli *nmc);
+gboolean setting_bridge_port_details (NMSettingBridgePort *s_bridge_port, NmCli *nmc);
 
 #endif /* NMC_SETTINGS_H */
diff --git a/docs/generate-settings-spec.c b/docs/generate-settings-spec.c
index 6c81913..2f7c7a8 100644
--- a/docs/generate-settings-spec.c
+++ b/docs/generate-settings-spec.c
@@ -32,6 +32,8 @@
 #include <nm-setting-8021x.h>
 #include <nm-setting-bluetooth.h>
 #include <nm-setting-bond.h>
+#include <nm-setting-bridge.h>
+#include <nm-setting-bridge-port.h>
 #include <nm-setting-cdma.h>
 #include <nm-setting-connection.h>
 #include <nm-setting-gsm.h>
@@ -57,6 +59,8 @@ static SettingNewFunc funcs[] = {
 	nm_setting_802_1x_new,
 	nm_setting_bluetooth_new,
 	nm_setting_bond_new,
+	nm_setting_bridge_new,
+	nm_setting_bridge_port_new,
 	nm_setting_cdma_new,
 	nm_setting_connection_new,
 	nm_setting_gsm_new,
diff --git a/docs/libnm-glib/Makefile.am b/docs/libnm-glib/Makefile.am
index a419256..3867121 100644
--- a/docs/libnm-glib/Makefile.am
+++ b/docs/libnm-glib/Makefile.am
@@ -41,6 +41,7 @@ IGNORE_HFILES= \
 	nm-client-bindings.h \
 	nm-device-bindings.h \
 	nm-device-bond-bindings.h \
+	nm-device-bridge-bindings.h \
 	nm-device-bt-bindings.h \
 	nm-device-ethernet-bindings.h \
 	nm-device-wifi-bindings.h \
diff --git a/docs/libnm-glib/libnm-glib-docs.sgml b/docs/libnm-glib/libnm-glib-docs.sgml
index 47de919..b76a73f 100644
--- a/docs/libnm-glib/libnm-glib-docs.sgml
+++ b/docs/libnm-glib/libnm-glib-docs.sgml
@@ -22,6 +22,7 @@
     <xi:include href="xml/nm-gsm-device.xml"/>
     <xi:include href="xml/nm-cdma-device.xml"/>
     <xi:include href="xml/nm-device-bond.xml"/>
+    <xi:include href="xml/nm-device-bridge.xml"/>
     <xi:include href="xml/nm-device-bt.xml"/>
     <xi:include href="xml/nm-device-infiniband.xml"/>
     <xi:include href="xml/nm-device-vlan.xml"/>
diff --git a/docs/libnm-glib/libnm-glib.types b/docs/libnm-glib/libnm-glib.types
index 16efa63..1969431 100644
--- a/docs/libnm-glib/libnm-glib.types
+++ b/docs/libnm-glib/libnm-glib.types
@@ -3,6 +3,7 @@
 #include <nm-device-wifi.h>
 #include <nm-device-infiniband.h>
 #include <nm-device-bond.h>
+#include <nm-device-bridge.h>
 #include <nm-device-vlan.h>
 #include <nm-cdma-device.h>
 #include <nm-gsm-device.h>
@@ -20,6 +21,7 @@ nm_device_ethernet_get_type
 nm_device_wifi_get_type
 nm_device_infiniband_get_type
 nm_device_bond_get_type
+nm_device_bridge_get_type
 nm_device_vlan_get_type
 nm_gsm_device_get_type
 nm_cdma_device_get_type
diff --git a/docs/libnm-util/libnm-util-docs.sgml b/docs/libnm-util/libnm-util-docs.sgml
index 9dd3c68..e027542 100644
--- a/docs/libnm-util/libnm-util-docs.sgml
+++ b/docs/libnm-util/libnm-util-docs.sgml
@@ -24,6 +24,8 @@
     <xi:include href="xml/nm-setting-wireless-security.xml"/>
     <xi:include href="xml/nm-setting-bluetooth.xml"/>
     <xi:include href="xml/nm-setting-bond.xml"/>
+    <xi:include href="xml/nm-setting-bridge.xml"/>
+    <xi:include href="xml/nm-setting-bridge-port.xml"/>
     <xi:include href="xml/nm-setting-serial.xml"/>
     <xi:include href="xml/nm-setting-cdma.xml"/>
     <xi:include href="xml/nm-setting-gsm.xml"/>
diff --git a/include/NetworkManager.h b/include/NetworkManager.h
index 7f8e980..50ce020 100644
--- a/include/NetworkManager.h
+++ b/include/NetworkManager.h
@@ -46,6 +46,7 @@
 #define NM_DBUS_INTERFACE_DEVICE_INFINIBAND NM_DBUS_INTERFACE_DEVICE ".Infiniband"
 #define NM_DBUS_INTERFACE_DEVICE_BOND       NM_DBUS_INTERFACE_DEVICE ".Bond"
 #define NM_DBUS_INTERFACE_DEVICE_VLAN       NM_DBUS_INTERFACE_DEVICE ".Vlan"
+#define NM_DBUS_INTERFACE_DEVICE_BRIDGE     NM_DBUS_INTERFACE_DEVICE ".Bridge"
 
 
 #define NM_DBUS_SERVICE_USER_SETTINGS     "org.freedesktop.NetworkManagerUserSettings"
@@ -87,6 +88,7 @@ typedef enum NMDeviceType
 	NM_DEVICE_TYPE_INFINIBAND = 9,
 	NM_DEVICE_TYPE_BOND = 10,
 	NM_DEVICE_TYPE_VLAN = 11,
+	NM_DEVICE_TYPE_BRIDGE = 13,
 } NMDeviceType;
 
 /* DEPRECATED TYPE NAMES */
diff --git a/introspection/Makefile.am b/introspection/Makefile.am
index e2918d0..af780fc 100644
--- a/introspection/Makefile.am
+++ b/introspection/Makefile.am
@@ -9,6 +9,7 @@ EXTRA_DIST = \
 	nm-device-olpc-mesh.xml \
 	nm-device-ethernet.xml \
 	nm-device-bond.xml \
+	nm-device-bridge.xml \
 	nm-device-cdma.xml \
 	nm-device-gsm.xml \
 	nm-device-infiniband.xml \
diff --git a/introspection/all.xml b/introspection/all.xml
index e192531..45488aa 100644
--- a/introspection/all.xml
+++ b/introspection/all.xml
@@ -37,6 +37,7 @@ Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.</
 <xi:include href="nm-device-olpc-mesh.xml"/>
 <xi:include href="nm-device-infiniband.xml"/>
 <xi:include href="nm-device-bond.xml"/>
+<xi:include href="nm-device-bridge.xml"/>
 <xi:include href="nm-device-vlan.xml"/>
 <xi:include href="nm-ip4-config.xml"/>
 <xi:include href="nm-ip6-config.xml"/>
diff --git a/introspection/nm-device-bond.xml b/introspection/nm-device-bond.xml
index 9d200ef..a804ca0 100644
--- a/introspection/nm-device-bond.xml
+++ b/introspection/nm-device-bond.xml
@@ -15,6 +15,13 @@
       </tp:docstring>
     </property>
 
+    <property name="Slaves" type="ao" access="read">
+      <tp:docstring>
+        Array of object paths representing devices which are currently
+	slaved to this device.
+      </tp:docstring>
+    </property>
+
     <signal name="PropertiesChanged">
         <arg name="properties" type="a{sv}" tp:type="String_Variant_Map">
             <tp:docstring>
diff --git a/introspection/nm-device-bridge.xml b/introspection/nm-device-bridge.xml
new file mode 100644
index 0000000..f3b2560
--- /dev/null
+++ b/introspection/nm-device-bridge.xml
@@ -0,0 +1,34 @@
+<?xml version="1.0" encoding="UTF-8" ?>
+
+<node name="/" xmlns:tp="http://telepathy.freedesktop.org/wiki/DbusSpec#extensions-v0">
+  <interface name="org.freedesktop.NetworkManager.Device.Bridge">
+
+    <property name="HwAddress" type="s" access="read">
+      <tp:docstring>
+        Hardware address of the device.
+      </tp:docstring>
+    </property>
+
+    <property name="Carrier" type="b" access="read">
+      <tp:docstring>
+        Indicates whether the physical carrier is found (e.g. whether a cable is plugged in or not).
+      </tp:docstring>
+    </property>
+
+    <property name="Slaves" type="ao" access="read">
+      <tp:docstring>
+        Array of object paths representing devices which are currently
+	slaved to this device.
+      </tp:docstring>
+    </property>
+
+    <signal name="PropertiesChanged">
+        <arg name="properties" type="a{sv}" tp:type="String_Variant_Map">
+            <tp:docstring>
+                A dictionary mapping property names to variant boxed values
+            </tp:docstring>
+        </arg>
+    </signal>
+
+  </interface>
+</node>
diff --git a/introspection/nm-device.xml b/introspection/nm-device.xml
index f6bd931..ba4828b 100644
--- a/introspection/nm-device.xml
+++ b/introspection/nm-device.xml
@@ -192,6 +192,11 @@
           The device is a VLAN interface.
         </tp:docstring>
       </tp:enumvalue>
+      <tp:enumvalue suffix="BRIDGE" value="13">
+        <tp:docstring>
+          The device is a bridge interface.
+        </tp:docstring>
+      </tp:enumvalue>
     </tp:enum>
 
     <tp:flags name="NM_DEVICE_CAP" value-prefix="NM_DEVICE_CAP" type="u">
diff --git a/libnm-glib/Makefile.am b/libnm-glib/Makefile.am
index bc88d48..d82714a 100644
--- a/libnm-glib/Makefile.am
+++ b/libnm-glib/Makefile.am
@@ -12,6 +12,7 @@ BUILT_SOURCES = \
 	nm-device-wifi-bindings.h \
 	nm-device-bt-bindings.h \
 	nm-device-bond-bindings.h \
+	nm-device-bridge-bindings.h \
 	nm-device-vlan-bindings.h \
 	nm-exported-connection-glue.h \
 	nm-exported-connection-bindings.h \
@@ -70,6 +71,7 @@ libnminclude_HEADERS = \
 	nm-device-wifi.h \
 	nm-device-bt.h \
 	nm-device-bond.h \
+	nm-device-bridge.h \
 	nm-device-vlan.h \
 	nm-access-point.h \
 	nm-ip4-config.h \
@@ -106,6 +108,7 @@ libnm_glib_la_SOURCES = \
 	nm-device-wifi.c \
 	nm-device-bt.c \
 	nm-device-bond.c \
+	nm-device-bridge.c \
 	nm-device-vlan.c \
 	nm-access-point.c \
 	nm-ip4-config.c \
@@ -141,7 +144,7 @@ libnm_glib_la_LIBADD = \
 	$(GUDEV_LIBS)
 
 libnm_glib_la_LDFLAGS = -Wl,--version-script=$(srcdir)/libnm-glib.ver \
-	-version-info "7:0:5"
+	-version-info "8:0:6"
 
 noinst_PROGRAMS = libnm-glib-test
 
@@ -178,6 +181,9 @@ nm-device-bt-bindings.h: $(top_srcdir)/introspection/nm-device-bt.xml
 nm-device-bond-bindings.h: $(top_srcdir)/introspection/nm-device-bond.xml
 	$(AM_V_GEN) dbus-binding-tool --prefix=nm_device_bond --mode=glib-client --output=$@ $<
 
+nm-device-bridge-bindings.h: $(top_srcdir)/introspection/nm-device-bridge.xml
+	$(AM_V_GEN) dbus-binding-tool --prefix=nm_device_bridge --mode=glib-client --output=$@ $<
+
 nm-device-vlan-bindings.h: $(top_srcdir)/introspection/nm-device-vlan.xml
 	$(AM_V_GEN) dbus-binding-tool --prefix=nm_device_vlan --mode=glib-client --output=$@ $<
 
diff --git a/libnm-glib/libnm-glib.ver b/libnm-glib/libnm-glib.ver
index 20a070d..dabde6e 100644
--- a/libnm-glib/libnm-glib.ver
+++ b/libnm-glib/libnm-glib.ver
@@ -20,6 +20,7 @@ global:
 	nm_active_connection_get_default;
 	nm_active_connection_get_default6;
 	nm_active_connection_get_devices;
+	nm_active_connection_get_master;
 	nm_active_connection_get_scope;
 	nm_active_connection_get_service_name;
 	nm_active_connection_get_specific_object;
@@ -57,8 +58,16 @@ global:
 	nm_dbus_settings_system_new;
 	nm_device_bond_get_carrier;
 	nm_device_bond_get_hw_address;
+	nm_device_bond_get_slaves;
 	nm_device_bond_get_type;
 	nm_device_bond_new;
+	nm_device_bridge_error_get_type;
+	nm_device_bridge_error_quark;
+	nm_device_bridge_get_carrier;
+	nm_device_bridge_get_hw_address;
+	nm_device_bridge_get_slaves;
+	nm_device_bridge_get_type;
+	nm_device_bridge_new;
 	nm_device_bt_new;
 	nm_device_bt_get_capabilities;
 	nm_device_bt_get_hw_address;
diff --git a/libnm-glib/nm-active-connection.c b/libnm-glib/nm-active-connection.c
index 2468da0..5378fba 100644
--- a/libnm-glib/nm-active-connection.c
+++ b/libnm-glib/nm-active-connection.c
@@ -51,6 +51,7 @@ typedef struct {
 	NMActiveConnectionState state;
 	gboolean is_default;
 	gboolean is_default6;
+	char *master;
 } NMActiveConnectionPrivate;
 
 enum {
@@ -62,6 +63,7 @@ enum {
 	PROP_STATE,
 	PROP_DEFAULT,
 	PROP_DEFAULT6,
+	PROP_MASTER,
 
 	LAST_PROP
 };
@@ -73,6 +75,7 @@ enum {
 #define DBUS_PROP_STATE "State"
 #define DBUS_PROP_DEFAULT "Default"
 #define DBUS_PROP_DEFAULT6 "Default6"
+#define DBUS_PROP_MASTER "Master"
 
 /**
  * nm_active_connection_new:
@@ -314,6 +317,32 @@ nm_active_connection_get_default6 (NMActiveConnection *connection)
 	return priv->is_default6;
 }
 
+/**
+ * nm_active_connection_get_master:
+ * @connection: a #NMActiveConnection
+ *
+ * Gets the path to the master #NMDevice of the connection.
+ *
+ * Returns: the path of the master #NMDevice of the #NMActiveConnection.
+ * This is the internal string used by the connection, and must not be modified.
+ **/
+const char *
+nm_active_connection_get_master (NMActiveConnection *connection)
+{
+	NMActiveConnectionPrivate *priv;
+
+	g_return_val_if_fail (NM_IS_ACTIVE_CONNECTION (connection), NULL);
+
+	priv = NM_ACTIVE_CONNECTION_GET_PRIVATE (connection);
+	if (!priv->master) {
+		priv->master = _nm_object_get_string_property (NM_OBJECT (connection),
+		                                               NM_DBUS_INTERFACE_ACTIVE_CONNECTION,
+		                                               DBUS_PROP_MASTER);
+	}
+
+	return priv->master;
+}
+
 static void
 nm_active_connection_init (NMActiveConnection *ap)
 {
@@ -348,6 +377,7 @@ finalize (GObject *object)
 	g_free (priv->service_name);
 	g_free (priv->connection);
 	g_free (priv->specific_object);
+	g_free (priv->master);
 
 	G_OBJECT_CLASS (nm_active_connection_parent_class)->finalize (object);
 }
@@ -382,6 +412,9 @@ get_property (GObject *object,
 	case PROP_DEFAULT6:
 		g_value_set_boolean (value, nm_active_connection_get_default6 (self));
 		break;
+	case PROP_MASTER:
+		g_value_set_string (value, nm_active_connection_get_master (self));
+		break;
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -567,4 +600,17 @@ nm_active_connection_class_init (NMActiveConnectionClass *ap_class)
 							   "Is the default IPv6 active connection",
 							   FALSE,
 							   G_PARAM_READABLE));
+
+	/**
+	 * NMActiveConnection:master:
+	 *
+	 * The path of the master device if one exists.
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_MASTER,
+		 g_param_spec_string (NM_ACTIVE_CONNECTION_MASTER,
+						      "Master",
+						      "Path of the master device",
+						      NULL,
+						      G_PARAM_READABLE));
 }
diff --git a/libnm-glib/nm-active-connection.h b/libnm-glib/nm-active-connection.h
index 30edf04..eed14f9 100644
--- a/libnm-glib/nm-active-connection.h
+++ b/libnm-glib/nm-active-connection.h
@@ -46,6 +46,7 @@ G_BEGIN_DECLS
 #define NM_ACTIVE_CONNECTION_STATE               "state"
 #define NM_ACTIVE_CONNECTION_DEFAULT             "default"
 #define NM_ACTIVE_CONNECTION_DEFAULT6            "default6"
+#define NM_ACTIVE_CONNECTION_MASTER              "master"
 
 typedef struct {
 	NMObject parent;
@@ -75,6 +76,7 @@ const GPtrArray *nm_active_connection_get_devices         (NMActiveConnection *c
 NMActiveConnectionState nm_active_connection_get_state    (NMActiveConnection *connection);
 gboolean nm_active_connection_get_default                 (NMActiveConnection *connection);
 gboolean nm_active_connection_get_default6                (NMActiveConnection *connection);
+const char * nm_active_connection_get_master              (NMActiveConnection *connection);
 
 G_END_DECLS
 
diff --git a/libnm-glib/nm-device-bond.c b/libnm-glib/nm-device-bond.c
index 94a872b..4d6b6eb 100644
--- a/libnm-glib/nm-device-bond.c
+++ b/libnm-glib/nm-device-bond.c
@@ -32,6 +32,8 @@
 #include "nm-device-bond.h"
 #include "nm-device-private.h"
 #include "nm-object-private.h"
+#include "nm-types.h"
+#include "nm-types-private.h"
 
 G_DEFINE_TYPE (NMDeviceBond, nm_device_bond, NM_TYPE_DEVICE)
 
@@ -43,18 +45,21 @@ typedef struct {
 	char *hw_address;
 	gboolean carrier;
 	gboolean carrier_valid;
+	GPtrArray *slaves;
 } NMDeviceBondPrivate;
 
 enum {
 	PROP_0,
 	PROP_HW_ADDRESS,
 	PROP_CARRIER,
+	PROP_SLAVES,
 
 	LAST_PROP
 };
 
 #define DBUS_PROP_HW_ADDRESS "HwAddress"
 #define DBUS_PROP_CARRIER "Carrier"
+#define DBUS_PROP_SLAVES "Slaves"
 
 /**
  * nm_device_bond_new:
@@ -129,6 +134,54 @@ nm_device_bond_get_carrier (NMDeviceBond *device)
 	return priv->carrier;
 }
 
+static gboolean
+demarshal_slaves (NMObject *object, GParamSpec *pspec, GValue *value, gpointer field)
+{
+	DBusGConnection *connection;
+
+	connection = nm_object_get_connection (object);
+	if (!_nm_object_array_demarshal (value, (GPtrArray **) field, connection, nm_device_new))
+		return FALSE;
+
+	_nm_object_queue_notify (object, NM_DEVICE_BOND_SLAVES);
+	return TRUE;
+}
+
+/**
+ * nm_device_bond_get_slaves:
+ * @device: a #NMDeviceBond
+ *
+ * Gets the devices currently slaved to @device.
+ *
+ * Returns: (element-type NMClient.Device): the #GPtrArray containing
+ * #NMDevice<!-- -->s that are slaves of @device. This is the internal
+ * copy used by the device, and must not be modified.
+ **/
+const GPtrArray *
+nm_device_bond_get_slaves (NMDeviceBond *device)
+{
+	NMDeviceBondPrivate *priv;
+	GValue value = { 0, };
+
+	g_return_val_if_fail (NM_IS_DEVICE_BOND (device), FALSE);
+
+	priv = NM_DEVICE_BOND_GET_PRIVATE (device);
+	if (priv->slaves)
+		return handle_ptr_array_return (priv->slaves);
+
+	if (!_nm_object_get_property (NM_OBJECT (device),
+	                              NM_DBUS_INTERFACE_DEVICE_BOND,
+	                              DBUS_PROP_SLAVES,
+	                              &value)) {
+		return NULL;
+	}
+
+	demarshal_slaves (NM_OBJECT (device), NULL, &value, &priv->slaves);
+	g_value_unset (&value);
+
+	return handle_ptr_array_return (priv->slaves);
+}
+
 /***********************************************************/
 
 static void
@@ -143,6 +196,7 @@ register_for_property_changed (NMDeviceBond *device)
 	const NMPropertiesChangedInfo property_changed_info[] = {
 		{ NM_DEVICE_BOND_HW_ADDRESS, _nm_object_demarshal_generic, &priv->hw_address },
 		{ NM_DEVICE_BOND_CARRIER,    _nm_object_demarshal_generic, &priv->carrier },
+		{ NM_DEVICE_BOND_SLAVES,     demarshal_slaves,             &priv->slaves },
 		{ NULL },
 	};
 
@@ -187,6 +241,12 @@ dispose (GObject *object)
 		priv->proxy = NULL;
 	}
 
+	if (priv->slaves) {
+		g_ptr_array_foreach (priv->slaves, (GFunc) g_object_unref, NULL);
+		g_ptr_array_free (priv->slaves, TRUE);
+		priv->slaves = NULL;
+	}
+
 	G_OBJECT_CLASS (nm_device_bond_parent_class)->dispose (object);
 }
 
@@ -215,6 +275,9 @@ get_property (GObject *object,
 	case PROP_CARRIER:
 		g_value_set_boolean (value, nm_device_bond_get_carrier (device));
 		break;
+	case PROP_SLAVES:
+		g_value_set_boxed (value, nm_device_bond_get_slaves (device));
+		break;
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -262,4 +325,16 @@ nm_device_bond_class_init (NMDeviceBondClass *eth_class)
 		                       FALSE,
 		                       G_PARAM_READABLE));
 
+	/**
+	 * NMDeviceBond:slaves:
+	 *
+	 * The devices (#NMDevice) slaved to the bond device.
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_SLAVES,
+		 g_param_spec_boxed (NM_DEVICE_BOND_SLAVES,
+		                     "Slaves",
+		                     "Slaves",
+		                     NM_TYPE_OBJECT_ARRAY,
+		                     G_PARAM_READABLE));
 }
diff --git a/libnm-glib/nm-device-bond.h b/libnm-glib/nm-device-bond.h
index 097a204..7578d86 100644
--- a/libnm-glib/nm-device-bond.h
+++ b/libnm-glib/nm-device-bond.h
@@ -37,6 +37,7 @@ G_BEGIN_DECLS
 
 #define NM_DEVICE_BOND_HW_ADDRESS  "hw-address"
 #define NM_DEVICE_BOND_CARRIER     "carrier"
+#define NM_DEVICE_BOND_SLAVES      "slaves"
 
 typedef struct {
 	NMDevice parent;
@@ -58,8 +59,9 @@ GType nm_device_bond_get_type (void);
 
 GObject *nm_device_bond_new (DBusGConnection *connection, const char *path);
 
-const char * nm_device_bond_get_hw_address (NMDeviceBond *device);
-gboolean     nm_device_bond_get_carrier (NMDeviceBond *device);
+const char      *nm_device_bond_get_hw_address (NMDeviceBond *device);
+gboolean         nm_device_bond_get_carrier    (NMDeviceBond *device);
+const GPtrArray *nm_device_bond_get_slaves     (NMDeviceBond *device);
 
 G_END_DECLS
 
diff --git a/libnm-glib/nm-device-bridge.c b/libnm-glib/nm-device-bridge.c
new file mode 100644
index 0000000..5672c0b
--- /dev/null
+++ b/libnm-glib/nm-device-bridge.c
@@ -0,0 +1,358 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/*
+ * libnm_glib -- Access network status & information from glib applications
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2012 Red Hat, Inc.
+ */
+
+#include <config.h>
+#include <string.h>
+#include <netinet/ether.h>
+
+#include "nm-glib-compat.h"
+
+#include <nm-setting-connection.h>
+#include <nm-setting-bridge.h>
+#include <nm-utils.h>
+
+#include "nm-device-bridge.h"
+#include "nm-device-private.h"
+#include "nm-object-private.h"
+#include "nm-types.h"
+#include "nm-types-private.h"
+
+G_DEFINE_TYPE (NMDeviceBridge, nm_device_bridge, NM_TYPE_DEVICE)
+
+#define NM_DEVICE_BRIDGE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DEVICE_BRIDGE, NMDeviceBridgePrivate))
+
+typedef struct {
+	DBusGProxy *proxy;
+
+	char *hw_address;
+	gboolean carrier;
+	gboolean carrier_valid;
+	GPtrArray *slaves;
+} NMDeviceBridgePrivate;
+
+enum {
+	PROP_0,
+	PROP_HW_ADDRESS,
+	PROP_CARRIER,
+	PROP_SLAVES,
+
+	LAST_PROP
+};
+
+#define DBUS_PROP_HW_ADDRESS "HwAddress"
+#define DBUS_PROP_CARRIER "Carrier"
+#define DBUS_PROP_SLAVES "Slaves"
+
+/**
+ * nm_device_bridge_error_quark:
+ *
+ * Registers an error quark for #NMDeviceBridge if necessary.
+ *
+ * Returns: the error quark used for #NMDeviceBridge errors.
+ **/
+GQuark
+nm_device_bridge_error_quark (void)
+{
+	static GQuark quark = 0;
+
+	if (G_UNLIKELY (quark == 0))
+		quark = g_quark_from_static_string ("nm-device-bridge-error-quark");
+	return quark;
+}
+
+/**
+ * nm_device_bridge_new:
+ * @connection: the #DBusGConnection
+ * @path: the DBus object path of the device
+ *
+ * Creates a new #NMDeviceBridge.
+ *
+ * Returns: a new device
+ **/
+GObject *
+nm_device_bridge_new (DBusGConnection *connection, const char *path)
+{
+	g_return_val_if_fail (connection != NULL, NULL);
+	g_return_val_if_fail (path != NULL, NULL);
+
+	return g_object_new (NM_TYPE_DEVICE_BRIDGE,
+	                     NM_OBJECT_DBUS_CONNECTION, connection,
+	                     NM_OBJECT_DBUS_PATH, path,
+	                     NULL);
+}
+
+/**
+ * nm_device_bridge_get_hw_address:
+ * @device: a #NMDeviceBridge
+ *
+ * Gets the hardware (MAC) address of the #NMDeviceBridge
+ *
+ * Returns: the hardware address. This is the internal string used by the
+ * device, and must not be modified.
+ **/
+const char *
+nm_device_bridge_get_hw_address (NMDeviceBridge *device)
+{
+	NMDeviceBridgePrivate *priv;
+
+	g_return_val_if_fail (NM_IS_DEVICE_BRIDGE (device), NULL);
+
+	priv = NM_DEVICE_BRIDGE_GET_PRIVATE (device);
+	if (!priv->hw_address) {
+		priv->hw_address = _nm_object_get_string_property (NM_OBJECT (device),
+		                                                   NM_DBUS_INTERFACE_DEVICE_BRIDGE,
+		                                                   DBUS_PROP_HW_ADDRESS);
+	}
+
+	return priv->hw_address;
+}
+
+/**
+ * nm_device_bridge_get_carrier:
+ * @device: a #NMDeviceBridge
+ *
+ * Whether the device has carrier.
+ *
+ * Returns: %TRUE if the device has carrier
+ **/
+gboolean
+nm_device_bridge_get_carrier (NMDeviceBridge *device)
+{
+	NMDeviceBridgePrivate *priv;
+
+	g_return_val_if_fail (NM_IS_DEVICE_BRIDGE (device), FALSE);
+
+	priv = NM_DEVICE_BRIDGE_GET_PRIVATE (device);
+	if (!priv->carrier_valid) {
+		priv->carrier = _nm_object_get_boolean_property (NM_OBJECT (device),
+		                                                 NM_DBUS_INTERFACE_DEVICE_BRIDGE,
+		                                                 DBUS_PROP_CARRIER);
+		priv->carrier_valid = TRUE;
+	}
+
+	return priv->carrier;
+}
+
+static gboolean
+demarshal_slaves (NMObject *object, GParamSpec *pspec, GValue *value, gpointer field)
+{
+	DBusGConnection *connection;
+
+	connection = nm_object_get_connection (object);
+	if (!_nm_object_array_demarshal (value, (GPtrArray **) field, connection, nm_device_new))
+		return FALSE;
+
+	_nm_object_queue_notify (object, NM_DEVICE_BRIDGE_SLAVES);
+	return TRUE;
+}
+
+/**
+ * nm_device_bridge_get_slaves:
+ * @device: a #NMDeviceBridge
+ *
+ * Gets the devices currently slaved to @device.
+ *
+ * Returns: (element-type NMClient.Device): the #GPtrArray containing
+ * #NMDevice<!-- -->s that are slaves of @device. This is the internal
+ * copy used by the device, and must not be modified.
+ **/
+const GPtrArray *
+nm_device_bridge_get_slaves (NMDeviceBridge *device)
+{
+	NMDeviceBridgePrivate *priv;
+	GValue value = { 0, };
+
+	g_return_val_if_fail (NM_IS_DEVICE_BRIDGE (device), FALSE);
+
+	priv = NM_DEVICE_BRIDGE_GET_PRIVATE (device);
+	if (priv->slaves)
+		return handle_ptr_array_return (priv->slaves);
+
+	if (!_nm_object_get_property (NM_OBJECT (device),
+	                             NM_DBUS_INTERFACE_DEVICE_BRIDGE,
+	                             DBUS_PROP_SLAVES,
+	                             &value)) {
+		return NULL;
+	}
+
+	demarshal_slaves (NM_OBJECT (device), NULL, &value, &priv->slaves);
+	g_value_unset (&value);
+
+	return handle_ptr_array_return (priv->slaves);
+}
+
+/***********************************************************/
+
+static void
+nm_device_bridge_init (NMDeviceBridge *device)
+{
+}
+
+static void
+register_for_property_changed (NMDeviceBridge *device)
+{
+	NMDeviceBridgePrivate *priv = NM_DEVICE_BRIDGE_GET_PRIVATE (device);
+	const NMPropertiesChangedInfo property_changed_info[] = {
+		{ NM_DEVICE_BRIDGE_HW_ADDRESS, _nm_object_demarshal_generic, &priv->hw_address },
+		{ NM_DEVICE_BRIDGE_CARRIER,    _nm_object_demarshal_generic, &priv->carrier },
+		{ NM_DEVICE_BRIDGE_SLAVES,     demarshal_slaves,             &priv->slaves },
+		{ NULL },
+	};
+
+	_nm_object_handle_properties_changed (NM_OBJECT (device),
+	                                      priv->proxy,
+	                                      property_changed_info);
+}
+
+static GObject*
+constructor (GType type,
+             guint n_construct_params,
+             GObjectConstructParam *construct_params)
+{
+	GObject *object;
+	NMDeviceBridgePrivate *priv;
+
+	object = G_OBJECT_CLASS (nm_device_bridge_parent_class)->constructor (type,
+	                                                                      n_construct_params,
+	                                                                      construct_params);
+	if (!object)
+		return NULL;
+
+	priv = NM_DEVICE_BRIDGE_GET_PRIVATE (object);
+
+	priv->proxy = dbus_g_proxy_new_for_name (nm_object_get_connection (NM_OBJECT (object)),
+	                                         NM_DBUS_SERVICE,
+	                                         nm_object_get_path (NM_OBJECT (object)),
+	                                         NM_DBUS_INTERFACE_DEVICE_BRIDGE);
+
+	register_for_property_changed (NM_DEVICE_BRIDGE (object));
+
+	return object;
+}
+
+static void
+dispose (GObject *object)
+{
+	NMDeviceBridgePrivate *priv = NM_DEVICE_BRIDGE_GET_PRIVATE (object);
+
+	if (priv->proxy) {
+		g_object_unref (priv->proxy);
+		priv->proxy = NULL;
+	}
+
+	if (priv->slaves) {
+		g_ptr_array_foreach (priv->slaves, (GFunc) g_object_unref, NULL);
+		g_ptr_array_free (priv->slaves, TRUE);
+		priv->slaves = NULL;
+	}
+
+	G_OBJECT_CLASS (nm_device_bridge_parent_class)->dispose (object);
+}
+
+static void
+finalize (GObject *object)
+{
+	NMDeviceBridgePrivate *priv = NM_DEVICE_BRIDGE_GET_PRIVATE (object);
+
+	g_free (priv->hw_address);
+
+	G_OBJECT_CLASS (nm_device_bridge_parent_class)->finalize (object);
+}
+
+static void
+get_property (GObject *object,
+              guint prop_id,
+              GValue *value,
+              GParamSpec *pspec)
+{
+	NMDeviceBridge *device = NM_DEVICE_BRIDGE (object);
+
+	switch (prop_id) {
+	case PROP_HW_ADDRESS:
+		g_value_set_string (value, nm_device_bridge_get_hw_address (device));
+		break;
+	case PROP_CARRIER:
+		g_value_set_boolean (value, nm_device_bridge_get_carrier (device));
+		break;
+	case PROP_SLAVES:
+		g_value_set_boxed (value, nm_device_bridge_get_slaves (device));
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+nm_device_bridge_class_init (NMDeviceBridgeClass *eth_class)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (eth_class);
+
+	g_type_class_add_private (eth_class, sizeof (NMDeviceBridgePrivate));
+
+	/* virtual methods */
+	object_class->constructor = constructor;
+	object_class->dispose = dispose;
+	object_class->finalize = finalize;
+	object_class->get_property = get_property;
+
+	/* properties */
+
+	/**
+	 * NMDeviceBridge:hw-address:
+	 *
+	 * The hardware (MAC) address of the device.
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_HW_ADDRESS,
+		 g_param_spec_string (NM_DEVICE_BRIDGE_HW_ADDRESS,
+		                      "Active MAC Address",
+		                      "Currently set hardware MAC address",
+		                      NULL,
+		                      G_PARAM_READABLE));
+
+	/**
+	 * NMDeviceBridge:carrier:
+	 *
+	 * Whether the device has carrier.
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_CARRIER,
+		 g_param_spec_boolean (NM_DEVICE_BRIDGE_CARRIER,
+		                       "Carrier",
+		                       "Carrier",
+		                       FALSE,
+		                       G_PARAM_READABLE));
+
+	/**
+	 * NMDeviceBridge:slaves:
+	 *
+	 * The devices (#NMDevice) slaved to the bridge device.
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_SLAVES,
+		 g_param_spec_boxed (NM_DEVICE_BRIDGE_SLAVES,
+		                     "Slaves",
+		                     "Slaves",
+		                     NM_TYPE_OBJECT_ARRAY,
+		                     G_PARAM_READABLE));
+}
diff --git a/libnm-glib/nm-device-bridge.h b/libnm-glib/nm-device-bridge.h
new file mode 100644
index 0000000..e8311da
--- /dev/null
+++ b/libnm-glib/nm-device-bridge.h
@@ -0,0 +1,84 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/*
+ * libnm_glib -- Access network status & information from glib applications
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * Copyright (C) 2012 Red Hat, Inc.
+ */
+
+#ifndef NM_DEVICE_BRIDGE_H
+#define NM_DEVICE_BRIDGE_H
+
+#include "nm-device.h"
+
+G_BEGIN_DECLS
+
+#define NM_TYPE_DEVICE_BRIDGE            (nm_device_bridge_get_type ())
+#define NM_DEVICE_BRIDGE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DEVICE_BRIDGE, NMDeviceBridge))
+#define NM_DEVICE_BRIDGE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_DEVICE_BRIDGE, NMDeviceBridgeClass))
+#define NM_IS_DEVICE_BRIDGE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_DEVICE_BRIDGE))
+#define NM_IS_DEVICE_BRIDGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_DEVICE_BRIDGE))
+#define NM_DEVICE_BRIDGE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_DEVICE_BRIDGE, NMDeviceBridgeClass))
+
+/**
+ * NMDeviceBridgeError:
+ * @NM_DEVICE_BRIDGE_ERROR_UNKNOWN: unknown or unclassified error
+ * @NM_DEVICE_BRIDGE_ERROR_NOT_BRIDGE_CONNECTION: the connection was not of bridge type
+ * @NM_DEVICE_BRIDGE_ERROR_INVALID_BRIDGE_CONNECTION: the bridge connection was invalid
+ * @NM_DEVICE_BRIDGE_ERROR_INTERFACE_MISMATCH: the interfaces of the connection and the device mismatched
+ */
+typedef enum {
+	NM_DEVICE_BRIDGE_ERROR_UNKNOWN = 0,               /*< nick=UnknownError >*/
+	NM_DEVICE_BRIDGE_ERROR_NOT_BRIDGE_CONNECTION,     /*< nick=NotBridgeConnection >*/
+	NM_DEVICE_BRIDGE_ERROR_INVALID_BRIDGE_CONNECTION, /*< nick=InvalidBridgeConnection >*/
+	NM_DEVICE_BRIDGE_ERROR_INTERFACE_MISMATCH,        /*< nick=InterfaceMismatch >*/
+} NMDeviceBridgeError;
+
+#define NM_DEVICE_BRIDGE_ERROR nm_device_bridge_error_quark ()
+GQuark nm_device_bridge_error_quark (void);
+
+#define NM_DEVICE_BRIDGE_HW_ADDRESS  "hw-address"
+#define NM_DEVICE_BRIDGE_CARRIER     "carrier"
+#define NM_DEVICE_BRIDGE_SLAVES      "slaves"
+
+typedef struct {
+	NMDevice parent;
+} NMDeviceBridge;
+
+typedef struct {
+	NMDeviceClass parent;
+
+	/* Padding for future expansion */
+	void (*_reserved1) (void);
+	void (*_reserved2) (void);
+	void (*_reserved3) (void);
+	void (*_reserved4) (void);
+	void (*_reserved5) (void);
+	void (*_reserved6) (void);
+} NMDeviceBridgeClass;
+
+GType        nm_device_bridge_get_type (void);
+
+GObject *    nm_device_bridge_new (DBusGConnection *connection, const char *path);
+
+const char      *nm_device_bridge_get_hw_address (NMDeviceBridge *device);
+gboolean         nm_device_bridge_get_carrier    (NMDeviceBridge *device);
+const GPtrArray *nm_device_bridge_get_slaves     (NMDeviceBridge *device);
+
+G_END_DECLS
+
+#endif /* NM_DEVICE_BRIDGE_H */
diff --git a/libnm-glib/nm-device.c b/libnm-glib/nm-device.c
index 585f331..c14af90 100644
--- a/libnm-glib/nm-device.c
+++ b/libnm-glib/nm-device.c
@@ -34,6 +34,7 @@
 #include "nm-device-bt.h"
 #include "nm-device-infiniband.h"
 #include "nm-device-bond.h"
+#include "nm-device-bridge.h"
 #include "nm-device-vlan.h"
 #include "nm-device.h"
 #include "nm-device-private.h"
@@ -718,6 +719,9 @@ nm_device_new (DBusGConnection *connection, const char *path)
 	case NM_DEVICE_TYPE_BOND:
 		dtype = NM_TYPE_DEVICE_BOND;
 		break;
+	case NM_DEVICE_TYPE_BRIDGE:
+		dtype = NM_TYPE_DEVICE_BRIDGE;
+		break;
 	case NM_DEVICE_TYPE_VLAN:
 		dtype = NM_TYPE_DEVICE_VLAN;
 		break;
diff --git a/libnm-util/Makefile.am b/libnm-util/Makefile.am
index d91b063..8b8e0ea 100644
--- a/libnm-util/Makefile.am
+++ b/libnm-util/Makefile.am
@@ -16,6 +16,8 @@ libnm_util_include_HEADERS = 		\
 	nm-setting-8021x.h		\
 	nm-setting-bluetooth.h		\
 	nm-setting-bond.h		\
+	nm-setting-bridge.h		\
+	nm-setting-bridge-port.h	\
 	nm-setting-connection.h		\
 	nm-setting-infiniband.h		\
 	nm-setting-ip4-config.h		\
@@ -43,6 +45,8 @@ libnm_util_la_SOURCES=			\
 	nm-setting-8021x.c		\
 	nm-setting-bluetooth.c		\
 	nm-setting-bond.c		\
+	nm-setting-bridge.c		\
+	nm-setting-bridge-port.c	\
 	nm-setting-connection.c		\
 	nm-setting-infiniband.c		\
 	nm-setting-ip4-config.c		\
@@ -65,7 +69,7 @@ libnm_util_la_SOURCES=			\
 libnm_util_la_LIBADD = $(GLIB_LIBS) $(DBUS_LIBS) $(UUID_LIBS)
 
 libnm_util_la_LDFLAGS = -Wl,--version-script=$(srcdir)/libnm-util.ver \
-	-version-info "8:0:7"
+	-version-info "9:0:8"
 
 if WITH_GNUTLS
 libnm_util_la_SOURCES += crypto_gnutls.c
diff --git a/libnm-util/libnm-util.ver b/libnm-util/libnm-util.ver
index bdcbb6b..cd5b125 100644
--- a/libnm-util/libnm-util.ver
+++ b/libnm-util/libnm-util.ver
@@ -16,6 +16,8 @@ global:
 	nm_connection_is_type;
 	nm_connection_get_scope;
 	nm_connection_get_setting;
+	nm_connection_get_setting_bridge;
+	nm_connection_get_setting_bridge_port;
 	nm_connection_get_setting_by_name;
 	nm_connection_get_setting_connection;
 	nm_connection_get_setting_ip4_config;
@@ -118,6 +120,24 @@ global:
 	nm_setting_bond_get_valid_options;
 	nm_setting_bond_add_option;
 	nm_setting_bond_remove_option;
+	nm_setting_bridge_error_get_type;
+	nm_setting_bridge_error_quark;
+	nm_setting_bridge_get_ageing_time;
+	nm_setting_bridge_get_forward_delay;
+	nm_setting_bridge_get_hello_time;
+	nm_setting_bridge_get_interface_name;
+	nm_setting_bridge_get_max_age;
+	nm_setting_bridge_get_priority;
+	nm_setting_bridge_get_stp;
+	nm_setting_bridge_get_type;
+	nm_setting_bridge_new;
+	nm_setting_bridge_port_error_get_type;
+	nm_setting_bridge_port_error_quark;
+	nm_setting_bridge_port_get_hairpin_mode;
+	nm_setting_bridge_port_get_path_cost;
+	nm_setting_bridge_port_get_priority;
+	nm_setting_bridge_port_get_type;
+	nm_setting_bridge_port_new;
 	nm_setting_cdma_error_get_type;
 	nm_setting_cdma_error_quark;
 	nm_setting_cdma_get_type;
diff --git a/libnm-util/nm-connection.c b/libnm-util/nm-connection.c
index e8943f3..7133aab 100644
--- a/libnm-util/nm-connection.c
+++ b/libnm-util/nm-connection.c
@@ -33,6 +33,8 @@
 #include "nm-setting-8021x.h"
 #include "nm-setting-bluetooth.h"
 #include "nm-setting-bond.h"
+#include "nm-setting-bridge.h"
+#include "nm-setting-bridge-port.h"
 #include "nm-setting-connection.h"
 #include "nm-setting-infiniband.h"
 #include "nm-setting-ip4-config.h"
@@ -144,7 +146,7 @@ static guint signals[LAST_SIGNAL] = { 0 };
 
 static GHashTable *registered_settings = NULL;
 
-#define DEFAULT_MAP_SIZE 18
+#define DEFAULT_MAP_SIZE 20
 
 static struct SettingInfo {
 	const char *name;
@@ -240,6 +242,11 @@ register_default_settings (void)
 			      NM_SETTING_BLUETOOTH_ERROR,
 			      1);
 
+	register_one_setting (NM_SETTING_BRIDGE_SETTING_NAME,
+	                      NM_TYPE_SETTING_BRIDGE,
+	                      NM_SETTING_BRIDGE_ERROR,
+	                      1);
+
 	register_one_setting (NM_SETTING_INFINIBAND_SETTING_NAME,
 	                      NM_TYPE_SETTING_INFINIBAND,
 	                      NM_SETTING_INFINIBAND_ERROR,
@@ -265,6 +272,11 @@ register_default_settings (void)
 	                      NM_SETTING_SERIAL_ERROR,
 	                      2);
 
+	register_one_setting (NM_SETTING_BRIDGE_PORT_SETTING_NAME,
+	                      NM_TYPE_SETTING_BRIDGE_PORT,
+	                      NM_SETTING_BRIDGE_PORT_ERROR,
+	                      3);
+
 	register_one_setting (NM_SETTING_PPP_SETTING_NAME,
 	                      NM_TYPE_SETTING_PPP,
 	                      NM_SETTING_PPP_ERROR,
@@ -563,6 +575,40 @@ nm_connection_get_setting_bond (NMConnection *connection)
 }
 
 /**
+ * nm_connection_get_setting_bridge:
+ * @connection: the #NMConnection
+ *
+ * A shortcut to return any #NMSettingBridge the connection might contain.
+ *
+ * Returns: (transfer none): an #NMSettingBridge if the connection contains one, otherwise NULL
+ **/
+NMSettingBridge *
+nm_connection_get_setting_bridge (NMConnection *connection)
+{
+	g_return_val_if_fail (connection != NULL, NULL);
+	g_return_val_if_fail (NM_IS_CONNECTION (connection), NULL);
+
+	return (NMSettingBridge *) nm_connection_get_setting (connection, NM_TYPE_SETTING_BRIDGE);
+}
+
+/**
+ * nm_connection_get_setting_bridge_port:
+ * @connection: the #NMConnection
+ *
+ * A shortcut to return any #NMSettingBridgePort the connection might contain.
+ *
+ * Returns: (transfer none): an #NMSettingBridgePort if the connection contains one, otherwise NULL
+ **/
+NMSettingBridgePort *
+nm_connection_get_setting_bridge_port (NMConnection *connection)
+{
+	g_return_val_if_fail (connection != NULL, NULL);
+	g_return_val_if_fail (NM_IS_CONNECTION (connection), NULL);
+
+	return (NMSettingBridgePort *) nm_connection_get_setting (connection, NM_TYPE_SETTING_BRIDGE_PORT);
+}
+
+/**
  * nm_connection_get_setting_vlan:
  * @connection: the #NMConnection
  *
diff --git a/libnm-util/nm-connection.h b/libnm-util/nm-connection.h
index f977876..f157305 100644
--- a/libnm-util/nm-connection.h
+++ b/libnm-util/nm-connection.h
@@ -33,6 +33,8 @@
 #include <nm-setting-connection.h>
 #include <nm-setting-ip4-config.h>
 #include <nm-setting-bond.h>
+#include <nm-setting-bridge.h>
+#include <nm-setting-bridge-port.h>
 #include <nm-setting-wired.h>
 #include <nm-setting-vlan.h>
 
@@ -179,6 +181,8 @@ const char *  nm_connection_get_id        (NMConnection *connection);
 NMSettingConnection *      nm_connection_get_setting_connection        (NMConnection *connection);
 NMSettingIP4Config *       nm_connection_get_setting_ip4_config        (NMConnection *connection);
 NMSettingBond *            nm_connection_get_setting_bond              (NMConnection *connection);
+NMSettingBridge *          nm_connection_get_setting_bridge            (NMConnection *connection);
+NMSettingBridgePort *      nm_connection_get_setting_bridge_port       (NMConnection *connection);
 NMSettingWired *           nm_connection_get_setting_wired             (NMConnection *connection);
 NMSettingVlan *            nm_connection_get_setting_vlan              (NMConnection *connection);
 
diff --git a/libnm-util/nm-setting-bridge-port.c b/libnm-util/nm-setting-bridge-port.c
new file mode 100644
index 0000000..9c593d0
--- /dev/null
+++ b/libnm-util/nm-setting-bridge-port.c
@@ -0,0 +1,298 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+
+/*
+ * Dan Williams <dcbw@redhat.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2012 Red Hat, Inc.
+ */
+
+#include <string.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <dbus/dbus-glib.h>
+
+#include "nm-setting-bridge-port.h"
+#include "nm-utils.h"
+#include "nm-utils-private.h"
+
+/**
+ * SECTION:nm-setting-bridge-port
+ * @short_description: Describes connection properties for bridge ports
+ * @include: nm-setting-bridge-port.h
+ *
+ * The #NMSettingBridgePort object is a #NMSetting subclass that describes
+ * optional properties that apply to bridge ports.
+ **/
+
+/**
+ * nm_setting_bridge_port_error_quark:
+ *
+ * Registers an error quark for #NMSettingBridgePort if necessary.
+ *
+ * Returns: the error quark used for #NMSettingBridgePort errors.
+ **/
+GQuark
+nm_setting_bridge_port_error_quark (void)
+{
+	static GQuark quark;
+
+	if (G_UNLIKELY (!quark))
+		quark = g_quark_from_static_string ("nm-setting-bridge-port-error-quark");
+	return quark;
+}
+
+/* This should really be standard. */
+#define ENUM_ENTRY(NAME, DESC) { NAME, "" #NAME "", DESC }
+
+GType
+nm_setting_bridge_port_error_get_type (void)
+{
+	static GType etype = 0;
+
+	if (etype == 0) {
+		static const GEnumValue values[] = {
+			/* Unknown error. */
+			ENUM_ENTRY (NM_SETTING_BRIDGE_PORT_ERROR_UNKNOWN, "UnknownError"),
+			/* The specified property was invalid. */
+			ENUM_ENTRY (NM_SETTING_BRIDGE_PORT_ERROR_INVALID_PROPERTY, "InvalidProperty"),
+			/* The specified property was missing and is required. */
+			ENUM_ENTRY (NM_SETTING_BRIDGE_PORT_ERROR_MISSING_PROPERTY, "MissingProperty"),
+			{ 0, 0, 0 }
+		};
+		etype = g_enum_register_static ("NMSettingBridgePortError", values);
+	}
+	return etype;
+}
+
+G_DEFINE_TYPE (NMSettingBridgePort, nm_setting_bridge_port, NM_TYPE_SETTING)
+
+#define NM_SETTING_BRIDGE_PORT_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_SETTING_BRIDGE_PORT, NMSettingBridgePortPrivate))
+
+typedef struct {
+	guint16 priority;
+	guint16 path_cost;
+	gboolean hairpin_mode;
+} NMSettingBridgePortPrivate;
+
+enum {
+	PROP_0,
+	PROP_PRIORITY,
+	PROP_PATH_COST,
+	PROP_HAIRPIN_MODE,
+	LAST_PROP
+};
+
+/**************************************************************************/
+
+/**
+ * nm_setting_bridge_port_get_priority:
+ * @setting: the #NMSettingBridgePort
+ *
+ * Returns: the #NMSettingBridgePort:priority property of the setting
+ **/
+guint16
+nm_setting_bridge_port_get_priority (NMSettingBridgePort *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_BRIDGE_PORT (setting), 0);
+
+	return NM_SETTING_BRIDGE_PORT_GET_PRIVATE (setting)->priority;
+}
+
+/**
+ * nm_setting_bridge_port_get_path_cost:
+ * @setting: the #NMSettingBridgePort
+ *
+ * Returns: the #NMSettingBridgePort:path-cost property of the setting
+ **/
+guint16
+nm_setting_bridge_port_get_path_cost (NMSettingBridgePort *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_BRIDGE_PORT (setting), 0);
+
+	return NM_SETTING_BRIDGE_PORT_GET_PRIVATE (setting)->path_cost;
+}
+
+/**
+ * nm_setting_bridge_port_get_hairpin_mode:
+ * @setting: the #NMSettingBridgePort
+ *
+ * Returns: the #NMSettingBridgePort:hairpin-mode property of the setting
+ **/
+gboolean
+nm_setting_bridge_port_get_hairpin_mode (NMSettingBridgePort *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_BRIDGE_PORT (setting), FALSE);
+
+	return NM_SETTING_BRIDGE_PORT_GET_PRIVATE (setting)->hairpin_mode;
+}
+
+/**************************************************************************/
+
+#define BR_MAX_PORT_PRIORITY 63
+#define BR_DEF_PRIORITY      32
+
+#define BR_MIN_PATH_COST     1
+#define BR_MAX_PATH_COST     65535
+
+static gboolean
+verify (NMSetting *setting, GSList *all_settings, GError **error)
+{
+	NMSettingBridgePortPrivate *priv = NM_SETTING_BRIDGE_PORT_GET_PRIVATE (setting);
+
+	if (priv->priority > BR_MAX_PORT_PRIORITY) {
+		g_set_error (error,
+		             NM_SETTING_BRIDGE_PORT_ERROR,
+		             NM_SETTING_BRIDGE_PORT_ERROR_INVALID_PROPERTY,
+		             NM_SETTING_BRIDGE_PORT_PRIORITY);
+		return FALSE;
+	}
+
+	if (priv->path_cost > BR_MAX_PATH_COST) {
+		g_set_error (error,
+		             NM_SETTING_BRIDGE_PORT_ERROR,
+		             NM_SETTING_BRIDGE_PORT_ERROR_INVALID_PROPERTY,
+		             NM_SETTING_BRIDGE_PORT_PATH_COST);
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+/**************************************************************************/
+
+/**
+ * nm_setting_bridge_port_new:
+ *
+ * Creates a new #NMSettingBridgePort object with default values.
+ *
+ * Returns: (transfer full): the new empty #NMSettingBridgePort object
+ **/
+NMSetting *
+nm_setting_bridge_port_new (void)
+{
+	return (NMSetting *) g_object_new (NM_TYPE_SETTING_BRIDGE_PORT, NULL);
+}
+
+static void
+nm_setting_bridge_port_init (NMSettingBridgePort *setting)
+{
+	g_object_set (setting, NM_SETTING_NAME, NM_SETTING_BRIDGE_PORT_SETTING_NAME, NULL);
+}
+
+static void
+set_property (GObject *object, guint prop_id,
+              const GValue *value, GParamSpec *pspec)
+{
+	NMSettingBridgePortPrivate *priv = NM_SETTING_BRIDGE_PORT_GET_PRIVATE (object);
+
+	switch (prop_id) {
+	case PROP_PRIORITY:
+		priv->priority = (guint16) (g_value_get_uint (value) & 0xFFFF);
+		break;
+	case PROP_PATH_COST:
+		priv->path_cost = (guint16) (g_value_get_uint (value) & 0xFFFF);
+		break;
+	case PROP_HAIRPIN_MODE:
+		priv->hairpin_mode = g_value_get_boolean (value);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+get_property (GObject *object, guint prop_id,
+              GValue *value, GParamSpec *pspec)
+{
+	NMSettingBridgePortPrivate *priv = NM_SETTING_BRIDGE_PORT_GET_PRIVATE (object);
+
+	switch (prop_id) {
+	case PROP_PRIORITY:
+		g_value_set_uint (value, priv->priority);
+		break;
+	case PROP_PATH_COST:
+		g_value_set_uint (value, priv->path_cost);
+		break;
+	case PROP_HAIRPIN_MODE:
+		g_value_set_boolean (value, priv->hairpin_mode);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+nm_setting_bridge_port_class_init (NMSettingBridgePortClass *setting_class)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (setting_class);
+	NMSettingClass *parent_class = NM_SETTING_CLASS (setting_class);
+
+	g_type_class_add_private (setting_class, sizeof (NMSettingBridgePortPrivate));
+
+	/* virtual methods */
+	object_class->set_property = set_property;
+	object_class->get_property = get_property;
+	parent_class->verify       = verify;
+
+	/* Properties */
+	/**
+	 * NMSettingBridgePort:priority:
+	 *
+	 * The Spanning Tree Protocol (STP) priority of this bridge port.
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_PRIORITY,
+		 g_param_spec_uint (NM_SETTING_BRIDGE_PORT_PRIORITY,
+		                    "Priority",
+		                    "The Spanning Tree Protocol (STP) priority of this bridge port",
+		                    0, BR_MAX_PORT_PRIORITY, BR_DEF_PRIORITY,
+		                    G_PARAM_READWRITE | G_PARAM_CONSTRUCT | NM_SETTING_PARAM_SERIALIZE));
+
+	/**
+	 * NMSettingBridgePort:path-cost:
+	 *
+	 * The Spanning Tree Protocol (STP) port cost for destinations via this port.
+	 **/
+	 g_object_class_install_property
+		 (object_class, PROP_PATH_COST,
+		 g_param_spec_uint (NM_SETTING_BRIDGE_PORT_PATH_COST,
+		                    "Path Cost",
+		                    "The Spanning Tree Protocol (STP) port cost for "
+		                    "destinations via this port.",
+		                    0, BR_MAX_PATH_COST, 100,
+		                    G_PARAM_READWRITE | G_PARAM_CONSTRUCT | NM_SETTING_PARAM_SERIALIZE));
+
+	/**
+	 * NMSettingBridgePort:hairpin-mode:
+	 *
+	 * Enables or disabled 'hairpin mode' for the port, which allows frames to
+	 * be sent back out through the port the frame was received on.
+	 **/
+	 g_object_class_install_property
+		 (object_class, PROP_HAIRPIN_MODE,
+		 g_param_spec_boolean (NM_SETTING_BRIDGE_PORT_HAIRPIN_MODE,
+		                       "Hairpin Mode",
+		                       "Enables or disabled 'hairpin mode' for the "
+		                       "port, which allows frames to be sent back out "
+		                       "through the port the frame was received on.",
+		                       FALSE,
+		                       G_PARAM_READWRITE | NM_SETTING_PARAM_SERIALIZE));
+
+}
diff --git a/libnm-util/nm-setting-bridge-port.h b/libnm-util/nm-setting-bridge-port.h
new file mode 100644
index 0000000..5559e38
--- /dev/null
+++ b/libnm-util/nm-setting-bridge-port.h
@@ -0,0 +1,89 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+
+/*
+ * Dan Williams <dcbw@redhat.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2012 Red Hat, Inc.
+ */
+
+#ifndef NM_SETTING_BRIDGE_PORT_H
+#define NM_SETTING_BRIDGE_PORT_H
+
+#include <nm-setting.h>
+
+G_BEGIN_DECLS
+
+#define NM_TYPE_SETTING_BRIDGE_PORT            (nm_setting_bridge_port_get_type ())
+#define NM_SETTING_BRIDGE_PORT(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_SETTING_BRIDGE_PORT, NMSettingBridgePort))
+#define NM_SETTING_BRIDGE_PORT_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_SETTING_BRIDGE_PORT, NMSettingBridgePortClass))
+#define NM_IS_SETTING_BRIDGE_PORT(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_SETTING_BRIDGE_PORT))
+#define NM_IS_SETTING_BRIDGE_PORT_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), NM_TYPE_SETTING_BRIDGE_PORT))
+#define NM_SETTING_BRIDGE_PORT_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_SETTING_BRIDGE_PORT, NMSettingBridgePortClass))
+
+#define NM_SETTING_BRIDGE_PORT_SETTING_NAME "bridge-port"
+
+/**
+ * NMSettingBridgePortError:
+ * @NM_SETTING_BRIDGE_PORT_ERROR_UNKNOWN: unknown or unclassified error
+ * @NM_SETTING_BRIDGE_PORT_ERROR_INVALID_PROPERTY: the property was invalid
+ * @NM_SETTING_BRIDGE_PORT_ERROR_MISSING_PROPERTY: the property was missing and
+ * is required
+ */
+typedef enum {
+	NM_SETTING_BRIDGE_PORT_ERROR_UNKNOWN = 0,      /*< nick=UnknownError >*/
+	NM_SETTING_BRIDGE_PORT_ERROR_INVALID_PROPERTY, /*< nick=InvalidProperty >*/
+	NM_SETTING_BRIDGE_PORT_ERROR_MISSING_PROPERTY, /*< nick=MissingProperty >*/
+} NMSettingBridgePortError;
+
+#define NM_TYPE_SETTING_BRIDGE_PORT_ERROR (nm_setting_bridge_port_error_get_type ()) 
+GType nm_setting_bridge_port_error_get_type (void);
+
+#define NM_SETTING_BRIDGE_PORT_ERROR nm_setting_bridge_port_error_quark ()
+GQuark nm_setting_bridge_port_error_quark (void);
+
+#define NM_SETTING_BRIDGE_PORT_PRIORITY     "priority"
+#define NM_SETTING_BRIDGE_PORT_PATH_COST    "path-cost"
+#define NM_SETTING_BRIDGE_PORT_HAIRPIN_MODE "hairpin-mode"
+
+typedef struct {
+	NMSetting parent;
+} NMSettingBridgePort;
+
+typedef struct {
+	NMSettingClass parent;
+
+	/* Padding for future expansion */
+	void (*_reserved1) (void);
+	void (*_reserved2) (void);
+	void (*_reserved3) (void);
+	void (*_reserved4) (void);
+} NMSettingBridgePortClass;
+
+GType nm_setting_bridge_port_get_type (void);
+
+NMSetting * nm_setting_bridge_port_new              (void);
+
+guint16     nm_setting_bridge_port_get_priority     (NMSettingBridgePort *setting);
+
+guint16     nm_setting_bridge_port_get_path_cost    (NMSettingBridgePort *setting);
+
+gboolean    nm_setting_bridge_port_get_hairpin_mode (NMSettingBridgePort *setting);
+
+G_END_DECLS
+
+#endif /* NM_SETTING_BRIDGE_PORT_H */
diff --git a/libnm-util/nm-setting-bridge.c b/libnm-util/nm-setting-bridge.c
new file mode 100644
index 0000000..4e0fd65
--- /dev/null
+++ b/libnm-util/nm-setting-bridge.c
@@ -0,0 +1,515 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+
+/*
+ * Thomas Graf <tgraf@redhat.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2011 - 2012 Red Hat, Inc.
+ */
+
+#include <string.h>
+#include <ctype.h>
+#include <stdlib.h>
+#include <dbus/dbus-glib.h>
+
+#include "nm-setting-bridge.h"
+#include "nm-param-spec-specialized.h"
+#include "nm-utils.h"
+#include "nm-utils-private.h"
+#include "nm-dbus-glib-types.h"
+
+/**
+ * SECTION:nm-setting-bridge
+ * @short_description: Describes connection properties for bridges
+ * @include: nm-setting-bridge.h
+ *
+ * The #NMSettingBridge object is a #NMSetting subclass that describes properties
+ * necessary for bridging connections.
+ **/
+
+/**
+ * nm_setting_bridge_error_quark:
+ *
+ * Registers an error quark for #NMSettingBridge if necessary.
+ *
+ * Returns: the error quark used for #NMSettingBridge errors.
+ **/
+GQuark
+nm_setting_bridge_error_quark (void)
+{
+	static GQuark quark;
+
+	if (G_UNLIKELY (!quark))
+		quark = g_quark_from_static_string ("nm-setting-bridge-error-quark");
+	return quark;
+}
+
+/* This should really be standard. */
+#define ENUM_ENTRY(NAME, DESC) { NAME, "" #NAME "", DESC }
+
+GType
+nm_setting_bridge_error_get_type (void)
+{
+	static GType etype = 0;
+
+	if (etype == 0) {
+		static const GEnumValue values[] = {
+			/* Unknown error. */
+			ENUM_ENTRY (NM_SETTING_BRIDGE_ERROR_UNKNOWN, "UnknownError"),
+			/* The specified property was invalid. */
+			ENUM_ENTRY (NM_SETTING_BRIDGE_ERROR_INVALID_PROPERTY, "InvalidProperty"),
+			/* The specified property was missing and is required. */
+			ENUM_ENTRY (NM_SETTING_BRIDGE_ERROR_MISSING_PROPERTY, "MissingProperty"),
+			{ 0, 0, 0 }
+		};
+		etype = g_enum_register_static ("NMSettingBridgeError", values);
+	}
+	return etype;
+}
+
+
+G_DEFINE_TYPE (NMSettingBridge, nm_setting_bridge, NM_TYPE_SETTING)
+
+#define NM_SETTING_BRIDGE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_SETTING_BRIDGE, NMSettingBridgePrivate))
+
+typedef struct {
+	char *   interface_name;
+	gboolean stp;
+	guint16  priority;
+	guint16  forward_delay;
+	guint16  hello_time;
+	guint16  max_age;
+	guint32  ageing_time;
+} NMSettingBridgePrivate;
+
+enum {
+	PROP_0,
+	PROP_INTERFACE_NAME,
+	PROP_STP,
+	PROP_PRIORITY,
+	PROP_FORWARD_DELAY,
+	PROP_HELLO_TIME,
+	PROP_MAX_AGE,
+	PROP_AGEING_TIME,
+	LAST_PROP
+};
+
+/**
+ * nm_setting_bridge_new:
+ *
+ * Creates a new #NMSettingBridge object with default values.
+ *
+ * Returns: (transfer full): the new empty #NMSettingBridge object
+ **/
+NMSetting *
+nm_setting_bridge_new (void)
+{
+	return (NMSetting *) g_object_new (NM_TYPE_SETTING_BRIDGE, NULL);
+}
+
+/**
+ * nm_setting_bridge_get_interface_name:
+ * @setting: the #NMSettingBridge
+ *
+ * Returns: the #NMSettingBridge:interface-name property of the setting
+ **/
+const char *
+nm_setting_bridge_get_interface_name (NMSettingBridge *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_BRIDGE (setting), 0);
+
+	return NM_SETTING_BRIDGE_GET_PRIVATE (setting)->interface_name;
+}
+
+/**
+ * nm_setting_bridge_get_stp:
+ * @setting: the #NMSettingBridge
+ *
+ * Returns: the #NMSettingBridge:stp property of the setting
+ **/
+gboolean
+nm_setting_bridge_get_stp (NMSettingBridge *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_BRIDGE (setting), FALSE);
+
+	return NM_SETTING_BRIDGE_GET_PRIVATE (setting)->stp;
+}
+
+/**
+ * nm_setting_bridge_get_priority:
+ * @setting: the #NMSettingBridge
+ *
+ * Returns: the #NMSettingBridge:priority property of the setting
+ **/
+guint16
+nm_setting_bridge_get_priority (NMSettingBridge *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_BRIDGE (setting), 0);
+
+	return NM_SETTING_BRIDGE_GET_PRIVATE (setting)->priority;
+}
+
+/**
+ * nm_setting_bridge_get_forward_delay:
+ * @setting: the #NMSettingBridge
+ *
+ * Returns: the #NMSettingBridge:forward-delay property of the setting
+ **/
+guint16
+nm_setting_bridge_get_forward_delay (NMSettingBridge *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_BRIDGE (setting), 0);
+
+	return NM_SETTING_BRIDGE_GET_PRIVATE (setting)->forward_delay;
+}
+
+/**
+ * nm_setting_bridge_get_hello_time:
+ * @setting: the #NMSettingBridge
+ *
+ * Returns: the #NMSettingBridge:hello-time property of the setting
+ **/
+guint16
+nm_setting_bridge_get_hello_time (NMSettingBridge *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_BRIDGE (setting), 0);
+
+	return NM_SETTING_BRIDGE_GET_PRIVATE (setting)->hello_time;
+}
+
+/**
+ * nm_setting_bridge_get_max_age:
+ * @setting: the #NMSettingBridge
+ *
+ * Returns: the #NMSettingBridge:max-age property of the setting
+ **/
+guint16
+nm_setting_bridge_get_max_age (NMSettingBridge *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_BRIDGE (setting), 0);
+
+	return NM_SETTING_BRIDGE_GET_PRIVATE (setting)->max_age;
+}
+
+/**
+ * nm_setting_bridge_get_ageing_time:
+ * @setting: the #NMSettingBridge
+ *
+ * Returns: the #NMSettingBridge:ageing-time property of the setting
+ **/
+guint
+nm_setting_bridge_get_ageing_time (NMSettingBridge *setting)
+{
+	g_return_val_if_fail (NM_IS_SETTING_BRIDGE (setting), 0);
+
+	return NM_SETTING_BRIDGE_GET_PRIVATE (setting)->ageing_time;
+}
+
+/* IEEE 802.1D-1998 timer values */
+#define BR_MIN_HELLO_TIME    1
+#define BR_MAX_HELLO_TIME    10
+
+#define BR_MIN_FORWARD_DELAY 2
+#define BR_MAX_FORWARD_DELAY 30
+
+#define BR_MIN_MAX_AGE       6
+#define BR_MAX_MAX_AGE       40
+
+/* IEEE 802.1D-1998 Table 7.4 */
+#define BR_MIN_AGEING_TIME   0
+#define BR_MAX_AGEING_TIME   1000000
+
+static inline gboolean
+check_range (guint32 val,
+             guint32 min,
+             guint32 max,
+             const char *prop,
+             GError **error)
+{
+	if ((val != 0) && (val < min || val > max)) {
+		g_set_error (error,
+		             NM_SETTING_BRIDGE_ERROR,
+		             NM_SETTING_BRIDGE_ERROR_INVALID_PROPERTY,
+		             prop);
+		return FALSE;
+	}
+	return TRUE;
+}
+
+static gboolean
+verify (NMSetting *setting, GSList *all_settings, GError **error)
+{
+	NMSettingBridgePrivate *priv = NM_SETTING_BRIDGE_GET_PRIVATE (setting);
+
+	if (!priv->interface_name || !strlen(priv->interface_name)) {
+		g_set_error (error,
+		             NM_SETTING_BRIDGE_ERROR,
+		             NM_SETTING_BRIDGE_ERROR_MISSING_PROPERTY,
+		             NM_SETTING_BRIDGE_INTERFACE_NAME);
+		return FALSE;
+	}
+
+	if (!nm_utils_iface_valid_name (priv->interface_name)) {
+		g_set_error (error,
+		             NM_SETTING_BRIDGE_ERROR,
+		             NM_SETTING_BRIDGE_ERROR_INVALID_PROPERTY,
+		             NM_SETTING_BRIDGE_INTERFACE_NAME);
+		return FALSE;
+	}
+
+	if (!check_range (priv->forward_delay,
+	                  BR_MIN_FORWARD_DELAY,
+	                  BR_MAX_FORWARD_DELAY,
+	                  NM_SETTING_BRIDGE_FORWARD_DELAY,
+	                  error))
+		return FALSE;
+
+	if (!check_range (priv->hello_time,
+	                  BR_MIN_HELLO_TIME,
+	                  BR_MAX_HELLO_TIME,
+	                  NM_SETTING_BRIDGE_HELLO_TIME,
+	                  error))
+		return FALSE;
+
+	if (!check_range (priv->max_age,
+	                  BR_MIN_MAX_AGE,
+	                  BR_MAX_MAX_AGE,
+	                  NM_SETTING_BRIDGE_MAX_AGE,
+	                  error))
+		return FALSE;
+
+	if (!check_range (priv->ageing_time,
+	                  BR_MIN_AGEING_TIME,
+	                  BR_MAX_AGEING_TIME,
+	                  NM_SETTING_BRIDGE_AGEING_TIME,
+	                  error))
+		return FALSE;
+
+	return TRUE;
+}
+
+static const char *
+get_virtual_iface_name (NMSetting *setting)
+{
+	NMSettingBridge *self = NM_SETTING_BRIDGE (setting);
+
+	return nm_setting_bridge_get_interface_name (self);
+}
+
+static void
+nm_setting_bridge_init (NMSettingBridge *setting)
+{
+	g_object_set (setting, NM_SETTING_NAME, NM_SETTING_BRIDGE_SETTING_NAME, NULL);
+}
+
+static void
+finalize (GObject *object)
+{
+	NMSettingBridgePrivate *priv = NM_SETTING_BRIDGE_GET_PRIVATE (object);
+
+	g_free (priv->interface_name);
+
+	G_OBJECT_CLASS (nm_setting_bridge_parent_class)->finalize (object);
+}
+
+static void
+set_property (GObject *object, guint prop_id,
+              const GValue *value, GParamSpec *pspec)
+{
+	NMSettingBridgePrivate *priv = NM_SETTING_BRIDGE_GET_PRIVATE (object);
+
+	switch (prop_id) {
+	case PROP_INTERFACE_NAME:
+		g_free (priv->interface_name);
+		priv->interface_name = g_value_dup_string (value);
+		break;
+	case PROP_STP:
+		priv->stp = g_value_get_boolean (value);
+		break;
+	case PROP_PRIORITY:
+		priv->priority = (guint16) g_value_get_uint (value);
+		break;
+	case PROP_FORWARD_DELAY:
+		priv->forward_delay = (guint16) g_value_get_uint (value);
+		break;
+	case PROP_HELLO_TIME:
+		priv->hello_time = (guint16) g_value_get_uint (value);
+		break;
+	case PROP_MAX_AGE:
+		priv->max_age = (guint16) g_value_get_uint (value);
+		break;
+	case PROP_AGEING_TIME:
+		priv->ageing_time = g_value_get_uint (value);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+get_property (GObject *object, guint prop_id,
+              GValue *value, GParamSpec *pspec)
+{
+	NMSettingBridgePrivate *priv = NM_SETTING_BRIDGE_GET_PRIVATE (object);
+	NMSettingBridge *setting = NM_SETTING_BRIDGE (object);
+
+	switch (prop_id) {
+	case PROP_INTERFACE_NAME:
+		g_value_set_string (value, nm_setting_bridge_get_interface_name (setting));
+		break;
+	case PROP_STP:
+		g_value_set_boolean (value, priv->stp);
+		break;
+	case PROP_PRIORITY:
+		g_value_set_uint (value, priv->priority);
+		break;
+	case PROP_FORWARD_DELAY:
+		g_value_set_uint (value, priv->forward_delay);
+		break;
+	case PROP_HELLO_TIME:
+		g_value_set_uint (value, priv->hello_time);
+		break;
+	case PROP_MAX_AGE:
+		g_value_set_uint (value, priv->max_age);
+		break;
+	case PROP_AGEING_TIME:
+		g_value_set_uint (value, priv->ageing_time);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+nm_setting_bridge_class_init (NMSettingBridgeClass *setting_class)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (setting_class);
+	NMSettingClass *parent_class = NM_SETTING_CLASS (setting_class);
+
+	g_type_class_add_private (setting_class, sizeof (NMSettingBridgePrivate));
+
+	/* virtual methods */
+	object_class->set_property = set_property;
+	object_class->get_property = get_property;
+	object_class->finalize     = finalize;
+	parent_class->verify       = verify;
+	parent_class->get_virtual_iface_name = get_virtual_iface_name;
+
+	/* Properties */
+	/**
+	 * NMSettingBridge:interface-name:
+	 *
+	 * The name of the virtual in-kernel briding network interface
+	 **/
+	g_object_class_install_property
+		(object_class, PROP_INTERFACE_NAME,
+		 g_param_spec_string (NM_SETTING_BRIDGE_INTERFACE_NAME,
+		                      "InterfaceName",
+		                      "The name of the virtual in-kernel bridging network interface",
+		                      NULL,
+		                      G_PARAM_READWRITE | NM_SETTING_PARAM_SERIALIZE));
+
+	/**
+	 * NMSettingBridge:stp:
+	 *
+	 * Controls whether Spanning Tree Protocol (STP) is enabled for this bridge.
+	 **/
+	 g_object_class_install_property
+		 (object_class, PROP_STP,
+		  g_param_spec_boolean (NM_SETTING_BRIDGE_STP,
+		                        "STP",
+		                        "Controls whether Spanning Tree Protocol (STP) "
+		                        "is enabled for this bridge.",
+		                        TRUE,
+		                        G_PARAM_READWRITE | G_PARAM_CONSTRUCT | NM_SETTING_PARAM_SERIALIZE));
+
+	/**
+	 * NMSettingBridge:priority:
+	 *
+	 * Sets the Spanning Tree Protocol (STP) priority for this bridge.  Lower
+	 * values are "better"; the lowest priority bridge will be elected the root
+	 * bridge.
+	 **/
+	 g_object_class_install_property
+		 (object_class, PROP_PRIORITY,
+		  g_param_spec_uint (NM_SETTING_BRIDGE_PRIORITY,
+		                     "Priority",
+		                     "Sets the Spanning Tree Protocol (STP) priority "
+		                     "for this bridge.  Lower values are 'better'; the "
+		                     "lowest priority bridge will be elected the root "
+		                     "bridge.",
+		                     0, G_MAXUINT16, 0x80,
+		                     G_PARAM_READWRITE | G_PARAM_CONSTRUCT | NM_SETTING_PARAM_SERIALIZE));
+
+	/**
+	 * NMSettingBridge:forward-delay:
+	 *
+	 * The Spanning Tree Protocol (STP) forwarding delay, in seconds.
+	 **/
+	 g_object_class_install_property
+		 (object_class, PROP_FORWARD_DELAY,
+		  g_param_spec_uint (NM_SETTING_BRIDGE_FORWARD_DELAY,
+		                     "ForwardDelay",
+		                     "The Spanning Tree Protocol (STP) forwarding "
+		                     "delay, in seconds.",
+		                     0, BR_MAX_FORWARD_DELAY, 15,
+		                     G_PARAM_READWRITE | G_PARAM_CONSTRUCT | NM_SETTING_PARAM_SERIALIZE));
+
+	/**
+	 * NMSettingBridge:hello-time:
+	 *
+	 * The Spanning Tree Protocol (STP) hello time, in seconds.
+	 **/
+	 g_object_class_install_property
+		 (object_class, PROP_HELLO_TIME,
+		  g_param_spec_uint (NM_SETTING_BRIDGE_HELLO_TIME,
+		                     "HelloTime",
+		                     "The Spanning Tree Protocol (STP) hello time, in "
+		                     "seconds.",
+		                     0, BR_MAX_HELLO_TIME, 2,
+		                     G_PARAM_READWRITE | G_PARAM_CONSTRUCT | NM_SETTING_PARAM_SERIALIZE));
+
+	/**
+	 * NMSettingBridge:max-age:
+	 *
+	 * The Spanning Tree Protocol (STP) maximum message age, in seconds.
+	 **/
+	 g_object_class_install_property
+		 (object_class, PROP_MAX_AGE,
+		  g_param_spec_uint (NM_SETTING_BRIDGE_MAX_AGE,
+		                     "MaxAge",
+		                     "The Spanning Tree Protocol (STP) maximum message "
+		                     "age, in seconds.",
+		                     0, BR_MAX_MAX_AGE, 20,
+		                     G_PARAM_READWRITE | G_PARAM_CONSTRUCT | NM_SETTING_PARAM_SERIALIZE));
+
+	/**
+	 * NMSettingBridge:ageing-time:
+	 *
+	 * The ethernet MAC address aging time, in seconds.
+	 **/
+	 g_object_class_install_property
+		 (object_class, PROP_AGEING_TIME,
+		  g_param_spec_uint (NM_SETTING_BRIDGE_AGEING_TIME,
+		                     "AgeingTime",
+		                     "The ethernet MAC address aging time, in seconds.",
+		                     0, BR_MAX_AGEING_TIME, 300,
+		                     G_PARAM_READWRITE | G_PARAM_CONSTRUCT | NM_SETTING_PARAM_SERIALIZE));
+}
+
diff --git a/libnm-util/nm-setting-bridge.h b/libnm-util/nm-setting-bridge.h
new file mode 100644
index 0000000..2883459
--- /dev/null
+++ b/libnm-util/nm-setting-bridge.h
@@ -0,0 +1,101 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+
+/*
+ * Thomas Graf <tgraf@redhat.com>
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the
+ * Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor,
+ * Boston, MA 02110-1301 USA.
+ *
+ * (C) Copyright 2011 - 2012 Red Hat, Inc.
+ */
+
+#ifndef NM_SETTING_BRIDGE_H
+#define NM_SETTING_BRIDGE_H
+
+#include <nm-setting.h>
+
+G_BEGIN_DECLS
+
+#define NM_TYPE_SETTING_BRIDGE            (nm_setting_bridge_get_type ())
+#define NM_SETTING_BRIDGE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_SETTING_BRIDGE, NMSettingBridge))
+#define NM_SETTING_BRIDGE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass), NM_TYPE_SETTING_BRIDGE, NMSettingBridgeClass))
+#define NM_IS_SETTING_BRIDGE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_SETTING_BRIDGE))
+#define NM_IS_SETTING_BRIDGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass), NM_TYPE_SETTING_BRIDGE))
+#define NM_SETTING_BRIDGE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_SETTING_BRIDGE, NMSettingBridgeClass))
+
+#define NM_SETTING_BRIDGE_SETTING_NAME "bridge"
+
+/**
+ * NMSettingBridgeError:
+ * @NM_SETTING_BRIDGE_ERROR_UNKNOWN: unknown or unclassified error
+ * @NM_SETTING_BRIDGE_ERROR_INVALID_PROPERTY: the property was invalid
+ * @NM_SETTING_BRIDGE_ERROR_MISSING_PROPERTY: the property was missing and is
+ * required
+ */
+typedef enum {
+	NM_SETTING_BRIDGE_ERROR_UNKNOWN = 0,      /*< nick=UnknownError >*/
+	NM_SETTING_BRIDGE_ERROR_INVALID_PROPERTY, /*< nick=InvalidProperty >*/
+	NM_SETTING_BRIDGE_ERROR_MISSING_PROPERTY, /*< nick=MissingProperty >*/
+} NMSettingBridgeError;
+
+#define NM_TYPE_SETTING_BRIDGE_ERROR (nm_setting_bridge_error_get_type ()) 
+GType nm_setting_bridge_error_get_type (void);
+
+#define NM_SETTING_BRIDGE_ERROR nm_setting_bridge_error_quark ()
+GQuark nm_setting_bridge_error_quark (void);
+
+#define NM_SETTING_BRIDGE_INTERFACE_NAME "interface-name"
+#define NM_SETTING_BRIDGE_STP            "stp"
+#define NM_SETTING_BRIDGE_PRIORITY       "priority"
+#define NM_SETTING_BRIDGE_FORWARD_DELAY  "forward-delay"
+#define NM_SETTING_BRIDGE_HELLO_TIME     "hello-time"
+#define NM_SETTING_BRIDGE_MAX_AGE        "max-age"
+#define NM_SETTING_BRIDGE_AGEING_TIME    "ageing-time"
+
+typedef struct {
+	NMSetting parent;
+} NMSettingBridge;
+
+typedef struct {
+	NMSettingClass parent;
+
+	/* Padding for future expansion */
+	void (*_reserved1) (void);
+	void (*_reserved2) (void);
+	void (*_reserved3) (void);
+	void (*_reserved4) (void);
+} NMSettingBridgeClass;
+
+GType nm_setting_bridge_get_type (void);
+
+NMSetting *  nm_setting_bridge_new                (void);
+
+const char * nm_setting_bridge_get_interface_name (NMSettingBridge *setting);
+
+gboolean     nm_setting_bridge_get_stp            (NMSettingBridge *setting);
+
+guint16      nm_setting_bridge_get_priority       (NMSettingBridge *setting);
+
+guint16      nm_setting_bridge_get_forward_delay  (NMSettingBridge *setting);
+
+guint16      nm_setting_bridge_get_hello_time     (NMSettingBridge *setting);
+
+guint16      nm_setting_bridge_get_max_age        (NMSettingBridge *setting);
+
+guint32      nm_setting_bridge_get_ageing_time    (NMSettingBridge *setting);
+
+G_END_DECLS
+
+#endif /* NM_SETTING_BRIDGE_H */
diff --git a/src/Makefile.am b/src/Makefile.am
index 4c1bb51..632ab44 100644
--- a/src/Makefile.am
+++ b/src/Makefile.am
@@ -110,6 +110,8 @@ NetworkManager_SOURCES = \
 		nm-device-infiniband.h \
 		nm-device-bond.c \
 		nm-device-bond.h \
+		nm-device-bridge.c \
+		nm-device-bridge.h \
 		nm-device-vlan.c \
 		nm-device-vlan.h \
 		nm-wifi-ap.c \
@@ -179,6 +181,9 @@ nm-device-infiniband-glue.h: $(top_srcdir)/introspection/nm-device-infiniband.xm
 nm-device-bond-glue.h: $(top_srcdir)/introspection/nm-device-bond.xml
 	$(AM_V_GEN) dbus-binding-tool --prefix=nm_device_bond --mode=glib-server --output=$@ $<
 
+nm-device-bridge-glue.h: $(top_srcdir)/introspection/nm-device-bridge.xml
+	$(AM_V_GEN) dbus-binding-tool --prefix=nm_device_bridge --mode=glib-server --output=$@ $<
+
 nm-device-vlan-glue.h: $(top_srcdir)/introspection/nm-device-vlan.xml
 	$(AM_V_GEN) dbus-binding-tool --prefix=nm_device_vlan --mode=glib-server --output=$@ $<
 
@@ -219,6 +224,7 @@ BUILT_SOURCES = \
 	nm-device-ethernet-glue.h \
 	nm-device-infiniband-glue.h \
 	nm-device-bond-glue.h \
+	nm-device-bridge-glue.h \
 	nm-device-vlan-glue.h \
 	nm-device-wifi-glue.h \
 	nm-device-olpc-mesh-glue.h \
diff --git a/src/NetworkManagerUtils.c b/src/NetworkManagerUtils.c
index a956fc7..e98beb7 100644
--- a/src/NetworkManagerUtils.c
+++ b/src/NetworkManagerUtils.c
@@ -664,30 +664,64 @@ value_hash_add_bool (GHashTable *hash,
 	value_hash_add (hash, key, value);
 }
 
+/**
+ * nm_utils_do_sysctl:
+ * @path: path to write @value to
+ * @value: value to write to @path
+ *
+ * Writes @value to the file at @path, trying 3 times on failure.
+ *
+ * Returns: %TRUE on success.  On failure, returns %FALSE and sets errno.
+ */
 gboolean
 nm_utils_do_sysctl (const char *path, const char *value)
 {
-	int fd, len, nwrote, total;
-
-	fd = open (path, O_WRONLY);
-	if (fd == -1)
+	int fd, len, nwrote, tries, saved_errno = 0;
+	char *actual;
+
+	g_return_val_if_fail (path != NULL, FALSE);
+	g_return_val_if_fail (value != NULL, FALSE);
+
+	fd = open (path, O_WRONLY | O_TRUNC);
+	if (fd == -1) {
+		saved_errno = errno;
+		nm_log_warn (LOGD_CORE, "sysctl: failed to open '%s': (%d) %s",
+		             path, saved_errno, strerror (saved_errno));
+		errno = saved_errno;
 		return FALSE;
+	}
+
+	nm_log_dbg (LOGD_CORE, "sysctl: setting '%s' to '%s'", path, value);
+
+	/* Most sysfs and sysctl options don't care about a trailing CR, while some
+	 * (like infiniband) do.  So always add the CR.  Also, neither sysfs nor
+	 * sysctl support partial writes so the CR must be added to the string we're
+	 * about to write.
+	 */
+	actual = g_strdup_printf ("%s\n", value);
 
-	len = strlen (value);
-	total = 0;
-	do {
-		nwrote = write (fd, value + total, len - total);
+	/* Try to write the entire value three times if a partial write occurs */
+	len = strlen (actual);
+	for (tries = 0, nwrote = 0; tries < 3 && nwrote != len; tries++) {
+		errno = 0;
+		nwrote = write (fd, actual, len);
 		if (nwrote == -1) {
 			if (errno == EINTR)
 				continue;
-			close (fd);
-			return FALSE;
+			saved_errno = errno;
+			break;
 		}
-		total += nwrote;
-	} while (total < len);
-
+	}
+	g_free (actual);
 	close (fd);
-	return TRUE;
+
+	if (nwrote != len && saved_errno != EEXIST) {
+		nm_log_warn (LOGD_CORE, "sysctl: failed to set '%s' to '%s': (%d) %s",
+		             path, value, saved_errno, strerror (saved_errno));
+	}
+
+	errno = saved_errno;
+	return (nwrote == len);
 }
 
 gboolean
diff --git a/src/ip6-manager/nm-ip6-manager.c b/src/ip6-manager/nm-ip6-manager.c
index f6f6127..5a59578 100644
--- a/src/ip6-manager/nm-ip6-manager.c
+++ b/src/ip6-manager/nm-ip6-manager.c
@@ -110,7 +110,7 @@ nm_ip6_device_destroy (NMIP6Device *device)
 	/* reset the saved IPv6 value */
 	if (device->disable_ip6_save_valid) {
 		nm_utils_do_sysctl (device->disable_ip6_path,
-		                    device->disable_ip6_save ? "1\n" : "0\n");
+		                    device->disable_ip6_save ? "1" : "0");
 	}
 
 	if (device->finish_addrconf_id)
@@ -820,10 +820,10 @@ nm_ip6_manager_prepare_interface (NMIP6Manager *manager,
 	/* Establish target state and turn router advertisement acceptance on or off */
 	if (!strcmp (method, NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL)) {
 		device->target_state = NM_IP6_DEVICE_GOT_LINK_LOCAL;
-		nm_utils_do_sysctl (accept_ra_path, "0\n");
+		nm_utils_do_sysctl (accept_ra_path, "0");
 	} else {
 		device->target_state = NM_IP6_DEVICE_GOT_ADDRESS;
-		nm_utils_do_sysctl (accept_ra_path, "1\n");
+		nm_utils_do_sysctl (accept_ra_path, "1");
 	}
 }
 
@@ -866,9 +866,9 @@ nm_ip6_manager_begin_addrconf (NMIP6Manager *manager, int ifindex)
 	 * new RAs; there doesn't seem to be a better way to do this right now.
 	 */
 	if (device->target_state >= NM_IP6_DEVICE_GOT_ADDRESS) {
-		nm_utils_do_sysctl (device->disable_ip6_path, "1\n");
+		nm_utils_do_sysctl (device->disable_ip6_path, "1");
 		g_usleep (200);
-		nm_utils_do_sysctl (device->disable_ip6_path, "0\n");
+		nm_utils_do_sysctl (device->disable_ip6_path, "0");
 	}
 
 	device->ip6flags_poll_id = g_timeout_add_seconds (1, poll_ip6_flags, priv->monitor);
diff --git a/src/nm-activation-request.c b/src/nm-activation-request.c
index a8887f7..8160ade 100644
--- a/src/nm-activation-request.c
+++ b/src/nm-activation-request.c
@@ -76,8 +76,7 @@ typedef struct {
 	gboolean is_default;
 	gboolean is_default6;
 
-	NMActRequest *dep;
-	guint dep_state_id;
+	NMDevice *master;
 
 	gboolean shared;
 	GSList *share_rules;
@@ -149,59 +148,13 @@ device_state_changed (NMDevice *device,
 	}
 }
 
-static void
-dep_gone (NMActRequest *self, GObject *ignored)
-{
-	NMActRequestPrivate *priv = NM_ACT_REQUEST_GET_PRIVATE (self);
-
-	g_warn_if_fail (G_OBJECT (priv->dep) == ignored);
-
-	/* Dependent connection is gone; clean up and fail */
-	priv->dep = NULL;
-	priv->dep_state_id = 0;
-	g_signal_emit (self, signals[DEP_RESULT], 0, NM_ACT_REQUEST_DEP_RESULT_FAILED);
-}
-
-static NMActRequestDependencyResult
-ac_state_to_dep_result (NMActRequest *ac)
-{
-	NMActiveConnectionState state = nm_act_request_get_ac_state (ac);
-
-	if (state == NM_ACTIVE_CONNECTION_STATE_ACTIVATING)
-		return NM_ACT_REQUEST_DEP_RESULT_WAIT;
-	else if (state == NM_ACTIVE_CONNECTION_STATE_ACTIVATED)
-		return NM_ACT_REQUEST_DEP_RESULT_READY;
-
-	return NM_ACT_REQUEST_DEP_RESULT_FAILED;
-}
-
-static void
-dep_state_changed (NMActRequest *dep,
-                   GParamSpec *pspec,
-                   NMActRequest *self)
-{
-	NMActRequestPrivate *priv = NM_ACT_REQUEST_GET_PRIVATE (self);
-	NMActRequestDependencyResult result;
-
-	g_warn_if_fail (priv->dep == dep);
-
-	result = ac_state_to_dep_result (priv->dep);
-	if (result == NM_ACT_REQUEST_DEP_RESULT_FAILED) {
-		g_object_weak_unref (G_OBJECT (priv->dep), (GWeakNotify) dep_gone, self);
-		g_signal_handler_disconnect (priv->dep, priv->dep_state_id);
-		priv->dep = NULL;
-		priv->dep_state_id = 0;
-	}
-	g_signal_emit (self, signals[DEP_RESULT], 0, result);
-}
-
 NMActRequest *
 nm_act_request_new (NMConnection *connection,
                     const char *specific_object,
                     gboolean user_requested,
                     gboolean assumed,
                     gpointer *device,
-                    NMActRequest *dependency)
+                    gpointer *master)
 {
 	GObject *object;
 	NMActRequestPrivate *priv;
@@ -226,14 +179,11 @@ nm_act_request_new (NMConnection *connection,
 
 	priv->user_requested = user_requested;
 	priv->assumed = assumed;
+	if (master) {
+		g_assert (NM_IS_DEVICE (master));
+		g_assert (NM_DEVICE (master) != NM_DEVICE (device));
 
-	if (dependency) {
-		priv->dep = dependency;
-		g_object_weak_ref (G_OBJECT (dependency), (GWeakNotify) dep_gone, object);
-		priv->dep_state_id = g_signal_connect (dependency,
-		                                       "notify::" NM_ACTIVE_CONNECTION_STATE,
-		                                       G_CALLBACK (dep_state_changed),
-		                                       object);
+		priv->master = g_object_ref (master);
 	}
 
 	return NM_ACT_REQUEST (object);
@@ -277,11 +227,9 @@ dispose (GObject *object)
 
 	g_object_unref (priv->connection);
 
-	if (priv->dep) {
-		g_object_weak_unref (G_OBJECT (priv->dep), (GWeakNotify) dep_gone, object);
-		g_signal_handler_disconnect (priv->dep, priv->dep_state_id);
-		priv->dep = NULL;
-		priv->dep_state_id = 0;
+	if (priv->master) {
+		g_object_unref (priv->master);
+		priv->master = NULL;
 	}
 
 	G_OBJECT_CLASS (nm_act_request_parent_class)->dispose (object);
@@ -324,7 +272,6 @@ get_property (GObject *object, guint prop_id,
 {
 	NMActRequestPrivate *priv = NM_ACT_REQUEST_GET_PRIVATE (object);
 	GPtrArray *devices;
-	NMDevice *master;
 
 	switch (prop_id) {
 	case PROP_SERVICE_NAME:
@@ -357,12 +304,7 @@ get_property (GObject *object, guint prop_id,
 		g_value_set_boolean (value, FALSE);
 		break;
 	case PROP_MASTER:
-		if (priv->dep) {
-			master = NM_DEVICE (nm_act_request_get_device (priv->dep));
-			g_assert (master);
-			g_value_set_boxed (value, nm_device_get_path (master));
-		} else
-			g_value_set_boxed (value, "/");
+		g_value_set_boxed (value, priv->master ? nm_device_get_path (priv->master) : "/");
 		break;
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
@@ -419,14 +361,6 @@ nm_act_request_class_init (NMActRequestClass *req_class)
 		nm_properties_changed_signal_new (object_class,
 		                                  G_STRUCT_OFFSET (NMActRequestClass, properties_changed));
 
-	signals[DEP_RESULT] =
-		g_signal_new (NM_ACT_REQUEST_DEPENDENCY_RESULT,
-					  G_OBJECT_CLASS_TYPE (object_class),
-					  G_SIGNAL_RUN_FIRST,
-					  0, NULL, NULL,
-					  g_cclosure_marshal_VOID__UINT,
-					  G_TYPE_NONE, 1, G_TYPE_UINT);
-
 	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (req_class),
 	                                 &dbus_glib_nm_active_connection_object_info);
 }
@@ -738,20 +672,10 @@ nm_act_request_get_assumed (NMActRequest *req)
 	return NM_ACT_REQUEST_GET_PRIVATE (req)->assumed;
 }
 
-NMActRequest *
-nm_act_request_get_dependency (NMActRequest *req)
-{
-	g_return_val_if_fail (req != NULL, NULL);
-
-	return NM_ACT_REQUEST_GET_PRIVATE (req)->dep;
-}
-
-NMActRequestDependencyResult
-nm_act_request_get_dependency_result (NMActRequest *req)
+GObject *
+nm_act_request_get_master (NMActRequest *req)
 {
-	NMActRequestPrivate *priv = NM_ACT_REQUEST_GET_PRIVATE (req);
-
-	return priv->dep ? ac_state_to_dep_result (priv->dep) : NM_ACT_REQUEST_DEP_RESULT_READY;
+	return (GObject *) NM_ACT_REQUEST_GET_PRIVATE (req)->master;
 }
 
 NMActiveConnectionState
diff --git a/src/nm-activation-request.h b/src/nm-activation-request.h
index 81ed735..b93e94e 100644
--- a/src/nm-activation-request.h
+++ b/src/nm-activation-request.h
@@ -35,15 +35,6 @@
 #define NM_IS_ACT_REQUEST_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((obj), NM_TYPE_ACT_REQUEST))
 #define NM_ACT_REQUEST_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj), NM_TYPE_ACT_REQUEST, NMActRequestClass))
 
-typedef enum {
-	NM_ACT_REQUEST_DEP_RESULT_UNKNOWN,
-	NM_ACT_REQUEST_DEP_RESULT_WAIT,
-	NM_ACT_REQUEST_DEP_RESULT_READY,
-	NM_ACT_REQUEST_DEP_RESULT_FAILED,
-} NMActRequestDependencyResult;
-
-#define NM_ACT_REQUEST_DEPENDENCY_RESULT "dependency-result"
-
 typedef struct {
 	GObject parent;
 } NMActRequest;
@@ -62,8 +53,6 @@ typedef struct {
 	                                RequestSecretsCaller caller);
 
 	void (*properties_changed) (NMActRequest *req, GHashTable *properties);
-
-	void (*dependency_result) (NMActRequest *req, NMActRequestDependencyResult result);
 } NMActRequestClass;
 
 GType nm_act_request_get_type (void);
@@ -73,7 +62,7 @@ NMActRequest *nm_act_request_new          (NMConnection *connection,
                                            gboolean user_requested,
                                            gboolean assumed,
                                            gpointer *device,  /* An NMDevice */
-                                           NMActRequest *dependency);
+                                           gpointer *master); /* An NMDevice */
 
 NMConnection *nm_act_request_get_connection     (NMActRequest *req);
 const char *  nm_act_request_get_specific_object (NMActRequest *req);
@@ -112,9 +101,7 @@ gboolean nm_act_request_get_secrets    (NMActRequest *req,
                                         const char *hint1,
                                         const char *hint2);
 
-NMActRequest *nm_act_request_get_dependency (NMActRequest *req);
-
-NMActRequestDependencyResult nm_act_request_get_dependency_result (NMActRequest *req);
+GObject *     nm_act_request_get_master (NMActRequest *req);
 
 NMActiveConnectionState nm_act_request_get_ac_state (NMActRequest *req);
 
diff --git a/src/nm-device-bond.c b/src/nm-device-bond.c
index 3b5dc5f..4ab0fa5 100644
--- a/src/nm-device-bond.c
+++ b/src/nm-device-bond.c
@@ -33,6 +33,7 @@
 #include "NetworkManagerUtils.h"
 #include "nm-device-private.h"
 #include "nm-netlink-monitor.h"
+#include "nm-dbus-glib-types.h"
 #include "nm-system.h"
 
 #include "nm-device-bond-glue.h"
@@ -44,8 +45,11 @@ G_DEFINE_TYPE (NMDeviceBond, nm_device_bond, NM_TYPE_DEVICE_WIRED)
 #define NM_BOND_ERROR (nm_bond_error_quark ())
 
 typedef struct {
-	gboolean disposed;
-	GSList *slaves;
+	gboolean ip4_waiting;
+	gboolean ip6_waiting;
+	gboolean carrier_waiting;
+
+	guint ip_retry_id;
 } NMDeviceBondPrivate;
 
 enum {
@@ -60,6 +64,7 @@ enum {
 	PROP_0,
 	PROP_HW_ADDRESS,
 	PROP_CARRIER,
+	PROP_SLAVES,
 
 	LAST_PROP
 };
@@ -116,13 +121,34 @@ device_state_changed (NMDevice *device,
                       NMDeviceStateReason reason,
                       gpointer user_data)
 {
-	if (new_state == NM_DEVICE_STATE_UNAVAILABLE) {
-		/* Use NM_DEVICE_STATE_REASON_CARRIER to make sure num retries is reset */
-		nm_device_queue_state (device, NM_DEVICE_STATE_DISCONNECTED, NM_DEVICE_STATE_REASON_CARRIER);
+	NMDeviceBondPrivate *priv = NM_DEVICE_BOND_GET_PRIVATE (device);
+
+	if (new_state != NM_DEVICE_STATE_IP_CONFIG) {
+		if (priv->ip_retry_id) {
+			g_source_remove (priv->ip_retry_id);
+			priv->ip_retry_id = 0;
+		}
 	}
 }
 
 static void
+carrier_action (NMDeviceWired *self, NMDeviceState state, gboolean carrier)
+{
+	/* Carrier can't be used to signal availability of the bond master because
+	 * the bond's carrier follows the slaves' carriers.  So carrier gets
+	 * ignored when determining whether or not the device can be activated.
+	 *
+	 * Second, just because all slaves have been removed or have lost carrier
+	 * does not mean the master should be deactivated.  This could be due to
+	 * user addition/removal of slaves, and is also normal operation with some
+	 * failover modes.
+	 *
+	 * For these reasons, carrier changes are effectively ignored by overriding
+	 * the parent class' carrier handling and doing nothing.
+	 */
+}
+
+static void
 real_update_hw_address (NMDevice *dev)
 {
 	const guint8 *hw_addr;
@@ -279,6 +305,7 @@ connection_match_config (NMDevice *self, const GSList *connections)
 static NMActStageReturn
 real_act_stage1_prepare (NMDevice *dev, NMDeviceStateReason *reason)
 {
+	NMDeviceBondPrivate *priv = NM_DEVICE_BOND_GET_PRIVATE (dev);
 	NMActStageReturn ret = NM_ACT_STAGE_RETURN_SUCCESS;
 	NMConnection *connection;
 	NMSettingBond *s_bond;
@@ -286,6 +313,10 @@ real_act_stage1_prepare (NMDevice *dev, NMDeviceStateReason *reason)
 
 	g_return_val_if_fail (reason != NULL, NM_ACT_STAGE_RETURN_FAILURE);
 
+	priv->ip4_waiting = FALSE;
+	priv->ip6_waiting = FALSE;
+	priv->carrier_waiting = FALSE;
+
 	ret = NM_DEVICE_CLASS (nm_device_bond_parent_class)->act_stage1_prepare (dev, reason);
 	if (ret == NM_ACT_STAGE_RETURN_SUCCESS) {
 		connection = nm_device_get_connection (dev);
@@ -304,133 +335,238 @@ real_act_stage1_prepare (NMDevice *dev, NMDeviceStateReason *reason)
 	return ret;
 }
 
-static void
-slave_state_changed (NMDevice *slave,
-                     NMDeviceState new_state,
-                     NMDeviceState old_state,
-                     NMDeviceStateReason reason,
-                     gpointer user_data)
+static gboolean
+ip_retry (gpointer user_data)
 {
-	NMDeviceBond *self = NM_DEVICE_BOND (user_data);
-	NMDeviceBondPrivate *priv = NM_DEVICE_BOND_GET_PRIVATE (self);
-	guint had_slaves;
-
-	nm_log_dbg (LOGD_DEVICE, "(%s): slave %s state change %d -> %d",
-	            nm_device_get_iface (NM_DEVICE (self)),
-	            nm_device_get_iface (slave),
-	            old_state,
-	            new_state);
-
-	had_slaves = !!priv->slaves;
-
-	if (   old_state > NM_DEVICE_STATE_DISCONNECTED
-	    && new_state <= NM_DEVICE_STATE_DISCONNECTED) {
-		/* Slave is no longer available or managed; can't use it */
-		nm_device_release_slave (NM_DEVICE (self), slave);
-	}
+	NMDevice *device = NM_DEVICE (user_data);
+	NMDeviceBondPrivate *priv = NM_DEVICE_BOND_GET_PRIVATE (device);
+	const char *iface = nm_device_get_ip_iface (device);
 
-	if (had_slaves && !priv->slaves) {
-		/* FIXME: just leave the interface up and connected without slaves? */
-		nm_log_dbg (LOGD_DEVICE, "(%s): last slave released, deactivating",
-		            nm_device_get_iface (NM_DEVICE (self)));
-		nm_device_queue_state (NM_DEVICE (self),
-		                       NM_DEVICE_STATE_DISCONNECTED,
-		                       NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED);
-	}
-}
+	priv->ip_retry_id = 0;
 
-typedef struct {
-	NMDevice *slave;
-	guint state_id;
-} SlaveInfo;
-
-static SlaveInfo *
-find_slave_info_by_device (NMDeviceBond *self, NMDevice *slave)
-{
-	NMDeviceBondPrivate *priv = NM_DEVICE_BOND_GET_PRIVATE (self);
-	GSList *iter;
+	if (nm_device_get_state (device) != NM_DEVICE_STATE_IP_CONFIG)
+		return FALSE;
 
-	for (iter = priv->slaves; iter; iter = g_slist_next (iter)) {
-		if (((SlaveInfo *) iter->data)->slave == slave)
-			return iter->data;
+	if (priv->carrier_waiting == FALSE) {
+		if (priv->ip4_waiting) {
+			nm_log_info (LOGD_DEVICE | LOGD_IP4, "(%s): retrying IPv4 config", iface);
+			priv->ip4_waiting = FALSE;
+			nm_device_activate_stage3_ip4_start (device);
+		}
+
+		if (priv->ip6_waiting) {
+			nm_log_info (LOGD_DEVICE | LOGD_IP6, "(%s): retrying IPv6 config", iface);
+			priv->ip6_waiting = FALSE;
+			nm_device_activate_stage3_ip6_start (device);
+		}
 	}
-	return NULL;
+
+	return FALSE;
 }
 
 static void
-free_slave_info (SlaveInfo *sinfo)
+ip_schedule_retry (NMDevice *device)
 {
-	g_return_if_fail (sinfo != NULL);
-	g_return_if_fail (sinfo->slave != NULL);
+	NMDeviceBondPrivate *priv = NM_DEVICE_BOND_GET_PRIVATE (device);
 
-	g_signal_handler_disconnect (sinfo->slave, sinfo->state_id);
-	g_object_unref (sinfo->slave);
-	memset (sinfo, 0, sizeof (*sinfo));
-	g_free (sinfo);
+	if (priv->ip_retry_id == 0)
+		priv->ip_retry_id = g_idle_add (ip_retry, device);
 }
 
 static gboolean
-enslave_slave (NMDevice *device, NMDevice *slave)
+enslave_slave (NMDevice *device, NMDevice *slave, NMConnection *connection)
 {
-	NMDeviceBond *self = NM_DEVICE_BOND (device);
-	NMDeviceBondPrivate *priv = NM_DEVICE_BOND_GET_PRIVATE (self);
+	const char *iface = nm_device_get_ip_iface (device);
+	const char *slave_iface = nm_device_get_ip_iface (slave);
 	gboolean success, no_firmware = FALSE;
 
-	if (find_slave_info_by_device (self, slave))
-		return TRUE;
-
 	nm_device_hw_take_down (slave, TRUE);
 
-	success = nm_system_iface_enslave (nm_device_get_ip_ifindex (device),
-	                                   nm_device_get_ip_iface (device),
-	                                   nm_device_get_ip_ifindex (slave),
-	                                   nm_device_get_ip_iface (slave));
-	if (success) {
-		SlaveInfo *sinfo;
-
-		sinfo = g_malloc0 (sizeof (*slave));
-		sinfo->slave = g_object_ref (slave);
-		sinfo->state_id = g_signal_connect (slave,
-		                                    "state-changed",
-		                                    (GCallback) slave_state_changed,
-		                                    self);
-		priv->slaves = g_slist_append (priv->slaves, sinfo);
-
-		nm_log_dbg (LOGD_DEVICE, "(%s): enslaved bond slave %s",
-			        nm_device_get_ip_iface (device),
-			        nm_device_get_ip_iface (slave));
-	}
+	success = nm_system_bond_enslave (nm_device_get_ip_ifindex (device),
+	                                  iface,
+	                                  nm_device_get_ip_ifindex (slave),
+	                                  slave_iface);
 
 	nm_device_hw_bring_up (slave, TRUE, &no_firmware);
 
+	if (success) {
+		nm_log_info (LOGD_DEVICE, "(%s): enslaved bond slave %s", iface, slave_iface);
+		g_object_notify (G_OBJECT (device), "slaves");
+
+		/* If waiting for a slave to continue with IP config, start now */
+		ip_schedule_retry (device);
+	}
+
 	return success;
 }
 
 static gboolean
 release_slave (NMDevice *device, NMDevice *slave)
 {
-	NMDeviceBond *self = NM_DEVICE_BOND (device);
-	NMDeviceBondPrivate *priv = NM_DEVICE_BOND_GET_PRIVATE (self);
-	gboolean success;
-	SlaveInfo *sinfo;
+	gboolean success, no_firmware = FALSE;
 
-	sinfo = find_slave_info_by_device (self, slave);
-	if (!sinfo)
-		return FALSE;
+	success = nm_system_bond_release (nm_device_get_ip_ifindex (device),
+	                                  nm_device_get_ip_iface (device),
+	                                  nm_device_get_ip_ifindex (slave),
+	                                  nm_device_get_ip_iface (slave));
+	nm_log_info (LOGD_DEVICE, "(%s): released bond slave %s (success %d)",
+	             nm_device_get_ip_iface (device),
+	             nm_device_get_ip_iface (slave),
+	             success);
+	g_object_notify (G_OBJECT (device), "slaves");
+
+	/* Kernel bonding code "closes" the slave when releasing it, (which clears
+	 * IFF_UP), so we must bring it back up here to ensure carrier changes and
+	 * other state is noticed by the now-released slave.
+	 */
+	if (!nm_device_hw_bring_up (slave, TRUE, &no_firmware)) {
+		nm_log_warn (LOGD_DEVICE, "(%s): released bond slave could not be brought up.",
+		             nm_device_get_iface (slave));
+	}
 
-	success = nm_system_iface_release (nm_device_get_ip_ifindex (device),
-	                                   nm_device_get_ip_iface (device),
-	                                   nm_device_get_ip_ifindex (slave),
-	                                   nm_device_get_ip_iface (slave));
-	nm_log_dbg (LOGD_DEVICE, "(%s): released bond slave %s (success %d)",
-	            nm_device_get_ip_iface (device),
-	            nm_device_get_ip_iface (slave),
-	            success);
-	priv->slaves = g_slist_remove (priv->slaves, sinfo);
-	free_slave_info (sinfo);
 	return success;
 }
 
+static void
+carrier_changed (NMDevice *device,
+                 GParamSpec *pspec,
+                 gpointer user_data)
+{
+	NMDeviceBondPrivate *priv = NM_DEVICE_BOND_GET_PRIVATE (device);
+
+	if (priv->carrier_waiting && nm_device_wired_get_carrier (NM_DEVICE_WIRED (device))) {
+		priv->carrier_waiting = FALSE;
+		ip_schedule_retry (device);
+	}
+}
+
+static gboolean
+have_any_ready_slaves (NMDevice *device)
+{
+	GSList *slaves, *iter;
+	gboolean usable = FALSE;
+
+	slaves = nm_device_master_get_slaves (device);
+	for (iter = slaves; iter; iter = g_slist_next (iter)) {
+		if (nm_device_get_enslaved (iter->data)) {
+			usable = TRUE;
+			break;
+		}
+	}
+	g_slist_free (slaves);
+
+	return usable;
+}
+
+static gboolean
+ip4_requires_slaves (NMDevice *device)
+{
+	NMConnection *connection;
+	NMSettingIP4Config *s_ip4;
+	const char *method = NULL;
+
+	connection = nm_device_get_connection (device);
+	g_assert (connection);
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	if (s_ip4)
+		method = nm_setting_ip4_config_get_method (s_ip4);
+
+	return g_strcmp0 (method, NM_SETTING_IP4_CONFIG_METHOD_AUTO) == 0;
+}
+
+static NMActStageReturn
+act_stage3_ip4_config_start (NMDevice *device, NMDeviceStateReason *reason)
+{
+	NMDeviceBondPrivate *priv = NM_DEVICE_BOND_GET_PRIVATE (device);
+
+	priv->ip4_waiting = FALSE;
+
+	if (ip4_requires_slaves (device)) {
+		if (have_any_ready_slaves (device) == FALSE) {
+			priv->ip4_waiting = TRUE;
+			nm_log_info (LOGD_DEVICE | LOGD_IP4, "(%s): IPv4 config waiting until slaves are present",
+			             nm_device_get_ip_iface (device));
+		}
+
+		if (!nm_device_wired_get_carrier (NM_DEVICE_WIRED (device))) {
+			priv->carrier_waiting = TRUE;
+			nm_log_info (LOGD_DEVICE | LOGD_IP4, "(%s): IPv4 config waiting until carrier is on",
+			             nm_device_get_ip_iface (device));
+		}
+
+		if (priv->ip4_waiting || priv->carrier_waiting)
+			return NM_ACT_STAGE_RETURN_POSTPONE;
+	}
+
+	/* Proceed with normal IPv4 configuration */
+	return NM_DEVICE_CLASS (nm_device_bond_parent_class)->act_stage3_ip4_config_start (device, reason);
+}
+
+static gboolean
+ip6_requires_slaves (NMDevice *device)
+{
+	NMConnection *connection;
+	NMSettingIP6Config *s_ip6;
+	const char *method = NULL;
+
+	connection = nm_device_get_connection (device);
+	g_assert (connection);
+
+	s_ip6 = (NMSettingIP6Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP6_CONFIG);
+	if (s_ip6)
+		method = nm_setting_ip6_config_get_method (s_ip6);
+
+	/* SLAAC, DHCP, and Link-Local depend on connectivity (and thus slaves)
+	 * to complete addressing.  SLAAC and DHCP obviously need a peer to
+	 * provide a prefix, while Link-Local must perform DAD on the local link.
+	 */
+	return    g_strcmp0 (method, NM_SETTING_IP6_CONFIG_METHOD_AUTO) == 0
+	       || g_strcmp0 (method, NM_SETTING_IP6_CONFIG_METHOD_DHCP) == 0
+	       || g_strcmp0 (method, NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL) == 0;
+}
+
+static NMActStageReturn
+act_stage3_ip6_config_start (NMDevice *device, NMDeviceStateReason *reason)
+{
+	NMDeviceBondPrivate *priv = NM_DEVICE_BOND_GET_PRIVATE (device);
+
+	priv->ip6_waiting = FALSE;
+
+	if (ip6_requires_slaves (device)) {
+		if (have_any_ready_slaves (device) == FALSE) {
+			priv->ip6_waiting = TRUE;
+			nm_log_info (LOGD_DEVICE | LOGD_IP6, "(%s): IPv6 config waiting until slaves are present",
+			             nm_device_get_ip_iface (device));
+		}
+
+		if (!nm_device_wired_get_carrier (NM_DEVICE_WIRED (device))) {
+			priv->carrier_waiting = TRUE;
+			nm_log_info (LOGD_DEVICE | LOGD_IP6, "(%s): IPv6 config waiting until carrier is on",
+			             nm_device_get_ip_iface (device));
+		}
+
+		if (priv->ip6_waiting || priv->carrier_waiting)
+			return NM_ACT_STAGE_RETURN_POSTPONE;
+	}
+
+	/* Proceed with normal IPv6 configuration */
+	return NM_DEVICE_CLASS (nm_device_bond_parent_class)->act_stage3_ip6_config_start (device, reason);
+}
+
+static void
+deactivate (NMDevice *device)
+{
+	NMDeviceBondPrivate *priv = NM_DEVICE_BOND_GET_PRIVATE (device);
+
+	priv->ip4_waiting = FALSE;
+	priv->ip6_waiting = FALSE;
+	priv->carrier_waiting = FALSE;
+
+	if (NM_DEVICE_CLASS (nm_device_bond_parent_class)->deactivate)
+		NM_DEVICE_CLASS (nm_device_bond_parent_class)->deactivate (device);
+}
+
 /******************************************************************/
 
 NMDevice *
@@ -456,6 +592,11 @@ constructed (GObject *object)
 	nm_log_dbg (LOGD_HW | LOGD_DEVICE, "(%s): kernel ifindex %d",
 	            nm_device_get_iface (NM_DEVICE (object)),
 	            nm_device_get_ifindex (NM_DEVICE (object)));
+
+	g_signal_connect (object,
+	                  "notify::" NM_DEVICE_BOND_CARRIER,
+	                  G_CALLBACK (carrier_changed),
+	                  NULL);
 }
 
 static void
@@ -469,6 +610,8 @@ get_property (GObject *object, guint prop_id,
               GValue *value, GParamSpec *pspec)
 {
 	const guint8 *current_addr;
+	GPtrArray *slaves;
+	GSList *list, *iter;
 
 	switch (prop_id) {
 	case PROP_HW_ADDRESS:
@@ -478,6 +621,14 @@ get_property (GObject *object, guint prop_id,
 	case PROP_CARRIER:
 		g_value_set_boolean (value, nm_device_wired_get_carrier (NM_DEVICE_WIRED (object)));
 		break;
+	case PROP_SLAVES:
+		slaves = g_ptr_array_new ();
+		list = nm_device_master_get_slaves (NM_DEVICE (object));
+		for (iter = list; iter; iter = iter->next)
+			g_ptr_array_add (slaves, g_strdup (nm_device_get_path (NM_DEVICE (iter->data))));
+		g_slist_free (list);
+		g_value_take_boxed (value, slaves);
+		break;
 	default:
 		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
 		break;
@@ -496,28 +647,11 @@ set_property (GObject *object, guint prop_id,
 }
 
 static void
-dispose (GObject *object)
-{
-	NMDeviceBond *self = NM_DEVICE_BOND (object);
-	NMDeviceBondPrivate *priv = NM_DEVICE_BOND_GET_PRIVATE (self);
-	GSList *iter;
-
-	if (priv->disposed) {
-		G_OBJECT_CLASS (nm_device_bond_parent_class)->dispose (object);
-		return;
-	}
-	priv->disposed = TRUE;
-
-	for (iter = priv->slaves; iter; iter = g_slist_next (iter))
-		release_slave (NM_DEVICE (self), ((SlaveInfo *) iter->data)->slave);
-	g_slist_free (priv->slaves);
-}
-
-static void
 nm_device_bond_class_init (NMDeviceBondClass *klass)
 {
 	GObjectClass *object_class = G_OBJECT_CLASS (klass);
 	NMDeviceClass *parent_class = NM_DEVICE_CLASS (klass);
+	NMDeviceWiredClass *wired_class = NM_DEVICE_WIRED_CLASS (klass);
 
 	g_type_class_add_private (object_class, sizeof (NMDeviceBondPrivate));
 
@@ -525,7 +659,6 @@ nm_device_bond_class_init (NMDeviceBondClass *klass)
 	object_class->constructed = constructed;
 	object_class->get_property = get_property;
 	object_class->set_property = set_property;
-	object_class->dispose = dispose;
 
 	parent_class->get_generic_capabilities = real_get_generic_capabilities;
 	parent_class->update_hw_address = real_update_hw_address;
@@ -537,9 +670,14 @@ nm_device_bond_class_init (NMDeviceBondClass *klass)
 	parent_class->connection_match_config = connection_match_config;
 
 	parent_class->act_stage1_prepare = real_act_stage1_prepare;
+	parent_class->act_stage3_ip4_config_start = act_stage3_ip4_config_start;
+	parent_class->act_stage3_ip6_config_start = act_stage3_ip6_config_start;
+	parent_class->deactivate = deactivate;
 	parent_class->enslave_slave = enslave_slave;
 	parent_class->release_slave = release_slave;
 
+	wired_class->carrier_action = carrier_action;
+
 	/* properties */
 	g_object_class_install_property
 		(object_class, PROP_HW_ADDRESS,
@@ -557,6 +695,14 @@ nm_device_bond_class_init (NMDeviceBondClass *klass)
 							   FALSE,
 							   G_PARAM_READABLE));
 
+	g_object_class_install_property
+		(object_class, PROP_SLAVES,
+		 g_param_spec_boxed (NM_DEVICE_BOND_SLAVES,
+		                     "Slaves",
+		                     "Slaves",
+		                     DBUS_TYPE_G_ARRAY_OF_OBJECT_PATH,
+		                     G_PARAM_READABLE));
+
 	/* Signals */
 	signals[PROPERTIES_CHANGED] =
 		nm_properties_changed_signal_new (object_class,
diff --git a/src/nm-device-bond.h b/src/nm-device-bond.h
index b431e8d..496dfae 100644
--- a/src/nm-device-bond.h
+++ b/src/nm-device-bond.h
@@ -36,6 +36,7 @@ G_BEGIN_DECLS
 
 #define NM_DEVICE_BOND_HW_ADDRESS "hw-address"
 #define NM_DEVICE_BOND_CARRIER "carrier"
+#define NM_DEVICE_BOND_SLAVES "slaves"
 
 typedef struct {
 	NMDeviceWired parent;
diff --git a/src/nm-device-bridge.c b/src/nm-device-bridge.c
new file mode 100644
index 0000000..5dba0e5
--- /dev/null
+++ b/src/nm-device-bridge.c
@@ -0,0 +1,791 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2011 - 2012 Red Hat, Inc.
+ */
+
+#include "config.h"
+
+#include <glib.h>
+#include <glib/gi18n.h>
+
+#include <netinet/ether.h>
+
+#include "nm-device-bridge.h"
+#include "nm-device-interface.h"
+#include "nm-logging.h"
+#include "nm-properties-changed-signal.h"
+#include "nm-utils.h"
+#include "NetworkManagerUtils.h"
+#include "nm-device-private.h"
+#include "nm-netlink-monitor.h"
+#include "nm-dbus-glib-types.h"
+#include "nm-system.h"
+
+#include "nm-device-bridge-glue.h"
+
+
+G_DEFINE_TYPE (NMDeviceBridge, nm_device_bridge, NM_TYPE_DEVICE_WIRED)
+
+#define NM_DEVICE_BRIDGE_GET_PRIVATE(o) (G_TYPE_INSTANCE_GET_PRIVATE ((o), NM_TYPE_DEVICE_BRIDGE, NMDeviceBridgePrivate))
+
+#define NM_BRIDGE_ERROR (nm_bridge_error_quark ())
+
+typedef struct {
+	gboolean ip4_waiting;
+	gboolean ip6_waiting;
+	gboolean carrier_waiting;
+
+	guint ip_retry_id;
+} NMDeviceBridgePrivate;
+
+enum {
+	PROPERTIES_CHANGED,
+
+	LAST_SIGNAL
+};
+
+static guint signals[LAST_SIGNAL] = { 0 };
+
+enum {
+	PROP_0,
+	PROP_HW_ADDRESS,
+	PROP_CARRIER,
+	PROP_SLAVES,
+
+	LAST_PROP
+};
+
+/******************************************************************/
+
+typedef enum {
+	NM_BRIDGE_ERROR_CONNECTION_NOT_BRIDGE = 0, /*< nick=ConnectionNotBridge >*/
+	NM_BRIDGE_ERROR_CONNECTION_INVALID,      /*< nick=ConnectionInvalid >*/
+	NM_BRIDGE_ERROR_CONNECTION_INCOMPATIBLE, /*< nick=ConnectionIncompatible >*/
+} NMBridgeError;
+
+#define NM_BRIDGE_ERROR (nm_bridge_error_quark ())
+#define NM_TYPE_BRIDGE_ERROR (nm_bridge_error_get_type ())
+
+static GQuark
+nm_bridge_error_quark (void)
+{
+	static GQuark quark = 0;
+	if (!quark)
+		quark = g_quark_from_static_string ("nm-bridge-error");
+	return quark;
+}
+
+/* This should really be standard. */
+#define ENUM_ENTRY(NAME, DESC) { NAME, "" #NAME "", DESC }
+
+static GType
+nm_bridge_error_get_type (void)
+{
+	static GType etype = 0;
+
+	if (etype == 0) {
+		static const GEnumValue values[] = {
+			/* Connection was not a bond connection. */
+			ENUM_ENTRY (NM_BRIDGE_ERROR_CONNECTION_NOT_BRIDGE, "ConnectionNotBridge"),
+			/* Connection was not a valid Bridge connection. */
+			ENUM_ENTRY (NM_BRIDGE_ERROR_CONNECTION_INVALID, "ConnectionInvalid"),
+			/* Connection does not apply to this device. */
+			ENUM_ENTRY (NM_BRIDGE_ERROR_CONNECTION_INCOMPATIBLE, "ConnectionIncompatible"),
+			{ 0, 0, 0 }
+		};
+		etype = g_enum_register_static ("NMBridgeError", values);
+	}
+	return etype;
+}
+
+/******************************************************************/
+
+static void
+device_state_changed (NMDevice *device,
+                      NMDeviceState new_state,
+                      NMDeviceState old_state,
+                      NMDeviceStateReason reason,
+                      gpointer user_data)
+{
+	NMDeviceBridgePrivate *priv = NM_DEVICE_BRIDGE_GET_PRIVATE (device);
+
+	if (new_state != NM_DEVICE_STATE_IP_CONFIG) {
+		if (priv->ip_retry_id) {
+			g_source_remove (priv->ip_retry_id);
+			priv->ip_retry_id = 0;
+		}
+	}
+}
+
+static void
+carrier_action (NMDeviceWired *self, NMDeviceState state, gboolean carrier)
+{
+	/* Bridge carrier state follows IFF_UP with no ports, and port carrier
+	 * states when ports are added.  Thus carrier isn't useful when deciding
+	 * to auto-activate the bridge master.  Also, like bond masters, when the
+	 * carrier state changes due to slave changes, we shouldn't deactivate the
+	 * bridge since the user may be reconfiguring ports.
+	 *
+	 * For these reasons, carrier changes are effectively ignored by overriding
+	 * the parent class' carrier handling and doing nothing.
+	 */
+}
+
+static void
+update_hw_address (NMDevice *dev)
+{
+	const guint8 *hw_addr;
+	guint8 old_addr[NM_UTILS_HWADDR_LEN_MAX];
+	int addrtype, addrlen;
+
+	addrtype = nm_device_wired_get_hwaddr_type (NM_DEVICE_WIRED (dev));
+	g_assert (addrtype >= 0);
+	addrlen = nm_utils_hwaddr_len (addrtype);
+	g_assert (addrlen > 0);
+
+	hw_addr = nm_device_wired_get_hwaddr (NM_DEVICE_WIRED (dev));
+	memcpy (old_addr, hw_addr, addrlen);
+
+	NM_DEVICE_CLASS (nm_device_bridge_parent_class)->update_hw_address (dev);
+
+	hw_addr = nm_device_wired_get_hwaddr (NM_DEVICE_WIRED (dev));
+	if (memcmp (old_addr, hw_addr, addrlen))
+		g_object_notify (G_OBJECT (dev), NM_DEVICE_BRIDGE_HW_ADDRESS);
+}
+
+static guint32
+get_generic_capabilities (NMDevice *dev)
+{
+	return NM_DEVICE_CAP_CARRIER_DETECT | NM_DEVICE_CAP_NM_SUPPORTED;
+}
+
+static gboolean
+is_available (NMDevice *dev)
+{
+	if (NM_DEVICE_GET_CLASS (dev)->hw_is_up)
+		return NM_DEVICE_GET_CLASS (dev)->hw_is_up (dev);
+	return FALSE;
+}
+
+static gboolean
+match_bridge_connection (NMDevice *device, NMConnection *connection, GError **error)
+{
+	const char *iface;
+	NMSettingBridge *s_bridge;
+
+	s_bridge = nm_connection_get_setting_bridge (connection);
+	if (!s_bridge || !nm_connection_is_type (connection, NM_SETTING_BRIDGE_SETTING_NAME)) {
+		g_set_error (error, NM_BRIDGE_ERROR, NM_BRIDGE_ERROR_CONNECTION_NOT_BRIDGE,
+		             "The connection was not a bridge connection.");
+		return FALSE;
+	}
+
+	/* Bridge connections must specify the virtual interface name */
+	iface = nm_connection_get_virtual_iface_name (connection);
+	if (!iface || strcmp (nm_device_get_iface (device), iface)) {
+		g_set_error (error, NM_BRIDGE_ERROR, NM_BRIDGE_ERROR_CONNECTION_INVALID,
+		             "The bridge connection virtual interface name did not match.");
+		return FALSE;
+	}
+
+	return TRUE;
+}
+
+static NMConnection *
+get_best_auto_connection (NMDevice *dev,
+                          GSList *connections,
+                          char **specific_object)
+{
+	GSList *iter;
+
+	for (iter = connections; iter; iter = g_slist_next (iter)) {
+		NMConnection *connection = NM_CONNECTION (iter->data);
+		NMSettingConnection *s_con;
+
+		s_con = nm_connection_get_setting_connection (connection);
+		g_assert (s_con);
+		if (   nm_setting_connection_get_autoconnect (s_con)
+		    && match_bridge_connection (dev, connection, NULL))
+			return connection;
+	}
+	return NULL;
+}
+
+static gboolean
+check_connection_compatible (NMDevice *device,
+                             NMConnection *connection,
+                             GError **error)
+{
+	return match_bridge_connection (device, connection, error);
+}
+
+static gboolean
+spec_match_list (NMDevice *device, const GSList *specs)
+{
+	char *hwaddr;
+	gboolean matched;
+
+	hwaddr = nm_utils_hwaddr_ntoa (nm_device_wired_get_hwaddr (NM_DEVICE_WIRED (device)), ARPHRD_ETHER);
+	matched = nm_match_spec_hwaddr (specs, hwaddr);
+	g_free (hwaddr);
+
+	return matched;
+}
+
+static gboolean
+bridge_match_config (NMDevice *self, NMConnection *connection)
+{
+	NMSettingBridge *s_bridge;
+	const char *ifname;
+
+	s_bridge = nm_connection_get_setting_bridge (connection);
+	if (!s_bridge)
+		return FALSE;
+
+	/* Interface name */
+	ifname = nm_setting_bridge_get_interface_name (s_bridge);
+	if (g_strcmp0 (ifname, nm_device_get_ip_iface (self)) != 0)
+		return FALSE;
+
+	return TRUE;
+}
+
+static NMConnection *
+connection_match_config (NMDevice *self, const GSList *connections)
+{
+	const GSList *iter;
+	GSList *bridge_matches;
+	NMConnection *match;
+
+	/* First narrow @connections down to those that match in their
+	 * NMSettingBridge configuration.
+	 */
+	bridge_matches = NULL;
+	for (iter = connections; iter; iter = iter->next) {
+		NMConnection *candidate = NM_CONNECTION (iter->data);
+
+		if (!nm_connection_is_type (candidate, NM_SETTING_BRIDGE_SETTING_NAME))
+			continue;
+		if (!bridge_match_config (self, candidate))
+			continue;
+
+		bridge_matches = g_slist_prepend (bridge_matches, candidate);
+	}
+
+	/* Now pass those to the super method, which will check IP config */
+	bridge_matches = g_slist_reverse (bridge_matches);
+	match = NM_DEVICE_CLASS (nm_device_bridge_parent_class)->connection_match_config (self, bridge_matches);
+	g_slist_free (bridge_matches);
+
+	return match;
+}
+
+/******************************************************************/
+
+static void
+set_sysfs_uint (const char *iface,
+                GObject *obj,
+                const char *obj_prop,
+                const char *dir,
+                const char *sysfs_prop,
+                gboolean default_if_zero,
+                gboolean user_hz_compensate)
+{
+	char *path, *s;
+	GParamSpec *pspec;
+	GValue val = { 0 };
+	guint32 uval = 0;
+
+	pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (obj), obj_prop);
+	g_return_if_fail (pspec != NULL);
+
+	/* Get the property's value */
+	g_value_init (&val, G_PARAM_SPEC_VALUE_TYPE (pspec));
+	g_object_get_property (obj, obj_prop, &val);
+	if (G_VALUE_HOLDS_BOOLEAN (&val))
+		uval = g_value_get_boolean (&val) ? 1 : 0;
+	else if (G_VALUE_HOLDS_UINT (&val)) {
+		uval = g_value_get_uint (&val);
+
+		/* zero means "unspecified" for some NM properties but isn't in the
+		 * allowed kernel range, so reset the property to the default value.
+		 */
+		if (default_if_zero && uval == 0) {
+			g_value_unset (&val);
+			g_value_init (&val, G_PARAM_SPEC_VALUE_TYPE (pspec));
+			g_param_value_set_default (pspec, &val);
+			uval = g_value_get_uint (&val);
+		}
+	} else
+		g_assert_not_reached ();
+
+	g_value_unset (&val);
+
+	/* Linux kernel bridge interfaces use 'centiseconds' for time-based values.
+	 * In reality it's not centiseconds, but depends on HZ and USER_HZ, which
+	 * is almost always works out to be a multiplier of 100, so we can assume
+	 * centiseconds.  See clock_t_to_jiffies().
+	 */
+	if (user_hz_compensate)
+		uval *= 100;
+
+	path = g_strdup_printf ("/sys/class/net/%s/%s/%s", iface, dir, sysfs_prop);
+	s = g_strdup_printf ("%u", uval);
+	/* FIXME: how should failure be handled? */
+	nm_utils_do_sysctl (path, s);
+	g_free (path);
+	g_free (s);
+}
+
+static NMActStageReturn
+act_stage1_prepare (NMDevice *dev, NMDeviceStateReason *reason)
+{
+	NMDeviceBridgePrivate *priv = NM_DEVICE_BRIDGE_GET_PRIVATE (dev);
+	NMActStageReturn ret = NM_ACT_STAGE_RETURN_SUCCESS;
+	NMConnection *connection;
+	NMSettingBridge *s_bridge;
+	const char *iface;
+
+	g_return_val_if_fail (reason != NULL, NM_ACT_STAGE_RETURN_FAILURE);
+
+	priv->ip4_waiting = FALSE;
+	priv->ip6_waiting = FALSE;
+	priv->carrier_waiting = FALSE;
+
+	ret = NM_DEVICE_CLASS (nm_device_bridge_parent_class)->act_stage1_prepare (dev, reason);
+	if (ret == NM_ACT_STAGE_RETURN_SUCCESS) {
+		connection = nm_device_get_connection (dev);
+		g_assert (connection);
+
+		s_bridge = nm_connection_get_setting_bridge (connection);
+		g_assert (s_bridge);
+
+		iface = nm_device_get_ip_iface (dev);
+		g_assert (iface);
+
+		set_sysfs_uint (iface, G_OBJECT (s_bridge), NM_SETTING_BRIDGE_STP, "bridge", "stp_state", FALSE, FALSE);
+		set_sysfs_uint (iface, G_OBJECT (s_bridge), NM_SETTING_BRIDGE_PRIORITY, "bridge", "priority", TRUE, FALSE);
+		set_sysfs_uint (iface, G_OBJECT (s_bridge), NM_SETTING_BRIDGE_FORWARD_DELAY, "bridge", "forward_delay", TRUE, TRUE);
+		set_sysfs_uint (iface, G_OBJECT (s_bridge), NM_SETTING_BRIDGE_HELLO_TIME, "bridge", "hello_time", TRUE, TRUE);
+		set_sysfs_uint (iface, G_OBJECT (s_bridge), NM_SETTING_BRIDGE_MAX_AGE, "bridge", "max_age", TRUE, TRUE);
+		set_sysfs_uint (iface, G_OBJECT (s_bridge), NM_SETTING_BRIDGE_AGEING_TIME, "bridge", "ageing_time", TRUE, TRUE);
+	}
+	return ret;
+}
+
+static gboolean
+ip_retry (gpointer user_data)
+{
+	NMDevice *device = NM_DEVICE (user_data);
+	NMDeviceBridgePrivate *priv = NM_DEVICE_BRIDGE_GET_PRIVATE (device);
+	const char *iface = nm_device_get_ip_iface (device);
+
+	priv->ip_retry_id = 0;
+
+	if (nm_device_get_state (device) != NM_DEVICE_STATE_IP_CONFIG)
+		return FALSE;
+
+	if (priv->carrier_waiting == FALSE) {
+		if (priv->ip4_waiting) {
+			nm_log_dbg (LOGD_DEVICE | LOGD_IP4, "(%s): retrying IPv4 config", iface);
+			priv->ip4_waiting = FALSE;
+			nm_device_activate_stage3_ip4_start (device);
+		}
+
+		if (priv->ip6_waiting) {
+			nm_log_dbg (LOGD_DEVICE | LOGD_IP6, "(%s): retrying IPv6 config", iface);
+			priv->ip6_waiting = FALSE;
+			nm_device_activate_stage3_ip6_start (device);
+		}
+	}
+
+	return FALSE;
+}
+
+static void
+ip_schedule_retry (NMDevice *device, guint seconds)
+{
+	NMDeviceBridgePrivate *priv = NM_DEVICE_BRIDGE_GET_PRIVATE (device);
+
+	if (priv->ip_retry_id == 0) {
+		if (seconds)
+			priv->ip_retry_id = g_timeout_add_seconds (seconds, ip_retry, device);
+		else
+			priv->ip_retry_id = g_idle_add (ip_retry, device);
+	}
+}
+
+static gboolean
+enslave_slave (NMDevice *device, NMDevice *slave, NMConnection *connection)
+{
+	gboolean success;
+	NMSettingBridgePort *s_port;
+	const char *iface = nm_device_get_ip_iface (device);
+	const char *slave_iface = nm_device_get_ip_iface (slave);
+
+	success = nm_system_bridge_attach (nm_device_get_ip_ifindex (device),
+	                                   iface,
+	                                   nm_device_get_ip_ifindex (slave),
+	                                   slave_iface);
+	if (!success)
+		return FALSE;
+
+	/* Set port properties */
+	s_port = nm_connection_get_setting_bridge_port (connection);
+	if (s_port) {
+		set_sysfs_uint (slave_iface, G_OBJECT (s_port), NM_SETTING_BRIDGE_PORT_PRIORITY, "brport", "priority", TRUE, FALSE);
+		set_sysfs_uint (slave_iface, G_OBJECT (s_port), NM_SETTING_BRIDGE_PORT_PATH_COST, "brport", "path_cost", TRUE, FALSE);
+		set_sysfs_uint (slave_iface, G_OBJECT (s_port), NM_SETTING_BRIDGE_PORT_HAIRPIN_MODE, "brport", "hairpin_mode", FALSE, FALSE);
+	}
+	nm_log_info (LOGD_DEVICE, "(%s): attached bridge port %s", iface, slave_iface);
+	g_object_notify (G_OBJECT (device), NM_DEVICE_BRIDGE_SLAVES);
+
+	ip_schedule_retry (device, 0);
+
+	return TRUE;
+}
+
+static gboolean
+release_slave (NMDevice *device, NMDevice *slave)
+{
+	gboolean success;
+
+	success = nm_system_bridge_detach (nm_device_get_ip_ifindex (device),
+	                                   nm_device_get_ip_iface (device),
+	                                   nm_device_get_ip_ifindex (slave),
+	                                   nm_device_get_ip_iface (slave));
+	nm_log_info (LOGD_DEVICE, "(%s): detached bridge port %s (success %d)",
+	             nm_device_get_ip_iface (device),
+	             nm_device_get_ip_iface (slave),
+	             success);
+	g_object_notify (G_OBJECT (device), NM_DEVICE_BRIDGE_SLAVES);
+	return success;
+}
+
+static void
+carrier_changed (NMDevice *device,
+                 GParamSpec *pspec,
+                 gpointer user_data)
+{
+	NMDeviceBridgePrivate *priv = NM_DEVICE_BRIDGE_GET_PRIVATE (device);
+
+	if (priv->carrier_waiting && nm_device_wired_get_carrier (NM_DEVICE_WIRED (device))) {
+		priv->carrier_waiting = FALSE;
+		ip_schedule_retry (device, 0);
+	}
+}
+
+static gboolean
+have_any_ready_slaves (NMDevice *device)
+{
+	GSList *slaves, *iter;
+	gboolean usable = FALSE;
+
+	slaves = nm_device_master_get_slaves (device);
+	for (iter = slaves; iter && !usable; iter = g_slist_next (iter)) {
+		NMDevice *slave = NM_DEVICE (iter->data);
+		char *contents = NULL, *path;
+
+		/* Make sure the port is actually enslaved and not just waiting */
+		if (nm_device_get_enslaved (slave) == FALSE)
+			continue;
+
+		/* And that it's in forwarding state */
+		path = g_strdup_printf ("/sys/class/net/%s/brport/state", nm_device_get_iface (slave));
+		if (g_file_get_contents (path, &contents, NULL, NULL) && contents) {
+			contents = g_strstrip (contents);
+			nm_log_dbg (LOGD_DEVICE, "(%s): port %s state '%s'",
+			            nm_device_get_ip_iface (device),
+			            nm_device_get_ip_iface (slave),
+			            contents);
+			/* 3 == BR_STATE_FORWARDING */
+			usable = (contents[0] == '3');
+		} else {
+			/* Assume the port is ready if we can't read 'state' */
+			nm_log_dbg (LOGD_DEVICE, "(%s): port %s state fetch error; assuming ready",
+			            nm_device_get_ip_iface (device),
+			            nm_device_get_ip_iface (slave));
+			usable = TRUE;
+		}
+		g_free (contents);
+		g_free (path);
+	}
+	g_slist_free (slaves);
+
+	return usable;
+}
+
+static gboolean
+ip4_requires_slaves (NMDevice *device)
+{
+	NMConnection *connection;
+	NMSettingIP4Config *s_ip4;
+	const char *method = NULL;
+
+	connection = nm_device_get_connection (device);
+	g_assert (connection);
+
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	if (s_ip4)
+		method = nm_setting_ip4_config_get_method (s_ip4);
+
+	return g_strcmp0 (method, NM_SETTING_IP4_CONFIG_METHOD_AUTO) == 0;
+}
+
+static NMActStageReturn
+act_stage3_ip4_config_start (NMDevice *device, NMDeviceStateReason *reason)
+{
+	NMDeviceBridgePrivate *priv = NM_DEVICE_BRIDGE_GET_PRIVATE (device);
+
+	priv->ip4_waiting = FALSE;
+
+	if (ip4_requires_slaves (device)) {
+		if (have_any_ready_slaves (device) == FALSE) {
+			priv->ip4_waiting = TRUE;
+			nm_log_info (LOGD_DEVICE | LOGD_IP4, "(%s): IPv4 config waiting until slaves are present and forwarding",
+			             nm_device_get_ip_iface (device));
+		}
+
+		if (!nm_device_wired_get_carrier (NM_DEVICE_WIRED (device))) {
+			priv->carrier_waiting = TRUE;
+			nm_log_info (LOGD_DEVICE | LOGD_IP4, "(%s): IPv4 config waiting until carrier is on",
+			             nm_device_get_ip_iface (device));
+		}
+
+		if (priv->ip4_waiting || priv->carrier_waiting) {
+			ip_schedule_retry (device, 3);
+			return NM_ACT_STAGE_RETURN_POSTPONE;
+		}
+	}
+
+	/* Proceed with normal IPv4 configuration */
+	return NM_DEVICE_CLASS (nm_device_bridge_parent_class)->act_stage3_ip4_config_start (device, reason);
+}
+
+static gboolean
+ip6_requires_slaves (NMDevice *device)
+{
+	NMConnection *connection;
+	NMSettingIP6Config *s_ip6;
+	const char *method = NULL;
+
+	connection = nm_device_get_connection (device);
+	g_assert (connection);
+
+	s_ip6 = (NMSettingIP6Config *) nm_connection_get_setting (connection, NM_TYPE_SETTING_IP6_CONFIG);
+	if (s_ip6)
+		method = nm_setting_ip6_config_get_method (s_ip6);
+
+	/* SLAAC, DHCP, and Link-Local depend on connectivity (and thus slaves)
+	 * to complete addressing.  SLAAC and DHCP obviously need a peer to
+	 * provide a prefix, while Link-Local must perform DAD on the local link.
+	 */
+	return    g_strcmp0 (method, NM_SETTING_IP6_CONFIG_METHOD_AUTO) == 0
+	       || g_strcmp0 (method, NM_SETTING_IP6_CONFIG_METHOD_DHCP) == 0
+	       || g_strcmp0 (method, NM_SETTING_IP6_CONFIG_METHOD_LINK_LOCAL) == 0;
+}
+
+static NMActStageReturn
+act_stage3_ip6_config_start (NMDevice *device, NMDeviceStateReason *reason)
+{
+	NMDeviceBridgePrivate *priv = NM_DEVICE_BRIDGE_GET_PRIVATE (device);
+
+	priv->ip6_waiting = FALSE;
+
+	if (ip6_requires_slaves (device)) {
+		if (have_any_ready_slaves (device) == FALSE) {
+			priv->ip6_waiting = TRUE;
+			nm_log_info (LOGD_DEVICE | LOGD_IP6, "(%s): IPv6 config waiting until slaves are present and forwarding",
+			             nm_device_get_ip_iface (device));
+		}
+
+		if (!nm_device_wired_get_carrier (NM_DEVICE_WIRED (device))) {
+			priv->carrier_waiting = TRUE;
+			nm_log_info (LOGD_DEVICE | LOGD_IP6, "(%s): IPv6 config waiting until carrier is on",
+			             nm_device_get_ip_iface (device));
+		}
+
+		if (priv->ip6_waiting || priv->carrier_waiting) {
+			ip_schedule_retry (device, 3);
+			return NM_ACT_STAGE_RETURN_POSTPONE;
+		}
+	}
+
+	/* Proceed with normal IPv6 configuration */
+	return NM_DEVICE_CLASS (nm_device_bridge_parent_class)->act_stage3_ip6_config_start (device, reason);
+}
+
+static void
+deactivate (NMDevice *device)
+{
+	NMDeviceBridgePrivate *priv = NM_DEVICE_BRIDGE_GET_PRIVATE (device);
+
+	priv->ip4_waiting = FALSE;
+	priv->ip6_waiting = FALSE;
+	priv->carrier_waiting = FALSE;
+
+	if (NM_DEVICE_CLASS (nm_device_bridge_parent_class)->deactivate)
+		NM_DEVICE_CLASS (nm_device_bridge_parent_class)->deactivate (device);
+}
+
+/******************************************************************/
+
+NMDevice *
+nm_device_bridge_new (const char *udi, const char *iface)
+{
+	g_return_val_if_fail (udi != NULL, NULL);
+	g_return_val_if_fail (iface != NULL, NULL);
+
+	return (NMDevice *) g_object_new (NM_TYPE_DEVICE_BRIDGE,
+	                                  NM_DEVICE_INTERFACE_UDI, udi,
+	                                  NM_DEVICE_INTERFACE_IFACE, iface,
+	                                  NM_DEVICE_INTERFACE_DRIVER, "bridge",
+	                                  NM_DEVICE_INTERFACE_TYPE_DESC, "Bridge",
+	                                  NM_DEVICE_INTERFACE_DEVICE_TYPE, NM_DEVICE_TYPE_BRIDGE,
+	                                  NULL);
+}
+
+static void
+constructed (GObject *object)
+{
+	G_OBJECT_CLASS (nm_device_bridge_parent_class)->constructed (object);
+
+	nm_log_dbg (LOGD_HW | LOGD_DEVICE, "(%s): kernel ifindex %d",
+	            nm_device_get_iface (NM_DEVICE (object)),
+	            nm_device_get_ifindex (NM_DEVICE (object)));
+
+	g_signal_connect (object,
+	                  "notify::" NM_DEVICE_BRIDGE_CARRIER,
+	                  G_CALLBACK (carrier_changed),
+	                  NULL);
+}
+
+static void
+nm_device_bridge_init (NMDeviceBridge * self)
+{
+	g_signal_connect (self, "state-changed", G_CALLBACK (device_state_changed), NULL);
+}
+
+static void
+get_property (GObject *object, guint prop_id,
+              GValue *value, GParamSpec *pspec)
+{
+	const guint8 *current_addr;
+	GPtrArray *slaves;
+	GSList *list, *iter;
+
+	switch (prop_id) {
+	case PROP_HW_ADDRESS:
+		current_addr = nm_device_wired_get_hwaddr (NM_DEVICE_WIRED (object));
+		g_value_take_string (value, nm_utils_hwaddr_ntoa (current_addr, ARPHRD_ETHER));
+		break;
+	case PROP_CARRIER:
+		g_value_set_boolean (value, nm_device_wired_get_carrier (NM_DEVICE_WIRED (object)));
+		break;
+	case PROP_SLAVES:
+		slaves = g_ptr_array_new ();
+		list = nm_device_master_get_slaves (NM_DEVICE (object));
+		for (iter = list; iter; iter = iter->next)
+			g_ptr_array_add (slaves, g_strdup (nm_device_get_path (NM_DEVICE (iter->data))));
+		g_slist_free (list);
+		g_value_take_boxed (value, slaves);
+		break;
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+set_property (GObject *object, guint prop_id,
+			  const GValue *value, GParamSpec *pspec)
+{
+	switch (prop_id) {
+	default:
+		G_OBJECT_WARN_INVALID_PROPERTY_ID (object, prop_id, pspec);
+		break;
+	}
+}
+
+static void
+nm_device_bridge_class_init (NMDeviceBridgeClass *klass)
+{
+	GObjectClass *object_class = G_OBJECT_CLASS (klass);
+	NMDeviceClass *parent_class = NM_DEVICE_CLASS (klass);
+	NMDeviceWiredClass *wired_class = NM_DEVICE_WIRED_CLASS (klass);
+
+	g_type_class_add_private (object_class, sizeof (NMDeviceBridgePrivate));
+
+	/* virtual methods */
+	object_class->constructed = constructed;
+	object_class->get_property = get_property;
+	object_class->set_property = set_property;
+
+	parent_class->get_generic_capabilities = get_generic_capabilities;
+	parent_class->update_hw_address = update_hw_address;
+	parent_class->is_available = is_available;
+	parent_class->get_best_auto_connection = get_best_auto_connection;
+	parent_class->check_connection_compatible = check_connection_compatible;
+
+	parent_class->spec_match_list = spec_match_list;
+	parent_class->connection_match_config = connection_match_config;
+
+	parent_class->act_stage1_prepare = act_stage1_prepare;
+	parent_class->act_stage3_ip4_config_start = act_stage3_ip4_config_start;
+	parent_class->act_stage3_ip6_config_start = act_stage3_ip6_config_start;
+	parent_class->deactivate = deactivate;
+	parent_class->enslave_slave = enslave_slave;
+	parent_class->release_slave = release_slave;
+
+	wired_class->carrier_action = carrier_action;
+
+	/* properties */
+	g_object_class_install_property
+		(object_class, PROP_HW_ADDRESS,
+		 g_param_spec_string (NM_DEVICE_BRIDGE_HW_ADDRESS,
+							  "Active MAC Address",
+							  "Currently set hardware MAC address",
+							  NULL,
+							  G_PARAM_READABLE));
+
+	g_object_class_install_property
+		(object_class, PROP_CARRIER,
+		 g_param_spec_boolean (NM_DEVICE_BRIDGE_CARRIER,
+							   "Carrier",
+							   "Carrier",
+							   FALSE,
+							   G_PARAM_READABLE));
+
+	g_object_class_install_property
+		(object_class, PROP_SLAVES,
+		 g_param_spec_boxed (NM_DEVICE_BRIDGE_SLAVES,
+		                     "Slaves",
+		                     "Slaves",
+		                     DBUS_TYPE_G_ARRAY_OF_OBJECT_PATH,
+		                     G_PARAM_READABLE));
+
+	/* Signals */
+	signals[PROPERTIES_CHANGED] =
+		nm_properties_changed_signal_new (object_class,
+										  G_STRUCT_OFFSET (NMDeviceBridgeClass, properties_changed));
+
+	dbus_g_object_type_install_info (G_TYPE_FROM_CLASS (klass),
+									 &dbus_glib_nm_device_bridge_object_info);
+
+	dbus_g_error_domain_register (NM_BRIDGE_ERROR, NULL, NM_TYPE_BRIDGE_ERROR);
+}
diff --git a/src/nm-device-bridge.h b/src/nm-device-bridge.h
new file mode 100644
index 0000000..4ac27d5
--- /dev/null
+++ b/src/nm-device-bridge.h
@@ -0,0 +1,60 @@
+/* -*- Mode: C; tab-width: 4; indent-tabs-mode: t; c-basic-offset: 4 -*- */
+/* NetworkManager -- Network link manager
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License along
+ * with this program; if not, write to the Free Software Foundation, Inc.,
+ * 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.
+ *
+ * Copyright 2012 Red Hat, Inc.
+ */
+
+#ifndef NM_DEVICE_BRIDGE_H
+#define NM_DEVICE_BRIDGE_H
+
+#include <glib-object.h>
+
+#include "nm-device-wired.h"
+
+G_BEGIN_DECLS
+
+#define NM_TYPE_DEVICE_BRIDGE            (nm_device_bridge_get_type ())
+#define NM_DEVICE_BRIDGE(obj)            (G_TYPE_CHECK_INSTANCE_CAST ((obj), NM_TYPE_DEVICE_BRIDGE, NMDeviceBridge))
+#define NM_DEVICE_BRIDGE_CLASS(klass)    (G_TYPE_CHECK_CLASS_CAST ((klass),  NM_TYPE_DEVICE_BRIDGE, NMDeviceBridgeClass))
+#define NM_IS_DEVICE_BRIDGE(obj)         (G_TYPE_CHECK_INSTANCE_TYPE ((obj), NM_TYPE_DEVICE_BRIDGE))
+#define NM_IS_DEVICE_BRIDGE_CLASS(klass) (G_TYPE_CHECK_CLASS_TYPE ((klass),  NM_TYPE_DEVICE_BRIDGE))
+#define NM_DEVICE_BRIDGE_GET_CLASS(obj)  (G_TYPE_INSTANCE_GET_CLASS ((obj),  NM_TYPE_DEVICE_BRIDGE, NMDeviceBridgeClass))
+
+#define NM_DEVICE_BRIDGE_HW_ADDRESS "hw-address"
+#define NM_DEVICE_BRIDGE_CARRIER "carrier"
+#define NM_DEVICE_BRIDGE_SLAVES "slaves"
+
+typedef struct {
+	NMDeviceWired parent;
+} NMDeviceBridge;
+
+typedef struct {
+	NMDeviceWiredClass parent;
+
+	/* Signals */
+	void (*properties_changed) (NMDeviceBridge *device, GHashTable *properties);
+} NMDeviceBridgeClass;
+
+
+GType nm_device_bridge_get_type (void);
+
+NMDevice *nm_device_bridge_new (const char *udi,
+                                const char *iface);
+
+G_END_DECLS
+
+#endif	/* NM_DEVICE_BRIDGE_H */
diff --git a/src/nm-device-infiniband.c b/src/nm-device-infiniband.c
index 45a824f..14b1424 100644
--- a/src/nm-device-infiniband.c
+++ b/src/nm-device-infiniband.c
@@ -222,7 +222,7 @@ real_act_stage1_prepare (NMDevice *dev, NMDeviceStateReason *reason)
 	NMConnection *connection;
 	NMSettingInfiniband *s_infiniband;
 	const char *transport_mode;
-	char *mode_path, *mode_value;
+	char *mode_path;
 	gboolean set_mode;
 
 	g_return_val_if_fail (reason != NULL, NM_ACT_STAGE_RETURN_FAILURE);
@@ -250,9 +250,7 @@ real_act_stage1_prepare (NMDevice *dev, NMDeviceStateReason *reason)
 		}
 	}
 
-	mode_value = g_strdup_printf ("%s\n", transport_mode);
-	set_mode = nm_utils_do_sysctl (mode_path, mode_value);
-	g_free (mode_value);
+	set_mode = nm_utils_do_sysctl (mode_path, transport_mode);
 	g_free (mode_path);
 
 	if (!set_mode) {
diff --git a/src/nm-device-interface.c b/src/nm-device-interface.c
index c8f8e38..32618d3 100644
--- a/src/nm-device-interface.c
+++ b/src/nm-device-interface.c
@@ -293,18 +293,15 @@ nm_device_interface_check_connection_compatible (NMDeviceInterface *device,
 	return TRUE;
 }
 
-gboolean
-nm_device_interface_activate (NMDeviceInterface *device,
-                              NMActRequest *req,
-                              GError **error)
+void
+nm_device_interface_activate (NMDeviceInterface *device, NMActRequest *req)
 {
-	gboolean success;
 	NMConnection *connection;
 	NMSettingConnection *s_con;
 	char *iface;
 
-	g_return_val_if_fail (NM_IS_DEVICE_INTERFACE (device), FALSE);
-	g_return_val_if_fail (NM_IS_ACT_REQUEST (req), FALSE);
+	g_return_if_fail (NM_IS_DEVICE_INTERFACE (device));
+	g_return_if_fail (NM_IS_ACT_REQUEST (req));
 
 	connection = nm_act_request_get_connection (req);
 	g_assert (connection);
@@ -316,11 +313,7 @@ nm_device_interface_activate (NMDeviceInterface *device,
 			     nm_setting_connection_get_id (s_con));
 	g_free (iface);
 
-	success = NM_DEVICE_INTERFACE_GET_INTERFACE (device)->activate (device, req, error);
-	if (!success)
-		g_assert (*error);
-
-	return success;
+	NM_DEVICE_INTERFACE_GET_INTERFACE (device)->activate (device, req);
 }
 
 gboolean
diff --git a/src/nm-device-interface.h b/src/nm-device-interface.h
index 0d8772d..0b8134b 100644
--- a/src/nm-device-interface.h
+++ b/src/nm-device-interface.h
@@ -98,9 +98,7 @@ struct _NMDeviceInterface {
 	                                         NMConnection *connection,
 	                                         GError **error);
 
-	gboolean (*activate) (NMDeviceInterface *device,
-	                      NMActRequest *req,
-	                      GError **error);
+	void (*activate) (NMDeviceInterface *device, NMActRequest *req);
 
 	void (*deactivate) (NMDeviceInterface *device, NMDeviceStateReason reason);
 	gboolean (*disconnect) (NMDeviceInterface *device, GError **error);
@@ -131,9 +129,7 @@ gboolean nm_device_interface_check_connection_compatible (NMDeviceInterface *dev
                                                           NMConnection *connection,
                                                           GError **error);
 
-gboolean nm_device_interface_activate (NMDeviceInterface *device,
-				       NMActRequest *req,
-				       GError **error);
+void nm_device_interface_activate (NMDeviceInterface *device, NMActRequest *req);
 
 void nm_device_interface_deactivate (NMDeviceInterface *device, NMDeviceStateReason reason);
 
diff --git a/src/nm-device-private.h b/src/nm-device-private.h
index c55f13c..79e2870 100644
--- a/src/nm-device-private.h
+++ b/src/nm-device-private.h
@@ -47,4 +47,7 @@ gboolean nm_device_get_firmware_missing (NMDevice *self);
 void nm_device_set_firmware_missing (NMDevice *self, gboolean missing);
 
 gboolean nm_device_match_ip_config (NMDevice *device, NMConnection *connection);
+
+gboolean nm_device_get_enslaved (NMDevice *device);
+
 #endif	/* NM_DEVICE_PRIVATE_H */
diff --git a/src/nm-device-wired.c b/src/nm-device-wired.c
index 02a235b..5f1cddb 100644
--- a/src/nm-device-wired.c
+++ b/src/nm-device-wired.c
@@ -70,24 +70,32 @@ carrier_action_defer_clear (NMDeviceWired *self)
 	}
 }
 
+static void
+carrier_action (NMDeviceWired *self, NMDeviceState state, gboolean carrier)
+{
+	NMDevice *device = NM_DEVICE (self);
+
+	if (state == NM_DEVICE_STATE_UNAVAILABLE) {
+		if (carrier)
+			nm_device_queue_state (device, NM_DEVICE_STATE_DISCONNECTED, NM_DEVICE_STATE_REASON_CARRIER);
+	} else if (state >= NM_DEVICE_STATE_DISCONNECTED) {
+		if (   !carrier
+		    && !nm_device_is_available (NM_DEVICE (self))
+		    && !nm_device_get_enslaved (NM_DEVICE (self)))
+			nm_device_queue_state (device, NM_DEVICE_STATE_UNAVAILABLE, NM_DEVICE_STATE_REASON_CARRIER);
+	}
+}
+
 static gboolean
 carrier_action_defer_cb (gpointer user_data)
 {
 	NMDeviceWired *self = NM_DEVICE_WIRED (user_data);
 	NMDeviceWiredPrivate *priv = NM_DEVICE_WIRED_GET_PRIVATE (self);
-	NMDeviceState state;
 
 	priv->carrier_action_defer_id = 0;
-
-	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (self));
-	if (state == NM_DEVICE_STATE_UNAVAILABLE) {
-		if (priv->carrier)
-			nm_device_queue_state (NM_DEVICE (self), NM_DEVICE_STATE_DISCONNECTED, NM_DEVICE_STATE_REASON_CARRIER);
-	} else if (state >= NM_DEVICE_STATE_DISCONNECTED) {
-		if (!priv->carrier && !nm_device_is_available (NM_DEVICE (self)))
-			nm_device_queue_state (NM_DEVICE (self), NM_DEVICE_STATE_UNAVAILABLE, NM_DEVICE_STATE_REASON_CARRIER);
-	}
-
+	NM_DEVICE_WIRED_GET_CLASS (self)->carrier_action (self,
+	                                                  nm_device_get_state (NM_DEVICE (self)),
+	                                                  priv->carrier);
 	return FALSE;
 }
 
@@ -117,7 +125,6 @@ set_carrier (NMDeviceWired *self,
 	g_return_if_fail (caps & NM_DEVICE_CAP_CARRIER_DETECT);
 
 	priv->carrier = carrier;
-	g_object_notify (G_OBJECT (self), "carrier");
 
 	state = nm_device_interface_get_state (NM_DEVICE_INTERFACE (self));
 	nm_log_info (LOGD_HW | NM_DEVICE_WIRED_LOG_LEVEL (NM_DEVICE (self)),
@@ -127,6 +134,8 @@ set_carrier (NMDeviceWired *self,
 	             state,
 	             defer_action ? ", deferring action for 4 seconds" : "");
 
+	g_object_notify (G_OBJECT (self), "carrier");
+
 	if (defer_action)
 		priv->carrier_action_defer_id = g_timeout_add_seconds (4, carrier_action_defer_cb, self);
 	else
@@ -233,6 +242,9 @@ constructor (GType type,
 		/* We may not know the hardware address type until a slave is added */
 		priv->hw_addr_type = ARPHRD_ETHER;
 		priv->hw_addr_len = ETH_ALEN;
+	} else if (nm_device_get_device_type (self) == NM_DEVICE_TYPE_BRIDGE) {
+		priv->hw_addr_type = ARPHRD_ETHER;
+		priv->hw_addr_len = ETH_ALEN;
 	} else
 		g_assert_not_reached ();
 
@@ -424,6 +436,7 @@ nm_device_wired_class_init (NMDeviceWiredClass *klass)
 {
 	GObjectClass *object_class = G_OBJECT_CLASS (klass);
 	NMDeviceClass *parent_class = NM_DEVICE_CLASS (klass);
+	NMDeviceWiredClass *wired_class = NM_DEVICE_WIRED_CLASS (klass);
 
 	g_type_class_add_private (object_class, sizeof (NMDeviceWiredPrivate));
 
@@ -438,6 +451,8 @@ nm_device_wired_class_init (NMDeviceWiredClass *klass)
 	parent_class->update_hw_address = real_update_hw_address;
 	parent_class->is_available = real_is_available;
 	parent_class->connection_match_config = connection_match_config;
+
+	wired_class->carrier_action = carrier_action;
 }
 
 /**
diff --git a/src/nm-device-wired.h b/src/nm-device-wired.h
index b2f6ee4..ab33cee 100644
--- a/src/nm-device-wired.h
+++ b/src/nm-device-wired.h
@@ -42,6 +42,9 @@ typedef struct {
 typedef struct {
 	NMDeviceClass parent;
 
+	void (*carrier_action) (NMDeviceWired *self,
+	                        NMDeviceState state,
+	                        gboolean carrier);
 } NMDeviceWiredClass;
 
 GType nm_device_wired_get_type (void);
diff --git a/src/nm-device.c b/src/nm-device.c
index a19f9b5..80a2ae4 100644
--- a/src/nm-device.c
+++ b/src/nm-device.c
@@ -82,6 +82,12 @@ typedef struct {
 } QueuedState;
 
 typedef struct {
+	NMDevice *slave;
+	gboolean enslaved;
+	guint watch_id;
+} SlaveInfo;
+
+typedef struct {
 	gboolean disposed;
 	gboolean initialized;
 
@@ -109,8 +115,6 @@ typedef struct {
 	gpointer        act_source_func;
 	guint           act_source6_id;
 	gpointer        act_source6_func;
-	guint           act_dep_result_id;
-	guint           act_dep_timeout_id;
 	gulong          secrets_updated_id;
 	gulong          secrets_failed_id;
 
@@ -157,14 +161,19 @@ typedef struct {
 
 	/* inhibit autoconnect feature */
 	gboolean	autoconnect_inhibit;
+
+	/* master interface for bridge/bond slave */
+	NMDevice *      master;
+	gboolean        enslaved;
+
+	/* list of SlaveInfo for bond/bridge master */
+	GSList *        slaves;
 } NMDevicePrivate;
 
 static gboolean check_connection_compatible (NMDeviceInterface *device,
                                              NMConnection *connection,
                                              GError **error);
-static gboolean nm_device_activate (NMDeviceInterface *device,
-                                    NMActRequest *req,
-                                    GError **error);
+static void nm_device_activate (NMDeviceInterface *device, NMActRequest *req);
 static void nm_device_deactivate (NMDeviceInterface *device, NMDeviceStateReason reason);
 static gboolean device_disconnect (NMDeviceInterface *device, GError **error);
 static gboolean spec_match_list (NMDeviceInterface *device, const GSList *specs);
@@ -503,10 +512,36 @@ nm_device_get_type_desc (NMDevice *self)
 	return NM_DEVICE_GET_PRIVATE (self)->type_desc;
 }
 
+static SlaveInfo *
+find_slave_info (NMDevice *self, NMDevice *slave)
+{
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+	SlaveInfo *info;
+	GSList *iter;
+
+	for (iter = priv->slaves; iter; iter = g_slist_next (iter)) {
+		info = iter->data;
+		if (info->slave == slave)
+			return info;
+	}
+	return NULL;
+}
+
+static void
+free_slave_info (SlaveInfo *info)
+{
+	g_signal_handler_disconnect (info->slave, info->watch_id);
+	if (info->slave)
+		g_object_unref (info->slave);
+	memset (info, 0, sizeof (*info));
+	g_free (info);
+}
+
 /**
  * nm_device_enslave_slave:
  * @dev: the master device
  * @slave: the slave device to enslave
+ * @connection: the slave device's connection
  *
  * If @dev is capable of enslaving other devices (ie it's a bridge, bond, etc)
  * then this function enslaves @slave.
@@ -514,22 +549,42 @@ nm_device_get_type_desc (NMDevice *self)
  * Returns: %TRUE on success, %FALSE on failure or if this device cannot enslave
  *  other devices.
  */
-gboolean
-nm_device_enslave_slave (NMDevice *dev, NMDevice *slave)
+static gboolean
+nm_device_enslave_slave (NMDevice *dev, NMDevice *slave, NMConnection *connection)
 {
+	SlaveInfo *info;
+	gboolean success = FALSE;
+
 	g_return_val_if_fail (dev != NULL, FALSE);
 	g_return_val_if_fail (slave != NULL, FALSE);
 	g_return_val_if_fail (nm_device_get_state (slave) >= NM_DEVICE_STATE_DISCONNECTED, FALSE);
+	g_return_val_if_fail (NM_DEVICE_GET_CLASS (dev)->enslave_slave != NULL, FALSE);
 
-	if (NM_DEVICE_GET_CLASS (dev)->enslave_slave)
-		return NM_DEVICE_GET_CLASS (dev)->enslave_slave (dev, slave);
-	return FALSE;
+	info = find_slave_info (dev, slave);
+	if (!info)
+		return FALSE;
+
+	g_warn_if_fail (info->enslaved == FALSE);
+	success = NM_DEVICE_GET_CLASS (dev)->enslave_slave (dev, slave, connection);
+	if (success) {
+		info->enslaved = TRUE;
+		nm_device_slave_notify_enslaved (info->slave, TRUE, FALSE);
+	}
+
+	/* Ensure the device's hardware address is up-to-date; it often changes
+	 * when slaves change.
+	 */
+	if (NM_DEVICE_GET_CLASS (dev)->update_hw_address)
+		NM_DEVICE_GET_CLASS (dev)->update_hw_address (dev);
+
+	return success;
 }
 
 /**
- * nm_device_release_slave:
+ * nm_device_release_one_slave:
  * @dev: the master device
  * @slave: the slave device to release
+ * @failed: %TRUE if the release was unexpected, ie the master failed
  *
  * If @dev is capable of enslaving other devices (ie it's a bridge, bond, etc)
  * then this function releases the previously enslaved @slave.
@@ -537,15 +592,219 @@ nm_device_enslave_slave (NMDevice *dev, NMDevice *slave)
  * Returns: %TRUE on success, %FALSE on failure, if this device cannot enslave
  *  other devices, or if @slave was never enslaved.
  */
+static gboolean
+nm_device_release_one_slave (NMDevice *dev, NMDevice *slave, gboolean failed)
+{
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (dev);
+	SlaveInfo *info;
+	gboolean success = FALSE;
+
+	g_return_val_if_fail (slave != NULL, FALSE);
+	g_return_val_if_fail (NM_DEVICE_GET_CLASS (dev)->release_slave != NULL, FALSE);
+
+	info = find_slave_info (dev, slave);
+	if (!info)
+		return FALSE;
+
+	if (info->enslaved) {
+		success = NM_DEVICE_GET_CLASS (dev)->release_slave (dev, slave);
+		g_warn_if_fail (success);
+	}
+	nm_device_slave_notify_enslaved (info->slave, FALSE, failed);
+
+	priv->slaves = g_slist_remove (priv->slaves, info);
+	free_slave_info (info);
+
+	/* Ensure the device's hardware address is up-to-date; it often changes
+	 * when slaves change.
+	 */
+	if (NM_DEVICE_GET_CLASS (dev)->update_hw_address)
+		NM_DEVICE_GET_CLASS (dev)->update_hw_address (dev);
+
+	return success;
+}
+
+static void
+slave_state_changed (NMDevice *slave,
+                     NMDeviceState slave_new_state,
+                     NMDeviceState slave_old_state,
+                     NMDeviceStateReason reason,
+                     NMDevice *self)
+{
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+	gboolean release = FALSE;
+
+	nm_log_dbg (LOGD_DEVICE, "(%s): slave %s state change %d -> %d",
+	            nm_device_get_iface (self),
+	            nm_device_get_iface (slave),
+	            slave_old_state,
+	            slave_new_state);
+
+	g_assert (priv->state > NM_DEVICE_STATE_DISCONNECTED);
+	g_assert (priv->state <= NM_DEVICE_STATE_ACTIVATED);
+
+	/* Don't try to enslave slaves until the master is ready */
+	if (priv->state < NM_DEVICE_STATE_CONFIG)
+		return;
+
+	if (slave_new_state == NM_DEVICE_STATE_IP_CONFIG)
+		nm_device_enslave_slave (self, slave, nm_device_get_connection (slave));
+	else if (slave_new_state > NM_DEVICE_STATE_ACTIVATED)
+		release = TRUE;
+	else if (   slave_new_state <= NM_DEVICE_STATE_DISCONNECTED
+	         && slave_old_state > NM_DEVICE_STATE_DISCONNECTED) {
+		/* Catch failures due to unavailable or unmanaged */
+		release = TRUE;
+	}
+
+	if (release) {
+		nm_device_release_one_slave (self, slave, FALSE);
+		/* Bridge/bond interfaces are left up until manually deactivated */
+		if (priv->slaves == NULL && priv->state == NM_DEVICE_STATE_ACTIVATED) {
+			nm_log_dbg (LOGD_DEVICE, "(%s): last slave removed; remaining activated",
+			            nm_device_get_iface (self));
+		}
+	}
+}
+
+/**
+ * nm_device_master_add_slave:
+ * @dev: the master device
+ * @slave: the slave device to enslave
+ *
+ * If @dev is capable of enslaving other devices (ie it's a bridge, bond, etc)
+ * then this function adds @slave to the slave list for later enslavement.
+ *
+ * Returns: %TRUE on success, %FALSE on failure
+ */
 gboolean
-nm_device_release_slave (NMDevice *dev, NMDevice *slave)
+nm_device_master_add_slave (NMDevice *dev, NMDevice *slave)
 {
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (dev);
+	SlaveInfo *info;
+
 	g_return_val_if_fail (dev != NULL, FALSE);
 	g_return_val_if_fail (slave != NULL, FALSE);
+	g_return_val_if_fail (nm_device_get_state (slave) >= NM_DEVICE_STATE_DISCONNECTED, FALSE);
+	g_return_val_if_fail (NM_DEVICE_GET_CLASS (dev)->enslave_slave != NULL, FALSE);
+
+	if (!find_slave_info (dev, slave)) {
+		info = g_malloc0 (sizeof (SlaveInfo));
+		info->slave = g_object_ref (slave);
+		info->watch_id = g_signal_connect (slave, "state-changed",
+		                                   G_CALLBACK (slave_state_changed), dev);
+		priv->slaves = g_slist_prepend (priv->slaves, info);
+	}
 
-	if (NM_DEVICE_GET_CLASS (dev)->release_slave)
-		return NM_DEVICE_GET_CLASS (dev)->release_slave (dev, slave);
-	return FALSE;
+	return TRUE;
+}
+
+
+/**
+ * nm_device_master_get_slaves:
+ * @dev: the master device
+ *
+ * Returns: any slaves of which @device is the master.  Caller owns returned list.
+ */
+GSList *
+nm_device_master_get_slaves (NMDevice *dev)
+{
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (dev);
+	GSList *slaves = NULL, *iter;
+
+	for (iter = priv->slaves; iter; iter = g_slist_next (iter))
+		slaves = g_slist_prepend (slaves, ((SlaveInfo *) iter->data)->slave);
+
+	return slaves;
+}
+
+/* release all slaves */
+static void
+nm_device_master_release_slaves (NMDevice *self, gboolean failed)
+{
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+	GSList *iter;
+
+	for (iter = priv->slaves; iter; iter = g_slist_next (iter))
+		nm_device_release_one_slave (self, ((SlaveInfo *) iter->data)->slave, failed);
+	g_slist_free (priv->slaves);
+	priv->slaves = NULL;
+}
+
+
+/**
+ * nm_device_slave_notify_enslaved:
+ * @dev: the slave device
+ * @enslaved: %TRUE if the device is now enslaved, %FALSE if released
+ * @master_failed: if released, indicates whether the release was unexpected,
+ *   ie the master device failed.
+ *
+ * Notifies a slave that it has been enslaved or released.  If released, provides
+ * information on whether the release was expected or not, and thus whether the
+ * slave should fail it's activation or gracefully deactivate.
+ */
+void
+nm_device_slave_notify_enslaved (NMDevice *dev,
+                                 gboolean enslaved,
+                                 gboolean master_failed)
+{
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (dev);
+	NMConnection *connection = nm_device_get_connection (dev);
+
+	if (enslaved) {
+		g_assert (priv->master);
+		g_warn_if_fail (priv->enslaved == FALSE);
+		g_warn_if_fail (priv->state == NM_DEVICE_STATE_IP_CONFIG);
+
+		nm_log_info (LOGD_DEVICE,
+				     "Activation (%s) connection '%s' enslaved, continuing activation",
+				     nm_device_get_iface (dev),
+				     nm_connection_get_id (connection));
+
+		/* Now that we're enslaved, proceed with activation.  Remember, slaves
+		 * don't have any IP configuration, so they skip directly to ACTIVATED.
+		 */
+		priv->enslaved = TRUE;
+		priv->ip4_ready = TRUE;
+		priv->ip6_ready = TRUE;
+		nm_device_queue_state (dev, NM_DEVICE_STATE_ACTIVATED, NM_DEVICE_STATE_REASON_NONE);
+	} else {
+		NMDeviceState new_state = NM_DEVICE_STATE_DISCONNECTED;
+		NMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;
+
+		if (   priv->state > NM_DEVICE_STATE_DISCONNECTED
+		    && priv->state <= NM_DEVICE_STATE_ACTIVATED) {
+			if (master_failed) {
+				new_state = NM_DEVICE_STATE_FAILED;
+				reason = NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED;
+
+				nm_log_warn (LOGD_DEVICE,
+				             "Activation (%s) connection '%s' master failed",
+				             nm_device_get_iface (dev),
+				             nm_connection_get_id (connection));
+			} else {
+				nm_log_dbg (LOGD_DEVICE,
+				            "Activation (%s) connection '%s' master deactivated",
+				            nm_device_get_iface (dev),
+				            nm_connection_get_id (connection));
+			}
+
+			nm_device_queue_state (dev, new_state, reason);
+		}
+	}
+}
+
+/**
+ * nm_device_get_enslaved:
+ * @device: the #NMDevice
+ *
+ * Returns: %TRUE if the device is enslaved to a master device (eg bridge or
+ * bond), %FALSE if not
+ */
+gboolean
+nm_device_get_enslaved (NMDevice *device)
+{
+	return NM_DEVICE_GET_PRIVATE (device)->enslaved;
 }
 
 /*
@@ -910,26 +1169,7 @@ addrconf6_cleanup (NMDevice *self)
 static NMActStageReturn
 real_act_stage1_prepare (NMDevice *self, NMDeviceStateReason *reason)
 {
-	NMActRequest *req;
-	NMActRequest *master_ac;
-	NMDevice *master;
-	NMActStageReturn ret = NM_ACT_STAGE_RETURN_SUCCESS;
-
-	req = nm_device_get_act_request (self);
-	g_assert (req);
-
-	/* If the interface is going to be a slave, let the master enslave it here */
-	master_ac = nm_act_request_get_dependency (req);
-	if (master_ac) {
-		/* FIXME: handle VPNs here too */
-
-		master = NM_DEVICE (nm_act_request_get_device (master_ac));
-		g_assert (master);
-		if (!nm_device_enslave_slave (master, self))
-			ret = NM_ACT_STAGE_RETURN_FAILURE;
-	}
-
-	return ret;
+	return NM_ACT_STAGE_RETURN_SUCCESS;
 }
 
 /*
@@ -950,11 +1190,6 @@ nm_device_activate_stage1_device_prepare (gpointer user_data)
 	/* Clear the activation source ID now that this stage has run */
 	activation_source_clear (self, FALSE, 0);
 
-	if (priv->act_dep_timeout_id) {
-		g_source_remove (priv->act_dep_timeout_id);
-		priv->act_dep_timeout_id = 0;
-	}
-
 	priv->ip4_ready = priv->ip6_ready = FALSE;
 
 	iface = nm_device_get_iface (self);
@@ -1003,6 +1238,17 @@ nm_device_activate_schedule_stage1_device_prepare (NMDevice *self)
 static NMActStageReturn
 real_act_stage2_config (NMDevice *dev, NMDeviceStateReason *reason)
 {
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (dev);
+	GSList *iter;
+
+	/* If we have slaves that aren't yet enslaved, do that now */
+	for (iter = priv->slaves; iter; iter = g_slist_next (iter)) {
+		SlaveInfo *info = iter->data;
+
+		if (nm_device_get_state (info->slave) == NM_DEVICE_STATE_IP_CONFIG)
+			nm_device_enslave_slave (dev, info->slave, nm_device_get_connection (info->slave));
+	}
+
 	/* Nothing to do */
 	return NM_ACT_STAGE_RETURN_SUCCESS;
 }
@@ -1776,7 +2022,7 @@ real_act_stage3_ip6_config_start (NMDevice *self, NMDeviceStateReason *reason)
 	} else if (ip6_method_matches (connection, NM_SETTING_IP6_CONFIG_METHOD_DHCP)) {
 		/* Router advertisements shouldn't be used in pure DHCP mode */
 		if (priv->ip6_accept_ra_path)
-			nm_utils_do_sysctl (priv->ip6_accept_ra_path, "0\n");
+			nm_utils_do_sysctl (priv->ip6_accept_ra_path, "0");
 
 		priv->dhcp6_mode = IP6_DHCP_OPT_MANAGED;
 		ret = dhcp6_start (self, connection, priv->dhcp6_mode, reason);
@@ -1784,7 +2030,7 @@ real_act_stage3_ip6_config_start (NMDevice *self, NMDeviceStateReason *reason)
 		/* reset the saved RA value when ipv6 is ignored */
 		if (priv->ip6_accept_ra_path) {
 			nm_utils_do_sysctl (priv->ip6_accept_ra_path,
-			                    priv->ip6_accept_ra_save ? "1\n" : "0\n");
+			                    priv->ip6_accept_ra_save ? "1" : "0");
 		}
 
 		priv->ip6_ready = TRUE;
@@ -1792,7 +2038,7 @@ real_act_stage3_ip6_config_start (NMDevice *self, NMDeviceStateReason *reason)
 	} else if (ip6_method_matches (connection, NM_SETTING_IP6_CONFIG_METHOD_MANUAL)) {
 		/* Router advertisements shouldn't be used in manual mode */
 		if (priv->ip6_accept_ra_path)
-			nm_utils_do_sysctl (priv->ip6_accept_ra_path, "0\n");
+			nm_utils_do_sysctl (priv->ip6_accept_ra_path, "0");
 		ret = NM_ACT_STAGE_RETURN_SUCCESS;
 	}
 
@@ -1802,62 +2048,116 @@ out:
 	return ret;
 }
 
-
-/*
- * nm_device_activate_stage3_ip_config_start
- *
- * Begin automatic/manual IP configuration
+/**
+ * nm_device_activate_stage3_ip4_start:
+ * @self: the device
  *
+ * Try starting IPv4 configuration.
  */
-static gboolean
-nm_device_activate_stage3_ip_config_start (gpointer user_data)
+gboolean
+nm_device_activate_stage3_ip4_start (NMDevice *self)
 {
-	NMDevice *self = NM_DEVICE (user_data);
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
-	const char *iface;
 	NMActStageReturn ret;
 	NMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;
 
-	/* Clear the activation source ID now that this stage has run */
-	activation_source_clear (self, FALSE, 0);
-
-	iface = nm_device_get_iface (self);
-	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 3 of 5 (IP Configure Start) started...", iface);
-	nm_device_state_changed (self, NM_DEVICE_STATE_IP_CONFIG, NM_DEVICE_STATE_REASON_NONE);
+	g_assert (priv->ip4_ready == FALSE);
 
 	ret = NM_DEVICE_GET_CLASS (self)->act_stage3_ip4_config_start (self, &reason);
 	if (ret == NM_ACT_STAGE_RETURN_SUCCESS)
 		nm_device_activate_schedule_stage4_ip4_config_get (self);
 	else if (ret == NM_ACT_STAGE_RETURN_FAILURE) {
 		nm_device_state_changed (self, NM_DEVICE_STATE_FAILED, reason);
-		goto out;
+		return FALSE;
 	} else if (ret == NM_ACT_STAGE_RETURN_STOP) {
 		/* Nothing to do */
 	} else
 		g_assert (ret == NM_ACT_STAGE_RETURN_POSTPONE);
 
+	return TRUE;
+}
+
+/**
+ * nm_device_activate_stage3_ip6_start:
+ * @self: the device
+ *
+ * Try starting IPv6 configuration.
+ */
+gboolean
+nm_device_activate_stage3_ip6_start (NMDevice *self)
+{
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+	NMActStageReturn ret;
+	NMDeviceStateReason reason = NM_DEVICE_STATE_REASON_NONE;
+
+	g_assert (priv->ip6_ready == FALSE);
+
 	ret = NM_DEVICE_GET_CLASS (self)->act_stage3_ip6_config_start (self, &reason);
 	if (ret == NM_ACT_STAGE_RETURN_SUCCESS)
 		nm_device_activate_schedule_stage4_ip6_config_get (self);
 	else if (ret == NM_ACT_STAGE_RETURN_FAILURE) {
 		nm_device_state_changed (self, NM_DEVICE_STATE_FAILED, reason);
-		goto out;
+		return FALSE;
 	} else if (ret == NM_ACT_STAGE_RETURN_STOP) {
 		/* Nothing to do */
 	} else
 		g_assert (ret == NM_ACT_STAGE_RETURN_POSTPONE);
 
-out:
-	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 3 of 5 (IP Configure Start) complete.", iface);
+	return TRUE;
+}
 
-	/* Handle interfaces (bond slaves, etc) that won't have any IP config; they
-	 * need to move to ACTIVATED.
+/*
+ * nm_device_activate_stage3_ip_config_start
+ *
+ * Begin automatic/manual IP configuration
+ *
+ */
+static gboolean
+nm_device_activate_stage3_ip_config_start (gpointer user_data)
+{
+	NMDevice *self = NM_DEVICE (user_data);
+	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+	const char *iface;
+	NMDevice *master;
+
+	/* Clear the activation source ID now that this stage has run */
+	activation_source_clear (self, FALSE, 0);
+
+	iface = nm_device_get_iface (self);
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 3 of 5 (IP Configure Start) started...", iface);
+	nm_device_state_changed (self, NM_DEVICE_STATE_IP_CONFIG, NM_DEVICE_STATE_REASON_NONE);
+
+	priv->ip4_ready = priv->ip6_ready = FALSE;
+
+	/* If the device is a slave, then we don't do any IP configuration but we
+	 * use the IP config stage to indicate to the master we're ready for
+	 * enslavement.  Either the master has already enslaved us, in which case
+	 * our state transition to SECONDARIES is already queued courtesy of
+	 * nm_device_slave_notify_enslaved(), or the master is still activating,
+	 * in which case we postpone activation here until the master enslaves us,
+	 * which calls nm_device_slave_notify_enslaved().
 	 */
-	if (priv->ip4_ready && priv->ip6_ready) {
-		/* FIXME: call layer2 stuff to set MTU? */
-		nm_device_state_changed (self, NM_DEVICE_STATE_ACTIVATED, NM_DEVICE_STATE_REASON_NONE);
+	master = (NMDevice *) nm_act_request_get_master (priv->act_request);
+	if (master) {
+		if (priv->enslaved == FALSE) {
+			nm_log_info (LOGD_DEVICE, "Activation (%s) connection '%s' waiting on master '%s'",
+						 nm_device_get_iface (self),
+						 nm_connection_get_id (nm_device_get_connection (self)),
+						 nm_device_get_iface (master));
+		}
+		goto out;
 	}
 
+	/* IPv4 */
+	if (!nm_device_activate_stage3_ip4_start (self))
+		goto out;
+
+	/* IPv6 */
+	if (!nm_device_activate_stage3_ip6_start (self))
+		goto out;
+
+out:
+	nm_log_info (LOGD_DEVICE, "Activation (%s) Stage 3 of 5 (IP Configure Start) complete.", iface);
 	return FALSE;
 }
 
@@ -2466,13 +2766,13 @@ share_init (void)
 	                    NULL };
 	char **iter;
 
-	if (!nm_utils_do_sysctl ("/proc/sys/net/ipv4/ip_forward", "1\n")) {
+	if (!nm_utils_do_sysctl ("/proc/sys/net/ipv4/ip_forward", "1")) {
 		nm_log_err (LOGD_SHARING, "Error starting IP forwarding: (%d) %s",
 					errno, strerror (errno));
 		return FALSE;
 	}
 
-	if (!nm_utils_do_sysctl ("/proc/sys/net/ipv4/ip_dynaddr", "1\n")) {
+	if (!nm_utils_do_sysctl ("/proc/sys/net/ipv4/ip_dynaddr", "1")) {
 		nm_log_err (LOGD_SHARING, "error starting IP forwarding: (%d) %s",
 					errno, strerror (errno));
 	}
@@ -2855,15 +3155,6 @@ nm_device_deactivate_quickly (NMDevice *self)
 	activation_source_clear (self, TRUE, AF_INET);
 	activation_source_clear (self, TRUE, AF_INET6);
 
-	if (priv->act_dep_result_id) {
-		g_source_remove (priv->act_dep_result_id);
-		priv->act_dep_result_id = 0;
-	}
-	if (priv->act_dep_timeout_id) {
-		g_source_remove (priv->act_dep_timeout_id);
-		priv->act_dep_timeout_id = 0;
-	}
-
 	/* Clear any queued transitions */
 	queued_state_clear (self);
 
@@ -2877,12 +3168,22 @@ nm_device_deactivate_quickly (NMDevice *self)
 
 	/* Turn off router advertisements until they are needed */
 	if (priv->ip6_accept_ra_path)
-		nm_utils_do_sysctl (priv->ip6_accept_ra_path, "0\n");
+		nm_utils_do_sysctl (priv->ip6_accept_ra_path, "0");
 
 	/* Call device type-specific deactivation */
 	if (NM_DEVICE_GET_CLASS (self)->deactivate_quickly)
 		NM_DEVICE_GET_CLASS (self)->deactivate_quickly (self);
 
+	/* master: release slaves */
+	nm_device_master_release_slaves (self, FALSE);
+
+	/* slave: mark no longer enslaved */
+	if (priv->master) {
+		g_object_unref (priv->master);
+		priv->master = NULL;
+	}
+	priv->enslaved = FALSE;
+
 	/* Tear down an existing activation request */
 	clear_act_request (self);
 
@@ -2971,101 +3272,13 @@ connection_secrets_failed_cb (NMActRequest *req,
 	nm_device_state_changed (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_NO_SECRETS);
 }
 
-static gboolean
-device_activation_precheck (NMDevice *self, NMConnection *connection, GError **error)
-{
-	NMConnection *current_connection;
-
-	g_return_val_if_fail (NM_IS_DEVICE (self), FALSE);
-	g_return_val_if_fail (NM_IS_CONNECTION (connection), FALSE);
-
-	if (nm_device_get_state (self) != NM_DEVICE_STATE_ACTIVATED)
-		return TRUE;
-
-	if (!nm_device_is_activating (self))
-		return TRUE;
-
-	// FIXME: why not just check connection path & service?
-	current_connection = nm_act_request_get_connection (nm_device_get_act_request (self));
-	if (nm_connection_compare (connection, current_connection, NM_SETTING_COMPARE_FLAG_EXACT)) {
-		/* Already activating or activated with the same connection */
-		g_set_error (error,
-		             NM_DEVICE_INTERFACE_ERROR,
-		             NM_DEVICE_INTERFACE_ERROR_CONNECTION_ACTIVATING,
-		             "%s", "Connection is already activating");
-		return FALSE;
-	}
-
-	return TRUE;
-}
-
-static gboolean
-act_dep_timeout_cb (gpointer user_data)
-{
-	NMDevice *self = NM_DEVICE (user_data);
-	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
-	NMConnection *connection;
-
-	connection = nm_act_request_get_connection (priv->act_request);
-	nm_log_warn (LOGD_DEVICE,
-	             "Activation (%s) connection '%s' dependency timed out",
-	             nm_device_get_iface (self),
-	             nm_connection_get_id (connection));
-
-	nm_device_queue_state (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED);
-	return FALSE;
-}
-
 static void
-act_dep_result_cb (NMActRequest *req,
-                   NMActRequestDependencyResult result,
-                   NMDevice *self)
-{
-	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
-	NMConnection *connection;
-
-	connection = nm_act_request_get_connection (priv->act_request);
-
-	switch (result) {
-	case NM_ACT_REQUEST_DEP_RESULT_FAILED:
-		g_source_remove (priv->act_dep_result_id);
-		priv->act_dep_result_id = 0;
-
-		nm_log_warn (LOGD_DEVICE,
-			         "Activation (%s) connection '%s' dependency failed",
-			         nm_device_get_iface (self),
-			         nm_connection_get_id (connection));
-		nm_device_queue_state (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED);
-		break;
-	case NM_ACT_REQUEST_DEP_RESULT_READY:
-		g_warn_if_fail (priv->state == NM_DEVICE_STATE_PREPARE);
-		if (priv->state == NM_DEVICE_STATE_PREPARE) {
-			nm_log_info (LOGD_DEVICE,
-					     "Activation (%s) connection '%s' dependency ready, continuing activation",
-					     nm_device_get_iface (self),
-					     nm_connection_get_id (connection));
-			nm_device_activate_schedule_stage1_device_prepare (self);
-		}
-		break;
-	case NM_ACT_REQUEST_DEP_RESULT_WAIT:
-	default:
-		g_assert_not_reached ();
-		break;
-	}
-}
-
-static gboolean
-nm_device_activate (NMDeviceInterface *device,
-                    NMActRequest *req,
-                    GError **error)
+nm_device_activate (NMDeviceInterface *device, NMActRequest *req)
 {
 	NMDevice *self = NM_DEVICE (device);
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
 
-	if (!device_activation_precheck (self, nm_act_request_get_connection (req), error)) {
-		g_assert (*error);
-		return FALSE;
-	}
+	g_warn_if_fail (priv->state == NM_DEVICE_STATE_DISCONNECTED);
 
 	priv->act_request = g_object_ref (req);
 	priv->secrets_updated_id = g_signal_connect (req,
@@ -3077,9 +3290,16 @@ nm_device_activate (NMDeviceInterface *device,
 									    G_CALLBACK (connection_secrets_failed_cb),
 									    device);
 
-	if (!nm_act_request_get_assumed (req)) {
-		NMActRequest *dep_ac;
-		NMConnection *dep_con, *connection;
+	if (nm_act_request_get_assumed (req)) {
+		/* If it's an assumed connection, let the device subclass short-circuit
+		 * the normal connection process and just copy its IP configs from the
+		 * interface.
+		 */
+		nm_device_state_changed (self, NM_DEVICE_STATE_IP_CONFIG, NM_DEVICE_STATE_REASON_NONE);
+		nm_device_activate_schedule_stage3_ip_config_start (self);
+	} else {
+		NMConnection *connection;
+		NMDevice *master;
 
 		connection = nm_act_request_get_connection (req);
 		g_assert (connection);
@@ -3092,43 +3312,18 @@ nm_device_activate (NMDeviceInterface *device,
 		nm_device_state_changed (self, NM_DEVICE_STATE_PREPARE, NM_DEVICE_STATE_REASON_NONE);
 
 		/* Handle any dependencies this connection might have */
-		switch (nm_act_request_get_dependency_result (priv->act_request)) {
-		case NM_ACT_REQUEST_DEP_RESULT_FAILED:
-			nm_device_queue_state (self, NM_DEVICE_STATE_FAILED, NM_DEVICE_STATE_REASON_DEPENDENCY_FAILED);
-			break;
-		case NM_ACT_REQUEST_DEP_RESULT_WAIT:
-			dep_ac = nm_act_request_get_dependency (priv->act_request);
-			g_assert (dep_ac);
-			dep_con = nm_act_request_get_connection (dep_ac);
-			g_assert (dep_con);
-			nm_log_info (LOGD_DEVICE, "Activation (%s) connection '%s' waiting on dependency '%s'",
-						 nm_device_get_iface (self),
-						 nm_connection_get_id (connection),
-						 nm_connection_get_id (dep_con));
-
-			priv->act_dep_result_id = g_signal_connect (priv->act_request,
-					                                    NM_ACT_REQUEST_DEPENDENCY_RESULT,
-					                                    G_CALLBACK (act_dep_result_cb),
-					                                    self);
-			priv->act_dep_timeout_id = g_timeout_add_seconds (60, act_dep_timeout_cb, self);
-			break;
-		default:
-			g_warn_if_reached ();
-			/* fall through */
-		case NM_ACT_REQUEST_DEP_RESULT_READY:
-			nm_device_activate_schedule_stage1_device_prepare (self);
-			break;
+		master = (NMDevice *) nm_act_request_get_master (req);
+		if (master) {
+			/* Master should at least already be activating */
+			g_assert (nm_device_get_state (master) > NM_DEVICE_STATE_DISCONNECTED);
+
+			g_assert (priv->master == NULL);
+			priv->master = g_object_ref (master);
+			nm_device_master_add_slave (master, self);
 		}
-	} else {
-		/* If it's an assumed connection, let the device subclass short-circuit
-		 * the normal connection process and just copy its IP configs from the
-		 * interface.
-		 */
-		nm_device_state_changed (self, NM_DEVICE_STATE_IP_CONFIG, NM_DEVICE_STATE_REASON_NONE);
-		nm_device_activate_schedule_stage3_ip_config_start (self);
-	}
 
-	return TRUE;
+		nm_device_activate_schedule_stage1_device_prepare (self);
+	}
 }
 
 /*
@@ -3524,7 +3719,8 @@ dispose (GObject *object)
 			method = nm_setting_ip4_config_get_method (s_ip4);
 			if (   !method
 			    || !strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_AUTO)
-			    || !strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_MANUAL))
+			    || !strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_MANUAL)
+			    || !strcmp (method, NM_SETTING_IP4_CONFIG_METHOD_DISABLED))
 				take_down = FALSE;
 		}
 	}
@@ -3538,6 +3734,8 @@ dispose (GObject *object)
 	addrconf6_cleanup (self);
 	dnsmasq_cleanup (self);
 
+	g_warn_if_fail (priv->slaves == NULL);
+
 	/* Take the device itself down and clear its IPv4 configuration */
 	if (priv->managed && take_down) {
 		NMDeviceStateReason ignored = NM_DEVICE_STATE_REASON_NONE;
@@ -3549,7 +3747,7 @@ dispose (GObject *object)
 	/* reset the saved RA value */
 	if (priv->ip6_accept_ra_path) {
 		nm_utils_do_sysctl (priv->ip6_accept_ra_path,
-		                    priv->ip6_accept_ra_save ? "1\n" : "0\n");
+		                    priv->ip6_accept_ra_save ? "1" : "0");
 	}
 	g_free (priv->ip6_accept_ra_path);
 
@@ -3963,6 +4161,10 @@ nm_device_state_changed (NMDevice *device,
 		break;
 	case NM_DEVICE_STATE_FAILED:
 		nm_log_warn (LOGD_DEVICE, "Activation (%s) failed.", nm_device_get_iface (device));
+
+		/* Notify any slaves of the unexpected failure */
+		nm_device_master_release_slaves (device, TRUE);
+
 		/* Schedule the transition to DISCONNECTED.  The device can't transition
 		 * immediately becuase we can't change states again from the state
 		 * handler for a variety of reasons.
@@ -3986,17 +4188,28 @@ queued_set_state (gpointer user_data)
 {
 	NMDevice *self = NM_DEVICE (user_data);
 	NMDevicePrivate *priv = NM_DEVICE_GET_PRIVATE (self);
+	NMDeviceState new_state;
+	NMDeviceStateReason new_reason;
 
 	if (priv->queued_state.id) {
-		priv->queued_state.id = 0;
-
 		nm_log_dbg (LOGD_DEVICE, "(%s): running queued state change to %d (id %d)",
 		            nm_device_get_iface (self),
 		            priv->queued_state.state,
 		            priv->queued_state.id);
-		nm_device_state_changed (self, priv->queued_state.state, priv->queued_state.reason);
+
+		/* Clear queued state struct before triggering state change, since
+		 * the state change may queue another state.
+		 */
+		priv->queued_state.id = 0;
+		new_state = priv->queued_state.state;
+		new_reason = priv->queued_state.reason;
+		queued_state_clear (self);
+
+		nm_device_state_changed (self, new_state, new_reason);
+	} else {
+		g_warn_if_fail (priv->queued_state.state == NM_DEVICE_STATE_UNKNOWN);
+		g_warn_if_fail (priv->queued_state.reason == NM_DEVICE_STATE_REASON_NONE);
 	}
-	queued_state_clear (self);
 	return FALSE;
 }
 
diff --git a/src/nm-device.h b/src/nm-device.h
index 5faac44..0b0ad47 100644
--- a/src/nm-device.h
+++ b/src/nm-device.h
@@ -128,7 +128,8 @@ typedef struct {
 	                                    gboolean fail_if_no_hwaddr);
 
 	gboolean        (* enslave_slave) (NMDevice *self,
-	                                   NMDevice *slave);
+	                                   NMDevice *slave,
+	                                   NMConnection *connection);
 
 	gboolean        (* release_slave) (NMDevice *self,
 	                                   NMDevice *slave);
@@ -163,8 +164,14 @@ NMDHCP6Config * nm_device_get_dhcp6_config (NMDevice *dev);
 NMIP4Config *	nm_device_get_ip4_config	(NMDevice *dev);
 NMIP6Config *	nm_device_get_ip6_config	(NMDevice *dev);
 
-gboolean        nm_device_enslave_slave     (NMDevice *dev, NMDevice *slave);
-gboolean        nm_device_release_slave     (NMDevice *dev, NMDevice *slave);
+/* Master */
+gboolean        nm_device_master_add_slave  (NMDevice *dev, NMDevice *slave);
+GSList *        nm_device_master_get_slaves (NMDevice *dev);
+
+/* Slave */
+void            nm_device_slave_notify_enslaved (NMDevice *dev,
+                                                 gboolean enslaved,
+                                                 gboolean master_failed);
 
 void *		nm_device_get_system_config_data	(NMDevice *dev);
 
@@ -183,6 +190,8 @@ void nm_device_queue_state   (NMDevice *self,
 
 void			nm_device_activate_schedule_stage1_device_prepare		(NMDevice *device);
 void			nm_device_activate_schedule_stage2_device_config		(NMDevice *device);
+gboolean		nm_device_activate_stage3_ip4_start                     (NMDevice *self);
+gboolean		nm_device_activate_stage3_ip6_start                     (NMDevice *self);
 void			nm_device_activate_schedule_stage4_ip4_config_get		(NMDevice *device);
 void			nm_device_activate_schedule_stage4_ip4_config_timeout	(NMDevice *device);
 void			nm_device_activate_schedule_stage4_ip6_config_get		(NMDevice *device);
diff --git a/src/nm-manager.c b/src/nm-manager.c
index b838997..40576d7 100644
--- a/src/nm-manager.c
+++ b/src/nm-manager.c
@@ -47,6 +47,7 @@
 #include "nm-device-gsm.h"
 #include "nm-device-infiniband.h"
 #include "nm-device-bond.h"
+#include "nm-device-bridge.h"
 #include "nm-device-vlan.h"
 #include "nm-system.h"
 #include "nm-properties-changed-signal.h"
@@ -135,7 +136,7 @@ static const char *internal_activate_device (NMManager *manager,
                                              const char *specific_object,
                                              gboolean user_requested,
                                              gboolean assumed,
-                                             NMActRequest *dependency,
+                                             NMActRequest *master,
                                              GError **error);
 
 static NMDevice *find_device_by_iface (NMManager *self, const gchar *iface);
@@ -243,7 +244,8 @@ typedef struct {
 
 	guint timestamp_update_id;
 
-	gboolean bond_vlan_enabled;
+	/* bond/bridge/vlan enabled */
+	gboolean bbv_enabled;
 
 	gboolean disposed;
 } NMManagerPrivate;
@@ -1566,12 +1568,15 @@ get_virtual_iface_name (NMManager *self,
 	if (out_parent)
 		*out_parent = NULL;
 
-	if (!NM_MANAGER_GET_PRIVATE (self)->bond_vlan_enabled)
+	if (!NM_MANAGER_GET_PRIVATE (self)->bbv_enabled)
 		return NULL;
 
 	if (nm_connection_is_type (connection, NM_SETTING_BOND_SETTING_NAME))
 		return g_strdup (nm_connection_get_virtual_iface_name (connection));
 
+	if (nm_connection_is_type (connection, NM_SETTING_BRIDGE_SETTING_NAME))
+		return g_strdup (nm_connection_get_virtual_iface_name (connection));
+
 	if (nm_connection_is_type (connection, NM_SETTING_VLAN_SETTING_NAME)) {
 		NMSettingVlan *s_vlan;
 		const char *ifname;
@@ -1612,9 +1617,9 @@ get_virtual_iface_name (NMManager *self,
 static gboolean
 connection_needs_virtual_device (NMConnection *connection)
 {
-	if (nm_connection_is_type (connection, NM_SETTING_BOND_SETTING_NAME))
-		return TRUE;
-	if (nm_connection_is_type (connection, NM_SETTING_VLAN_SETTING_NAME))
+	if (   nm_connection_is_type (connection, NM_SETTING_BOND_SETTING_NAME)
+	    || nm_connection_is_type (connection, NM_SETTING_BRIDGE_SETTING_NAME)
+	    || nm_connection_is_type (connection, NM_SETTING_VLAN_SETTING_NAME))
 		return TRUE;
 
 	return FALSE;
@@ -1646,7 +1651,7 @@ system_create_virtual_device (NMManager *self, NMConnection *connection)
 	char *iface = NULL, *udi;
 	NMDevice *device = NULL, *parent = NULL;
 
-	if (!priv->bond_vlan_enabled)
+	if (!priv->bbv_enabled)
 		return NULL;
 
 	iface = get_virtual_iface_name (self, connection, &parent);
@@ -1679,6 +1684,16 @@ system_create_virtual_device (NMManager *self, NMConnection *connection)
 		udi = get_virtual_iface_placeholder_udi ();
 		device = nm_device_bond_new (udi, iface);
 		g_free (udi);
+	} else if (nm_connection_is_type (connection, NM_SETTING_BRIDGE_SETTING_NAME)) {
+		if (!nm_system_create_bridge (iface)) {
+			nm_log_warn (LOGD_DEVICE, "(%s): failed to add bridging interface for '%s'",
+			             iface, nm_connection_get_id (connection));
+			goto out;
+		}
+
+		udi = get_virtual_iface_placeholder_udi ();
+		device = nm_device_bridge_new (udi, iface);
+		g_free (udi);
 	} else if (nm_connection_is_type (connection, NM_SETTING_VLAN_SETTING_NAME)) {
 		g_return_val_if_fail (parent != NULL, FALSE);
 
@@ -1706,7 +1721,7 @@ system_create_virtual_devices (NMManager *self)
 	NMManagerPrivate *priv = NM_MANAGER_GET_PRIVATE (self);
 	GSList *iter, *connections;
 
-	if (!priv->bond_vlan_enabled)
+	if (!priv->bbv_enabled)
 		return;
 
 	nm_log_dbg (LOGD_CORE, "creating virtual devices...");
@@ -2823,6 +2838,12 @@ is_bond (int ifindex)
 }
 
 static gboolean
+is_bridge (int ifindex)
+{
+	return (nm_system_get_iface_type (ifindex, NULL) == NM_IFACE_TYPE_BRIDGE);
+}
+
+static gboolean
 is_vlan (int ifindex)
 {
 	return (nm_system_get_iface_type (ifindex, NULL) == NM_IFACE_TYPE_VLAN);
@@ -2862,10 +2883,15 @@ udev_device_added_cb (NMUdevManager *udev_mgr,
 	else if (is_infiniband (udev_device))
 		device = nm_device_infiniband_new (sysfs_path, iface, driver);
 	else if (is_bond (ifindex)) {
-		if (priv->bond_vlan_enabled)
+		if (priv->bbv_enabled)
 			device = nm_device_bond_new (sysfs_path, iface);
 		else
-			nm_log_dbg (LOGD_HW, "(%s): ignoring because NM_BOND_VLAN_ENABLED not set", iface);
+			nm_log_dbg (LOGD_HW, "(%s): ignoring because NM_BOND_BRIDGE_VLAN_ENABLED not set", iface);
+	} else if (is_bridge (ifindex)) {
+		if (priv->bbv_enabled)
+			device = nm_device_bridge_new (sysfs_path, iface);
+		else
+			nm_log_dbg (LOGD_HW, "(%s): ignoring because NM_BOND_BRIDGE_VLAN_ENABLED not set", iface);
 	} else if (is_vlan (ifindex)) {
 		int parent_ifindex = -1;
 		NMDevice *parent;
@@ -2874,10 +2897,10 @@ udev_device_added_cb (NMUdevManager *udev_mgr,
 		if (nm_system_get_iface_vlan_info (ifindex, &parent_ifindex, NULL)) {
 			parent = find_device_by_ifindex (self, parent_ifindex);
 			if (parent) {
-				if (priv->bond_vlan_enabled)
+				if (priv->bbv_enabled)
 					device = nm_device_vlan_new (sysfs_path, iface, parent);
 				else
-					nm_log_dbg (LOGD_HW, "(%s): ignoring because NM_BOND_VLAN_ENABLED not set", iface);
+					nm_log_dbg (LOGD_HW, "(%s): ignoring because NM_BOND_BRIDGE_VLAN_ENABLED not set", iface);
 			} else {
 				/* If udev signaled the VLAN interface before it signaled
 				 * the VLAN's parent at startup we may not know about the
@@ -3269,12 +3292,12 @@ internal_activate_device (NMManager *manager,
                           const char *specific_object,
                           gboolean user_requested,
                           gboolean assumed,
-                          NMActRequest *dependency,
+                          NMActRequest *master,
                           GError **error)
 {
 	NMActRequest *req;
 	NMDeviceInterface *dev_iface;
-	gboolean success;
+	NMDevice *master_device = NULL;
 
 	g_return_val_if_fail (NM_IS_MANAGER (manager), NULL);
 	g_return_val_if_fail (NM_IS_DEVICE (device), NULL);
@@ -3288,18 +3311,45 @@ internal_activate_device (NMManager *manager,
 
 	/* Tear down any existing connection */
 	if (nm_device_get_act_request (device)) {
-		nm_device_state_changed (device,
-		                         NM_DEVICE_STATE_DISCONNECTED,
-		                         NM_DEVICE_STATE_REASON_NONE);
+		NMConnection *dev_con = nm_device_get_connection (device);
+		NMSettingConnection *s_con;
+
+		/* Suppress reactivations of virtual interfaces or their slaves while
+		 * the interface is already activating, as 60-net.rules will call back
+		 * into NM via ifup when udev finds the new virtual interface.  Which
+		 * deactivates the interface in the middle of bringing it up.
+		 */
+		s_con = nm_connection_get_setting_connection (dev_con);
+		g_assert (s_con);
+
+		if (   nm_setting_connection_get_slave_type (s_con)
+		    || connection_needs_virtual_device (dev_con)) {
+			nm_log_dbg (LOGD_DEVICE, "(%s): suppressing reactivation request while activating",
+				        nm_device_get_iface (device));
+			g_set_error_literal (error,
+			                     NM_DEVICE_INTERFACE_ERROR,
+			                     NM_DEVICE_INTERFACE_ERROR_CONNECTION_ACTIVATING,
+			                     "A connection is already activating on this device.");
+			return NULL;
+		} else {
+			nm_log_dbg (LOGD_DEVICE, "(%s): deactivating due to new activation request",
+				        nm_device_get_iface (device));
+			nm_device_state_changed (device,
+				                     NM_DEVICE_STATE_DISCONNECTED,
+				                     NM_DEVICE_STATE_REASON_NONE);
+		}
 	}
 
-	req = nm_act_request_new (connection, specific_object, user_requested, assumed, (gpointer) device, dependency);
+	if (master)
+		master_device = (NMDevice *) nm_act_request_get_device (master);
+
+	req = nm_act_request_new (connection, specific_object, user_requested, assumed, (gpointer) device, (gpointer) master_device);
 	g_signal_connect (req, "manager-get-secrets", G_CALLBACK (provider_get_secrets), manager);
 	g_signal_connect (req, "manager-cancel-secrets", G_CALLBACK (provider_cancel_secrets), manager);
-	success = nm_device_interface_activate (dev_iface, req, error);
+	nm_device_interface_activate (dev_iface, req);
 	g_object_unref (req);
 
-	return success ? nm_act_request_get_active_connection_path (req) : NULL;
+	return nm_act_request_get_active_connection_path (req);
 }
 
 static gboolean
@@ -5564,22 +5614,28 @@ nm_manager_init (NMManager *manager)
 	/* Update timestamps in active connections */
 	priv->timestamp_update_id = g_timeout_add_seconds (300, (GSourceFunc) periodic_update_active_connection_timestamps, manager);
 
-	/* Check whether we're supposed to manage bonds and VLAN interfaces */
+	/* Check whether we're supposed to manage bonds, bridges, and VLAN interfaces */
 #define BV_ENABLED_KEY "NM_BOND_VLAN_ENABLED"
+#define BBV_ENABLED_KEY "NM_BOND_BRIDGE_VLAN_ENABLED"
 	if (g_file_get_contents (SYSCONFDIR "/sysconfig/network", &contents, NULL, NULL) && contents) {
 		p = strcasestr (contents, BV_ENABLED_KEY);
-		if (p) {
+		if (p)
 			p += strlen (BV_ENABLED_KEY);
-			if (*p++ == '=') {
-				if (   strcasecmp (p, "yes") == 0
-				    || strcasestr (p, "y")
-				    || strcasestr (p, "true"))
-					priv->bond_vlan_enabled = TRUE;
-			}
+		else {
+			p = strcasestr (contents, BBV_ENABLED_KEY);
+			if (p)
+				p += strlen (BBV_ENABLED_KEY);
+		}
+
+		if (p && *p++ == '=') {
+			if (   strcasecmp (p, "yes") == 0
+			    || strcasestr (p, "y")
+			    || strcasestr (p, "true"))
+				priv->bbv_enabled = TRUE;
 		}
 		g_free (contents);
 	}
-	nm_log_info (LOGD_HW, "Bonding/VLAN support %s", priv->bond_vlan_enabled ? "enabled" : "disabled");
+	nm_log_info (LOGD_HW, "Bonding/Bridging/VLAN support %s", priv->bbv_enabled ? "enabled" : "disabled");
 }
 
 static void
diff --git a/src/nm-netlink-monitor.c b/src/nm-netlink-monitor.c
index 15faf6a..25a8c96 100644
--- a/src/nm-netlink-monitor.c
+++ b/src/nm-netlink-monitor.c
@@ -33,10 +33,14 @@
 #include <sys/types.h>
 #include <sys/socket.h>
 #include <sys/stat.h>
+#include <sys/ioctl.h>
 #include <linux/types.h>
 #include <linux/netlink.h>
 #include <linux/rtnetlink.h>
 #include <linux/if.h>
+#include <linux/if_bonding.h>
+#include <linux/if_bridge.h>
+#include <linux/sockios.h>
 #include <linux/unistd.h>
 #include <unistd.h>
 #include <netlink/object-api.h>
@@ -763,12 +767,14 @@ nm_netlink_get_iface_type (int ifindex, const char *name)
 {
 	NMNetlinkMonitor *self;
 	NMNetlinkMonitorPrivate *priv;
-	struct rtnl_link *ret;
+	struct rtnl_link *ret = NULL;
 	int res = NM_IFACE_TYPE_UNSPEC;
-	char *type;
-	char *path, *ifname;
-	guint flags;
+	char *type, *path;
+	struct vlan_ioctl_args ifv;
+	struct ifreq ifr;
+	struct ifbond ifb;
 	struct stat st;
+	int fd = -1;
 
 	self = nm_netlink_monitor_get ();
 	priv = NM_NETLINK_MONITOR_GET_PRIVATE (self);
@@ -777,7 +783,7 @@ nm_netlink_get_iface_type (int ifindex, const char *name)
 
 	if (ifindex >= 0)
 		ret = rtnl_link_get (priv->link_cache, ifindex);
-	else
+	else if (name)
 		ret = rtnl_link_get_by_name (priv->link_cache, name);
 
 	if (!ret)
@@ -789,6 +795,8 @@ nm_netlink_get_iface_type (int ifindex, const char *name)
 			res = NM_IFACE_TYPE_BOND;
 		else if (!g_strcmp0 (type, "vlan"))
 			res = NM_IFACE_TYPE_VLAN;
+		else if (!g_strcmp0 (type, "bridge"))
+			res = NM_IFACE_TYPE_BRIDGE;
 		else if (!g_strcmp0 (type, "dummy"))
 			res = NM_IFACE_TYPE_DUMMY;
 		goto out;
@@ -797,26 +805,42 @@ nm_netlink_get_iface_type (int ifindex, const char *name)
 	/* 'type' might only be valid on newer kernels, so fall back to checking
 	 * interface flags and various type-specific directories.
 	 */
-	ifname = nm_netlink_index_to_iface (ifindex);
-	if (ifname == NULL) {
-		nm_log_err (LOGD_HW, "Failed to look up interface name for index %d", ifindex);
+	if (!name)
+		name = rtnl_link_get_name (ret);
+
+	if ((fd = socket (AF_INET, SOCK_STREAM, 0)) < 0) {
+		nm_log_err (LOGD_DEVICE, "couldn't open control socket.");
 		goto out;
 	}
 
-	flags = rtnl_link_get_flags (ret);
-	if (flags & IFF_MASTER) {
-		/* Both the 'bonding' and the 'eql' driver set IFF_MASTER, and we
-		 * don't want 'eql' devices, so check sysfs for the bonding directory.
-		 */
-		path = g_strdup_printf ("/sys/class/net/%s/bonding", ifname);
-		g_assert (path);
-		if ((stat (path, &st) == 0) && S_ISDIR (st.st_mode))
-			res = NM_IFACE_TYPE_BOND;
-		g_free (path);
+	/* Check VLAN */
+	memset (&ifv, 0, sizeof (ifv));
+	ifv.cmd = GET_VLAN_VID_CMD;
+	strncpy (ifv.device1, name, sizeof (ifv.device1) - 1);
+	if (ioctl (fd, SIOCGIFVLAN, &ifv) == 0) {
+		res = NM_IFACE_TYPE_VLAN;
+		goto out;
 	}
-	g_free (ifname);
+
+	/* and bond */
+	memset (&ifr, 0, sizeof (ifr));
+	strncpy (ifr.ifr_name, name, sizeof (ifr.ifr_name) - 1);
+	memset (&ifb, 0, sizeof (ifb));
+	ifr.ifr_data = (caddr_t) &ifb;
+	if (ioctl (fd, SIOCBONDINFOQUERY, &ifr) == 0) {
+		res = NM_IFACE_TYPE_BOND;
+		goto out;
+	}
+
+	/* and bridge */
+	path = g_strdup_printf ("/sys/class/net/%s/bridge", name);
+	if ((stat (path, &st) == 0) && S_ISDIR (st.st_mode))
+		res = NM_IFACE_TYPE_BRIDGE;
+	g_free (path);
 
 out:
+	if (fd >= 0)
+		close (fd);
 	if (ret)
 		rtnl_link_put (ret);
 	g_object_unref (self);
diff --git a/src/nm-system.c b/src/nm-system.c
index 09f4c11..36a2c68 100644
--- a/src/nm-system.c
+++ b/src/nm-system.c
@@ -44,6 +44,7 @@
 #include <linux/if.h>
 #include <linux/sockios.h>
 #include <linux/if_bonding.h>
+#include <linux/if_bridge.h>
 
 #include "nm-system.h"
 #include "nm-device.h"
@@ -1581,6 +1582,7 @@ nm_system_add_bonding_master (const char *iface)
 	char cmd[IFNAMSIZ+2];
 	struct stat st;
 	int ignored;
+	gboolean success;
 
 	g_return_val_if_fail (iface != NULL, FALSE);
 
@@ -1589,11 +1591,18 @@ nm_system_add_bonding_master (const char *iface)
 		ignored = system ("/sbin/modprobe bonding");
 
 	snprintf (cmd, sizeof (cmd), "+%s", iface);
-	return nm_utils_do_sysctl ("/sys/class/net/bonding_masters", cmd);
+	success = nm_utils_do_sysctl ("/sys/class/net/bonding_masters", cmd);
+
+	/* Ignore the error if the bond already exists */
+	if (success || errno == EEXIST)
+		return TRUE;
+
+	/* Unhandled error */
+	return FALSE;
 }
 
 static gboolean
-nm_system_iface_compat_enslave (const char *master_iface, const char *slave_iface)
+nm_system_bond_compat_enslave (const char *master_iface, const char *slave_iface)
 {
 	struct ifreq ifr;
 	int fd;
@@ -1658,7 +1667,7 @@ nm_system_iface_compat_enslave (const char *master_iface, const char *slave_ifac
 }
 
 /**
- * nm_system_iface_enslave:
+ * nm_system_bond_enslave:
  * @master_ifindex: master device interface index
  * @master_iface: master device interface name
  * @slave_ifindex: slave device interface index
@@ -1674,10 +1683,10 @@ nm_system_iface_compat_enslave (const char *master_iface, const char *slave_ifac
  * Returns: %TRUE on success, or %FALSE
  */
 gboolean
-nm_system_iface_enslave (gint master_ifindex,
-                         const char *master_iface,
-                         gint slave_ifindex,
-                         const char *slave_iface)
+nm_system_bond_enslave (gint master_ifindex,
+                        const char *master_iface,
+                        gint slave_ifindex,
+                        const char *slave_iface)
 {
 	struct nl_handle *sock;
 
@@ -1696,16 +1705,30 @@ nm_system_iface_enslave (gint master_ifindex,
 	g_assert (!nm_system_device_is_up_with_iface (slave_iface));
 
 	if (nm_system_iface_get_flags (slave_ifindex) & IFF_SLAVE) {
-		nm_log_err (LOGD_DEVICE, "(%s): %s is already a slave",
+		char *path, *contents = NULL;
+		int check_ifindex = -1;
+
+		/* Check if the device is already a slave of the master */
+		path = g_strdup_printf ("/sys/class/net/%s/master/ifindex", slave_iface);
+		if (g_file_get_contents (path, &contents, NULL, NULL)) {
+			check_ifindex = atoi (contents);
+			g_free (contents);
+		}
+		g_free (path);
+
+		if (check_ifindex == master_ifindex)
+			return TRUE;
+
+		nm_log_err (LOGD_DEVICE, "(%s): %s is already a slave of a different device",
 		            master_iface, slave_iface);
 		return FALSE;
 	}
 
-	return nm_system_iface_compat_enslave (master_iface, slave_iface);
+	return nm_system_bond_compat_enslave (master_iface, slave_iface);
 }
 
 static gboolean
-nm_system_iface_compat_release (const char *master_iface, const char *slave_iface)
+nm_system_bond_compat_release (const char *master_iface, const char *slave_iface)
 {
 	struct ifreq ifr;
 	int fd;
@@ -1734,7 +1757,7 @@ nm_system_iface_compat_release (const char *master_iface, const char *slave_ifac
 }
 
 /**
- * nm_system_iface_release:
+ * nm_system_bond_release:
  * @master_ifindex: master device interface index
  * @master_iface: master device interface name
  * @slave_ifindex: slave device interface index
@@ -1748,10 +1771,10 @@ nm_system_iface_compat_release (const char *master_iface, const char *slave_ifac
  * Returns: %TRUE on success, or %FALSE
  */
 gboolean
-nm_system_iface_release (gint master_ifindex,
-                         const char *master_iface,
-                         gint slave_ifindex,
-                         const char *slave_iface)
+nm_system_bond_release (gint master_ifindex,
+                        const char *master_iface,
+                        gint slave_ifindex,
+                        const char *slave_iface)
 {
 	struct nl_handle *sock;
 
@@ -1766,7 +1789,7 @@ nm_system_iface_release (gint master_ifindex,
 	if (!(nm_system_iface_get_flags (slave_ifindex) & IFF_SLAVE))
 		return TRUE;
 
-	return nm_system_iface_compat_release (master_iface, slave_iface);
+	return nm_system_bond_compat_release (master_iface, slave_iface);
 }
 
 /**
@@ -2182,3 +2205,248 @@ nm_system_del_vlan_iface (const char *iface)
 	nl_cache_free (cache);
 	return (ret == 0) ? TRUE : FALSE;
 }
+
+static int
+_bridge_create_compat (const char *iface)
+{
+	int ret = 0, fd;
+
+	if ((fd = socket (AF_LOCAL, SOCK_STREAM, 0)) < 0) {
+		nm_log_err (LOGD_DEVICE, "couldn't open control socket.");
+		return -EBADF;
+	}
+
+	if (ioctl (fd, SIOCBRADDBR, iface) < 0)
+		ret = -errno;
+
+	close (fd);
+	return ret;
+}
+
+/**
+ * nm_system_create_bridge:
+ * @iface: Name bridging device to create
+ *
+ * Creates a new bridging device in the kernel. If a bridging device with
+ * the specified name already exists, it is being reused.
+ *
+ * Returns: %TRUE on success, %FALSE on error.
+ */
+gboolean
+nm_system_create_bridge (const char *iface)
+{
+	int err;
+
+	/* FIXME: use netlink */
+	err = _bridge_create_compat (iface);
+	if (err < 0 && err != -EEXIST) {
+		nm_log_err (LOGD_DEVICE, "(%s): error while adding bridge: %s",
+		            iface, strerror (-err));
+		return FALSE;
+	}
+	return TRUE;
+}
+
+static int
+_bridge_del_compat (const char *iface)
+{
+	int ret = 0, fd;
+
+	if ((fd = socket (AF_LOCAL, SOCK_STREAM, 0)) < 0) {
+		nm_log_err (LOGD_DEVICE, "couldn't open control socket.");
+		return -EBADF;
+	}
+
+	if (ioctl (fd, SIOCBRDELBR, iface) < 0)
+		ret = -errno;
+
+	close (fd);
+	return ret;
+}
+
+/**
+ * nm_system_del_bridge:
+ * @iface: Name of bridging device to delete
+ *
+ * Deletes the specified bridging device in the kernel.
+ *
+ * Returns: %TRUE on success, %FALSE on error.
+ */
+gboolean
+nm_system_del_bridge (const char *iface)
+{
+	int err;
+
+	/* FIXME: use netlink */
+	err = _bridge_del_compat (iface);
+	if (err < 0 && err != -ENXIO) {
+		nm_log_err (LOGD_DEVICE, "(%s): error while deleting bridge: %s ",
+		            iface, strerror (-err));
+		return FALSE;
+	}
+	return TRUE;
+}
+
+static int
+_bridge_attach_compat (int master_ifindex,
+                       const char *master_iface,
+                       int slave_ifindex,
+                       const char *slave_iface)
+{
+	int ret = 0, fd;
+	struct ifreq ifr;
+
+	if ((fd = socket (AF_LOCAL, SOCK_STREAM, 0)) < 0) {
+		nm_log_err (LOGD_DEVICE, "couldn't open control socket.");
+		return -EBADF;
+	}
+
+	memset (&ifr, 0, sizeof (ifr));
+	strncpy (ifr.ifr_name, master_iface, IFNAMSIZ);
+	ifr.ifr_ifindex = slave_ifindex;
+	if (ioctl (fd, SIOCBRADDIF, &ifr) < 0)
+		ret = -errno;
+
+	close (fd);
+	return ret;
+}
+
+static int
+_bridge_detach_compat (int master_ifindex,
+                       const char *master_iface,
+                       int slave_ifindex,
+                       const char *slave_iface)
+{
+	int ret = 0, fd;
+	struct ifreq ifr;
+
+	if ((fd = socket (AF_LOCAL, SOCK_STREAM, 0)) < 0) {
+		nm_log_err (LOGD_DEVICE, "couldn't open control socket.");
+		return -EBADF;
+	}
+
+	memset (&ifr, 0, sizeof(ifr));
+	strncpy (ifr.ifr_name, master_iface, IFNAMSIZ);
+	ifr.ifr_ifindex = slave_ifindex;
+	if (ioctl (fd, SIOCBRDELIF, &ifr) < 0)
+		ret = -errno;
+
+	close (fd);
+	return ret;
+}
+
+/**
+ * nm_system_bridge_attach:
+ * @master_ifindex: master device interface index
+ * @master_iface: master device interface name
+ * @slave_ifindex: slave device interface index
+ * @slave_iface: slave device interface name
+ *
+ * Attaches interface 'slave' to bridge 'master'
+ *
+ * Returns: %TRUE on success, or %FALSE
+ */
+gboolean
+nm_system_bridge_attach (int master_ifindex,
+                         const char *master_iface,
+                         int slave_ifindex,
+                         const char *slave_iface)
+{
+	char *mif = NULL, *sif = NULL;
+	int err = -1;
+
+	g_return_val_if_fail (master_ifindex >= 0, FALSE);
+	g_return_val_if_fail (slave_ifindex >= 0, FALSE);
+
+	if (!master_iface) {
+		mif = nm_netlink_index_to_iface (master_ifindex);
+		if (mif == NULL) {
+			nm_log_err (LOGD_DEVICE, "interface name lookup failed for index %d", master_ifindex);
+			goto out;
+		}
+	}
+
+	if (!slave_ifindex) {
+		sif = nm_netlink_index_to_iface (slave_ifindex);
+		if (sif == NULL) {
+			nm_log_err (LOGD_DEVICE, "interface name lookup failed for index %d", slave_ifindex);
+			goto out;
+		}
+	}
+
+	/* FIXME: long term plan is to use netlink for this */
+	err = _bridge_attach_compat (master_ifindex,
+	                             mif ? mif : master_iface,
+	                             slave_ifindex,
+	                             sif ? sif : slave_iface);
+	if (err < 0) {
+		if (err == -EBUSY) {
+			/* Interface already attached to the given bridge */
+			err = 0;
+		} else {
+			nm_log_err (LOGD_DEVICE, "(%s): failed to attach slave %s: %s",
+			            master_iface, slave_iface, strerror (-err));
+		}
+	}
+
+out:
+	g_free (sif);
+	g_free (mif);
+	return err == 0 ? TRUE : FALSE;
+}
+
+/**
+ * nm_system_bridge_detach:
+ * @master_ifindex: master device interface index
+ * @master_iface: master device interface name
+ * @slave_ifindex: slave device interface index
+ * @slave_iface: slave device interface name
+ *
+ * Detaches the interface 'slave' from the bridge 'master'.
+ *
+ * Returns: %TRUE on success, or %FALSE
+ */
+gboolean
+nm_system_bridge_detach (int master_ifindex,
+                         const char *master_iface,
+                         int slave_ifindex,
+                         const char *slave_iface)
+{
+	char *mif = NULL, *sif = NULL;
+	int err = -1;
+
+	g_return_val_if_fail (master_ifindex >= 0, FALSE);
+	g_return_val_if_fail (slave_ifindex >= 0, FALSE);
+
+	if (!master_iface) {
+		mif = nm_netlink_index_to_iface (master_ifindex);
+		if (mif == NULL) {
+			nm_log_err (LOGD_DEVICE, "interface name lookup failed for index %d", master_ifindex);
+			goto out;
+		}
+	}
+
+	if (!slave_ifindex) {
+		sif = nm_netlink_index_to_iface (slave_ifindex);
+		if (sif == NULL) {
+			nm_log_err (LOGD_DEVICE, "interface name lookup failed for index %d", slave_ifindex);
+			goto out;
+		}
+	}
+
+	/* FIXME: long term plan is to use netlink for this */
+	err = _bridge_detach_compat (master_ifindex,
+	                             mif ? mif : master_iface,
+	                             slave_ifindex,
+	                             sif ? sif : slave_iface);
+	/* Kernel doesn't return an error detaching an already-detached interface */
+	if (err < 0) {
+		nm_log_err (LOGD_DEVICE, "(%s): failed to detach slave %s: %s",
+		            master_iface, slave_iface, strerror (-err));
+	}
+
+out:
+	g_free (mif);
+	g_free (sif);
+	return err == 0 ? TRUE : FALSE;
+}
diff --git a/src/nm-system.h b/src/nm-system.h
index 942435c..9c78dc9 100644
--- a/src/nm-system.h
+++ b/src/nm-system.h
@@ -98,11 +98,11 @@ gboolean        nm_system_apply_bonding_config          (const char *iface,
                                                          NMSettingBond *s_bond);
 gboolean        nm_system_add_bonding_master            (const char *iface);
 
-gboolean        nm_system_iface_enslave                 (gint master_ifindex,
+gboolean        nm_system_bond_enslave                  (gint master_ifindex,
                                                          const char *master_iface,
                                                          gint slave_ifindex,
                                                          const char *slave_iface);
-gboolean        nm_system_iface_release                 (gint master_ifindex,
+gboolean        nm_system_bond_release                  (gint master_ifindex,
                                                          const char *master_iface,
                                                          gint slave_ifindex,
                                                          const char *slave_iface);
@@ -111,7 +111,8 @@ enum {
 		NM_IFACE_TYPE_UNSPEC = 0,
 		NM_IFACE_TYPE_BOND,
 		NM_IFACE_TYPE_VLAN,
-		NM_IFACE_TYPE_DUMMY,
+		NM_IFACE_TYPE_BRIDGE,
+		NM_IFACE_TYPE_DUMMY
 };
 
 int             nm_system_get_iface_type      (int ifindex, const char *name);
@@ -125,5 +126,17 @@ gboolean        nm_system_add_vlan_iface (NMConnection *connection,
                                           int parent_ifindex);
 gboolean        nm_system_del_vlan_iface (const char *iface);
 
+gboolean        nm_system_create_bridge (const char *iface);
+gboolean        nm_system_del_bridge (const char *iface);
+
+gboolean        nm_system_bridge_attach (int master_ifindex,
+                                         const char *master_iface,
+                                         int slave_ifindex,
+                                         const char *slave_iface);
+gboolean        nm_system_bridge_detach (int master_ifindex,
+                                         const char *master_iface,
+                                         int slave_ifindex,
+                                         const char *slave_iface);
+
 
 #endif
diff --git a/src/nm-udev-manager.c b/src/nm-udev-manager.c
index 73cf4bd..fcd57cf 100644
--- a/src/nm-udev-manager.c
+++ b/src/nm-udev-manager.c
@@ -375,6 +375,9 @@ net_add (NMUdevManager *self, GUdevDevice *device)
 		case NM_IFACE_TYPE_BOND:
 			driver = "bonding";
 			break;
+		case NM_IFACE_TYPE_BRIDGE:
+			driver = "bridge";
+			break;
 		case NM_IFACE_TYPE_VLAN:
 			driver = "8021q";
 			break;
diff --git a/system-settings/plugins/ifcfg-rh/reader.c b/system-settings/plugins/ifcfg-rh/reader.c
index ced801a..a647da6 100644
--- a/system-settings/plugins/ifcfg-rh/reader.c
+++ b/system-settings/plugins/ifcfg-rh/reader.c
@@ -44,6 +44,8 @@
 #include <nm-connection.h>
 #include <NetworkManager.h>
 #include <nm-setting-bond.h>
+#include <nm-setting-bridge.h>
+#include <nm-setting-bridge-port.h>
 #include <nm-setting-connection.h>
 #include <nm-setting-ip4-config.h>
 #include <nm-setting-vlan.h>
@@ -105,12 +107,27 @@ static gboolean
 get_int (const char *str, int *value)
 {
 	char *e;
+	long int tmp;
 
 	errno = 0;
-	*value = strtol (str, &e, 0);
+	tmp = strtol (str, &e, 0);
 	if (errno || *e != '\0')
 		return FALSE;
+	*value = (int) tmp;
+	return TRUE;
+}
 
+static gboolean
+get_uint (const char *str, guint32 *value)
+{
+	char *e;
+	long unsigned int tmp;
+
+	errno = 0;
+	tmp = strtoul (str, &e, 0);
+	if (errno || *e != '\0')
+		return FALSE;
+	*value = (guint32) tmp;
 	return TRUE;
 }
 
@@ -197,6 +214,23 @@ make_connection_setting (const char *file,
 		g_free (value);
 	}
 
+	value = svGetValue (ifcfg, "BRIDGE", FALSE);
+	if (value) {
+		const char *bridge;
+
+		if ((bridge = nm_setting_connection_get_master (s_con))) {
+			PLUGIN_WARN (IFCFG_PLUGIN_NAME,
+			             "     warning: Already configured as slave of %s. "
+			             "Ignoring BRIDGE=\"%s\"", bridge, value);
+			g_free (value);
+		}
+
+		g_object_set (s_con, NM_SETTING_CONNECTION_MASTER, value, NULL);
+		g_object_set (s_con, NM_SETTING_CONNECTION_SLAVE_TYPE,
+		              NM_SETTING_BRIDGE_SETTING_NAME, NULL);
+		g_free (value);
+	}
+
 	return NM_SETTING (s_con);
 }
 
@@ -3592,6 +3626,232 @@ bond_connection_from_ifcfg (const char *file,
 	return connection;
 }
 
+typedef void (*BridgeOptFunc) (NMSetting *setting,
+                               gboolean stp,
+                               const char *key,
+                               const char *value);
+
+static void
+handle_bridge_option (NMSetting *setting,
+                      gboolean stp,
+                      const char *key,
+                      const char *value)
+{
+	guint32 u = 0;
+
+	if (!strcmp (key, "priority")) {
+		if (stp == FALSE) {
+			PLUGIN_WARN (IFCFG_PLUGIN_NAME, "    warning: 'priority' invalid when STP is disabled");
+		} else if (get_uint (value, &u))
+			g_object_set (setting, NM_SETTING_BRIDGE_PRIORITY, u, NULL);
+		else
+			PLUGIN_WARN (IFCFG_PLUGIN_NAME, "    warning: invalid priority value '%s'", value);
+	} else if (!strcmp (key, "hello_time")) {
+		if (stp == FALSE) {
+			PLUGIN_WARN (IFCFG_PLUGIN_NAME, "    warning: 'hello_time' invalid when STP is disabled");
+		} else if (get_uint (value, &u))
+			g_object_set (setting, NM_SETTING_BRIDGE_HELLO_TIME, u, NULL);
+		else
+			PLUGIN_WARN (IFCFG_PLUGIN_NAME, "    warning: invalid hello_time value '%s'", value);
+	} else if (!strcmp (key, "max_age")) {
+		if (stp == FALSE) {
+			PLUGIN_WARN (IFCFG_PLUGIN_NAME, "    warning: 'max_age' invalid when STP is disabled");
+		} else if (get_uint (value, &u))
+			g_object_set (setting, NM_SETTING_BRIDGE_MAX_AGE, u, NULL);
+		else
+			PLUGIN_WARN (IFCFG_PLUGIN_NAME, "    warning: invalid max_age value '%s'", value);
+	} else if (!strcmp (key, "ageing_time")) {
+		if (get_uint (value, &u))
+			g_object_set (setting, NM_SETTING_BRIDGE_AGEING_TIME, u, NULL);
+		else
+			PLUGIN_WARN (IFCFG_PLUGIN_NAME, "    warning: invalid ageing_time value '%s'", value);
+	} else
+			PLUGIN_WARN (IFCFG_PLUGIN_NAME, "    warning: unhandled bridge option '%s'", key);
+}
+
+static void
+handle_bridging_opts (NMSetting *setting,
+                      gboolean stp,
+                      const char *value,
+                      BridgeOptFunc func)
+{
+	char **items, **iter;
+
+	items = g_strsplit_set (value, " ", -1);
+	for (iter = items; iter && *iter; iter++) {
+		if (strlen (*iter)) {
+			char **keys, *key, *val;
+
+			keys = g_strsplit_set (*iter, "=", 2);
+			if (keys && *keys) {
+				key = *keys;
+				val = *(keys + 1);
+				if (val && strlen(key) && strlen(val))
+					func (setting, stp, key, val);
+			}
+
+			g_strfreev (keys);
+		}
+	}
+	g_strfreev (items);
+}
+
+static NMSetting *
+make_bridge_setting (shvarFile *ifcfg,
+                     const char *file,
+                     gboolean nm_controlled,
+                     char **unmanaged,
+                     GError **error)
+{
+	NMSettingBridge *s_bridge;
+	char *value;
+	guint32 u;
+	gboolean stp = FALSE;
+
+	s_bridge = NM_SETTING_BRIDGE (nm_setting_bridge_new ());
+
+	value = svGetValue (ifcfg, "DEVICE", FALSE);
+	if (!value || !strlen (value)) {
+		g_set_error (error, IFCFG_PLUGIN_ERROR, 0, "mandatory DEVICE keyword missing");
+		goto error;
+	}
+
+	g_object_set (s_bridge, NM_SETTING_BRIDGE_INTERFACE_NAME, value, NULL);
+	g_free (value);
+
+	value = svGetValue (ifcfg, "STP", FALSE);
+	if (value) {
+		if (!strcasecmp (value, "on") || !strcasecmp (value, "yes")) {
+			g_object_set (s_bridge, NM_SETTING_BRIDGE_STP, TRUE, NULL);
+			stp = TRUE;
+		} else if (!strcasecmp (value, "off") || !strcasecmp (value, "no"))
+			g_object_set (s_bridge, NM_SETTING_BRIDGE_STP, FALSE, NULL);
+		else
+			PLUGIN_WARN (IFCFG_PLUGIN_NAME, "    warning: invalid STP value '%s'", value);
+		g_free (value);
+	}
+
+	value = svGetValue (ifcfg, "DELAY", FALSE);
+	if (value) {
+		if (stp) {
+			if (get_uint (value, &u))
+				g_object_set (s_bridge, NM_SETTING_BRIDGE_FORWARD_DELAY, u, NULL);
+			else
+				PLUGIN_WARN (IFCFG_PLUGIN_NAME, "    warning: invalid forward delay value '%s'", value);
+		} else
+			PLUGIN_WARN (IFCFG_PLUGIN_NAME, "    warning: DELAY invalid when STP is disabled");
+		g_free (value);
+	}
+
+	value = svGetValue (ifcfg, "BRIDGING_OPTS", FALSE);
+	if (value) {
+		handle_bridging_opts (NM_SETTING (s_bridge), stp, value, handle_bridge_option);
+		g_free (value);
+	}
+
+	return (NMSetting *) s_bridge;
+
+error:
+	g_object_unref (s_bridge);
+	return NULL;
+}
+
+static NMConnection *
+bridge_connection_from_ifcfg (const char *file,
+                              shvarFile *ifcfg,
+                              gboolean nm_controlled,
+                              char **unmanaged,
+                              GError **error)
+{
+	NMConnection *connection = NULL;
+	NMSetting *con_setting = NULL;
+	NMSetting *bridge_setting = NULL;
+
+	g_return_val_if_fail (file != NULL, NULL);
+	g_return_val_if_fail (ifcfg != NULL, NULL);
+
+	connection = nm_connection_new ();
+	if (!connection) {
+		g_set_error (error, IFCFG_PLUGIN_ERROR, 0,
+		             "Failed to allocate new connection for %s.", file);
+		return NULL;
+	}
+
+	con_setting = make_connection_setting (file, ifcfg, NM_SETTING_BRIDGE_SETTING_NAME, NULL, _("Bridge"));
+	if (!con_setting) {
+		g_set_error (error, IFCFG_PLUGIN_ERROR, 0,
+		             "Failed to create connection setting.");
+		g_object_unref (connection);
+		return NULL;
+	}
+	nm_connection_add_setting (connection, con_setting);
+
+	bridge_setting = make_bridge_setting (ifcfg, file, nm_controlled, unmanaged, error);
+	if (!bridge_setting) {
+		g_object_unref (connection);
+		return NULL;
+	}
+	nm_connection_add_setting (connection, bridge_setting);	
+
+	if (!nm_connection_verify (connection, error)) {
+		g_object_unref (connection);
+		return NULL;
+	}
+
+	return connection;
+}
+
+static void
+handle_bridge_port_option (NMSetting *setting,
+                           gboolean stp,
+                           const char *key,
+                           const char *value)
+{
+	guint32 u = 0;
+
+	if (!strcmp (key, "priority")) {
+		if (get_uint (value, &u))
+			g_object_set (setting, NM_SETTING_BRIDGE_PORT_PRIORITY, u, NULL);
+		else
+			PLUGIN_WARN (IFCFG_PLUGIN_NAME, "    warning: invalid priority value '%s'", value);
+	} else if (!strcmp (key, "path_cost")) {
+		if (get_uint (value, &u))
+			g_object_set (setting, NM_SETTING_BRIDGE_PORT_PATH_COST, u, NULL);
+		else
+			PLUGIN_WARN (IFCFG_PLUGIN_NAME, "    warning: invalid path_cost value '%s'", value);
+	} else if (!strcmp (key, "hairpin_mode")) {
+		if (!strcasecmp (value, "on") || !strcasecmp (value, "yes") || !strcmp (value, "1"))
+			g_object_set (setting, NM_SETTING_BRIDGE_PORT_HAIRPIN_MODE, TRUE, NULL);
+		else if (!strcasecmp (value, "off") || !strcasecmp (value, "no"))
+			g_object_set (setting, NM_SETTING_BRIDGE_PORT_HAIRPIN_MODE, FALSE, NULL);
+		else
+			PLUGIN_WARN (IFCFG_PLUGIN_NAME, "    warning: invalid hairpin_mode value '%s'", value);
+	} else
+			PLUGIN_WARN (IFCFG_PLUGIN_NAME, "    warning: unhandled bridge port option '%s'", key);
+}
+
+static NMSetting *
+make_bridge_port_setting (shvarFile *ifcfg, GError **error)
+{
+	NMSetting *s_port;
+	char *value;
+
+	value = svGetValue (ifcfg, "BRIDGE", FALSE);
+	if (!value)
+		return NULL;
+	g_free (value);
+
+	s_port = nm_setting_bridge_port_new ();
+
+	value = svGetValue (ifcfg, "BRIDGING_OPTS", FALSE);
+	if (value) {
+		handle_bridging_opts (s_port, FALSE, value, handle_bridge_port_option);
+		g_free (value);
+	}
+
+	return s_port;
+}
+
 static gboolean
 is_bond_device (const char *name, shvarFile *parsed)
 {
@@ -3838,13 +4098,12 @@ connection_from_file (const char *filename,
 {
 	NMConnection *connection = NULL;
 	shvarFile *parsed;
-	char *type, *nmc = NULL, *bootproto, *tmp;
-	NMSetting *s_ip4, *s_ip6;
+	char *type, *nmc = NULL, *bootproto;
+	NMSetting *s_ip4, *s_ip6, *s_port;
 	const char *ifcfg_name = NULL;
 	gboolean nm_controlled = TRUE;
 	gboolean can_disable_ip4 = FALSE;
 	GError *error = NULL;
-	guint32 ignore_reason = IGNORE_REASON_NONE;
 
 	g_return_val_if_fail (filename != NULL, NULL);
 	g_return_val_if_fail (unmanaged != NULL, NULL);
@@ -3939,14 +4198,6 @@ connection_from_file (const char *filename,
 		g_free (lower);
 	}
 
-	/* Ignore BRIDGE= connections for now too (rh #619863) */
-	tmp = svGetValue (parsed, "BRIDGE", FALSE);
-	if (tmp) {
-		g_free (tmp);
-		nm_controlled = FALSE;
-		ignore_reason = IGNORE_REASON_BRIDGE;
-	}
-
 	/* Construct the connection */
 	if (!strcasecmp (type, TYPE_ETHERNET))
 		connection = wired_connection_from_ifcfg (filename, parsed, nm_controlled, unmanaged, &error);
@@ -3959,8 +4210,7 @@ connection_from_file (const char *filename,
 	else if (!strcasecmp (type, TYPE_VLAN))
 		connection = vlan_connection_from_ifcfg (filename, parsed, nm_controlled, unmanaged, &error);
 	else if (!strcasecmp (type, TYPE_BRIDGE)) {
-		g_set_error (&error, IFCFG_PLUGIN_ERROR, 0,
-		             "Bridge connections are not yet supported");
+		connection = bridge_connection_from_ifcfg (filename, parsed, nm_controlled, unmanaged, &error);
 	} else {
 		g_set_error (&error, IFCFG_PLUGIN_ERROR, 0,
 		             "Unknown connection type '%s'", type);
@@ -3974,24 +4224,8 @@ connection_from_file (const char *filename,
 	g_free (type);
 
 	/* Don't bother reading the connection fully if it's unmanaged or ignored */
-	if (!connection || *unmanaged || ignore_reason) {
-		if (connection && !*unmanaged) {
-			/* However,BRIDGE and VLAN connections that don't have HWADDR won't
-			 * be unmanaged because the unmanaged state is keyed off HWADDR.
-			 * They willl still be tagged 'ignore' from code that checks BRIDGE
-			 * and VLAN above.  Since they aren't marked unmanaged, kill them
-			 * completely.
-			 */
-			if (ignore_reason) {
-				g_object_unref (connection);
-				connection = NULL;
-				g_set_error (&error, IFCFG_PLUGIN_ERROR, 0,
-				             "%s connections are not yet supported",
-				             ignore_reason == IGNORE_REASON_BRIDGE ? "Bridge" : "VLAN");
-			}
-		}
+	if (!connection || *unmanaged)
 		goto done;
-	}
 
 	s_ip6 = make_ip6_setting (parsed, network_file, iscsiadm_path, &error);
 	if (error) {
@@ -4021,6 +4255,15 @@ connection_from_file (const char *filename,
 	} else if (s_ip4)
 		nm_connection_add_setting (connection, s_ip4);
 
+	/* Bridge port? */
+	s_port = make_bridge_port_setting (parsed, &error);
+	if (error) {
+		g_object_unref (connection);
+		connection = NULL;
+		goto done;
+	} else if (s_port)
+		nm_connection_add_setting (connection, s_port);
+
 	/* iSCSI / ibft connections are read-only since their settings are
 	 * stored in NVRAM and can only be changed in BIOS.
 	 */
diff --git a/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-bridge-component b/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-bridge-component
index f586637..24b5122 100644
--- a/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-bridge-component
+++ b/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-bridge-component
@@ -2,4 +2,4 @@ DEVICE=eth0
 HWADDR=00:22:15:59:62:97
 ONBOOT=no
 BRIDGE=br0
-
+BRIDGING_OPTS="priority=28 hairpin_mode=1 path_cost=100"
diff --git a/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-bridge-main b/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-bridge-main
index c5caf3f..c406bbb 100644
--- a/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-bridge-main
+++ b/system-settings/plugins/ifcfg-rh/tests/network-scripts/ifcfg-test-bridge-main
@@ -4,4 +4,4 @@ TYPE=Bridge
 BOOTPROTO=dhcp
 STP=on
 DELAY=0
-
+BRIDGING_OPTS="priority=32744 hello_time=7 max_age=39 ageing_time=235352"
diff --git a/system-settings/plugins/ifcfg-rh/tests/test-ifcfg-rh.c b/system-settings/plugins/ifcfg-rh/tests/test-ifcfg-rh.c
index 6235753..dcf684f 100644
--- a/system-settings/plugins/ifcfg-rh/tests/test-ifcfg-rh.c
+++ b/system-settings/plugins/ifcfg-rh/tests/test-ifcfg-rh.c
@@ -9808,6 +9808,7 @@ static void
 test_read_bridge_main (void)
 {
 	NMConnection *connection;
+	NMSettingBridge *s_bridge;
 	char *unmanaged = NULL;
 	char *keyfile = NULL;
 	char *routefile = NULL;
@@ -9825,8 +9826,140 @@ test_read_bridge_main (void)
 	                                   &route6file,
 	                                   &error,
 	                                   &ignore_error);
-	ASSERT (connection == NULL,
-	        "bridge-main-read", "unexpected success reading %s", TEST_IFCFG_BRIDGE_MAIN);
+	g_assert (connection);
+	g_assert (nm_connection_verify (connection, &error));
+	g_assert_no_error (error);
+
+	/* ===== Bridging SETTING ===== */
+
+	s_bridge = nm_connection_get_setting_bridge (connection);
+	g_assert (s_bridge);
+	g_assert_cmpstr (nm_setting_bridge_get_interface_name (s_bridge), ==, "br0");
+	g_assert_cmpuint (nm_setting_bridge_get_forward_delay (s_bridge), ==, 0);
+	g_assert_cmpuint (nm_setting_bridge_get_stp (s_bridge), ==, TRUE);
+	g_assert_cmpuint (nm_setting_bridge_get_priority (s_bridge), ==, 32744);
+	g_assert_cmpuint (nm_setting_bridge_get_hello_time (s_bridge), ==, 7);
+	g_assert_cmpuint (nm_setting_bridge_get_max_age (s_bridge), ==, 39);
+	g_assert_cmpuint (nm_setting_bridge_get_ageing_time (s_bridge), ==, 235352);
+
+	g_free (unmanaged);
+	g_free (keyfile);
+	g_free (routefile);
+	g_free (route6file);
+	g_object_unref (connection);
+}
+
+static void
+test_write_bridge_main (void)
+{
+	NMConnection *connection;
+	NMConnection *reread;
+	NMSettingConnection *s_con;
+	NMSettingBridge *s_bridge;
+	NMSettingIP4Config *s_ip4;
+	NMSettingIP6Config *s_ip6;
+	char *uuid;
+	const guint32 ip1 = htonl (0x01010103);
+	const guint32 gw = htonl (0x01010101);
+	const guint32 prefix = 24;
+	NMIP4Address *addr;
+	gboolean success;
+	GError *error = NULL;
+	char *testfile = NULL;
+	char *unmanaged = NULL;
+	char *keyfile = NULL;
+	char *routefile = NULL;
+	char *route6file = NULL;
+	gboolean ignore_error = FALSE;
+
+	connection = nm_connection_new ();
+	g_assert (connection);
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	g_assert (s_con);
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	uuid = nm_utils_uuid_generate ();
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Bridge Main",
+	              NM_SETTING_CONNECTION_UUID, uuid,
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_BRIDGE_SETTING_NAME,
+	              NULL);
+	g_free (uuid);
+
+	/* bridge setting */
+	s_bridge = (NMSettingBridge *) nm_setting_bridge_new ();
+	g_assert (s_bridge);
+	nm_connection_add_setting (connection, NM_SETTING (s_bridge));
+
+	g_object_set (s_bridge,
+	              NM_SETTING_BRIDGE_INTERFACE_NAME, "br0",
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIP4Config *) nm_setting_ip4_config_new ();
+	g_assert (s_ip4);
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+
+	g_object_set (s_ip4,
+	              NM_SETTING_IP4_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP4_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	addr = nm_ip4_address_new ();
+	nm_ip4_address_set_address (addr, ip1);
+	nm_ip4_address_set_prefix (addr, prefix);
+	nm_ip4_address_set_gateway (addr, gw);
+	nm_setting_ip4_config_add_address (s_ip4, addr);
+	nm_ip4_address_unref (addr);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIP6Config *) nm_setting_ip6_config_new ();
+	g_assert (s_ip6);
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+
+	g_object_set (s_ip6,
+	              NM_SETTING_IP6_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_IGNORE,
+	              NULL);
+
+	g_assert (nm_connection_verify (connection, &error));
+	g_assert_no_error (error);
+
+	/* Save the ifcfg */
+	success = writer_new_connection (connection,
+	                                 TEST_SCRATCH_DIR "/network-scripts/",
+	                                 &testfile,
+	                                 &error);
+	g_assert (success);
+	g_assert_cmpstr (testfile, !=, NULL);
+
+	/* re-read the connection for comparison */
+	reread = connection_from_file (testfile,
+	                               NULL,
+	                               TYPE_BRIDGE,
+	                               NULL,
+	                               &unmanaged,
+	                               &keyfile,
+	                               &routefile,
+	                               &route6file,
+	                               &error,
+	                               &ignore_error);
+	unlink (testfile);
+
+	g_assert (reread);
+	g_assert (nm_connection_verify (reread, &error));
+	g_assert_no_error (error);
+	g_assert (nm_connection_compare (connection, reread, NM_SETTING_COMPARE_FLAG_EXACT));
+
+	g_free (testfile);
+	g_free (unmanaged);
+	g_free (keyfile);
+	g_free (routefile);
+	g_free (route6file);
+	g_object_unref (connection);
+	g_object_unref (reread);
 }
 
 #define TEST_IFCFG_BRIDGE_COMPONENT TEST_IFCFG_DIR"/network-scripts/ifcfg-test-bridge-component"
@@ -9835,12 +9968,15 @@ static void
 test_read_bridge_component (void)
 {
 	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingBridgePort *s_port;
 	char *unmanaged = NULL;
 	char *keyfile = NULL;
 	char *routefile = NULL;
 	char *route6file = NULL;
 	gboolean ignore_error = FALSE;
 	GError *error = NULL;
+	gboolean success;
 
 	connection = connection_from_file (TEST_IFCFG_BRIDGE_COMPONENT,
 	                                   NULL,
@@ -9852,19 +9988,134 @@ test_read_bridge_component (void)
 	                                   &route6file,
 	                                   &error,
 	                                   &ignore_error);
-	ASSERT (connection != NULL,
-	        "bridge-component-read", "unexpected failure reading %s", TEST_IFCFG_BRIDGE_COMPONENT);
+	g_assert (connection);
 
-	ASSERT (unmanaged != NULL,
-	        "bridge-component-read", "missing unmanaged spec from %s", TEST_IFCFG_BRIDGE_COMPONENT);
+	success = nm_connection_verify (connection, &error);
+	g_assert_no_error (error);
+	g_assert (success);
 
-	ASSERT (g_strcmp0 (unmanaged, "mac:00:22:15:59:62:97") == 0,
-	        "bridge-component-read", "unexpected unmanaged spec from %s", TEST_IFCFG_BRIDGE_COMPONENT);
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_master (s_con), ==, "br0");
+	g_assert_cmpstr (nm_setting_connection_get_slave_type (s_con), ==, NM_SETTING_BRIDGE_SETTING_NAME);
+
+	s_port = nm_connection_get_setting_bridge_port (connection);
+	g_assert (s_port);
+	g_assert (nm_setting_bridge_port_get_hairpin_mode (s_port));
+	g_assert_cmpuint (nm_setting_bridge_port_get_priority (s_port), ==, 28);
+	g_assert_cmpuint (nm_setting_bridge_port_get_path_cost (s_port), ==, 100);
 
 	g_object_unref (connection);
 	g_free (unmanaged);
 }
 
+static void
+test_write_bridge_component (void)
+{
+	NMConnection *connection;
+	NMConnection *reread;
+	NMSettingConnection *s_con;
+	NMSettingWired *s_wired;
+	NMSetting *s_port;
+	static unsigned char tmpmac[] = { 0x31, 0x33, 0x33, 0x37, 0xbe, 0xcd };
+	GByteArray *mac;
+	guint32 mtu = 1492;
+	char *uuid;
+	gboolean success;
+	GError *error = NULL;
+	char *testfile = NULL;
+	char *unmanaged = NULL;
+	char *keyfile = NULL;
+	char *routefile = NULL;
+	char *route6file = NULL;
+	gboolean ignore_error = FALSE;
+
+	connection = nm_connection_new ();
+	g_assert (connection);
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	g_assert (s_con);
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	uuid = nm_utils_uuid_generate ();
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Bridge Component",
+	              NM_SETTING_CONNECTION_UUID, uuid,
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+				  NM_SETTING_CONNECTION_MASTER, "br0",
+				  NM_SETTING_CONNECTION_SLAVE_TYPE, NM_SETTING_BRIDGE_SETTING_NAME,
+	              NULL);
+	g_free (uuid);
+
+	/* Wired setting */
+	s_wired = (NMSettingWired *) nm_setting_wired_new ();
+	g_assert (s_wired);
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	mac = g_byte_array_sized_new (sizeof (tmpmac));
+	g_byte_array_append (mac, &tmpmac[0], sizeof (tmpmac));
+
+	g_object_set (s_wired,
+	              NM_SETTING_WIRED_MAC_ADDRESS, mac,
+	              NM_SETTING_WIRED_MTU, mtu,
+	              NULL);
+	g_byte_array_free (mac, TRUE);
+
+	/* Bridge port */
+	s_port = nm_setting_bridge_port_new ();
+	nm_connection_add_setting (connection, s_port);
+	g_object_set (s_port,
+	              NM_SETTING_BRIDGE_PORT_PRIORITY, 50,
+	              NM_SETTING_BRIDGE_PORT_PATH_COST, 33,
+	              NULL);
+
+	success = nm_connection_verify (connection, &error);
+	g_assert_no_error (error);
+	g_assert (success);
+
+	/* Save the ifcfg */
+	success = writer_new_connection (connection,
+	                                 TEST_SCRATCH_DIR "/network-scripts/",
+	                                 &testfile,
+	                                 &error);
+	g_assert_no_error (error);
+	g_assert (success);
+	g_assert (testfile);
+
+	/* re-read the connection for comparison */
+	reread = connection_from_file (testfile,
+	                               NULL,
+	                               TYPE_ETHERNET,
+	                               NULL,
+	                               &unmanaged,
+	                               &keyfile,
+	                               &routefile,
+	                               &route6file,
+	                               &error,
+	                               &ignore_error);
+	unlink (testfile);
+
+	g_assert (reread);
+
+	success = nm_connection_verify (reread, &error);
+	g_assert_no_error (error);
+
+	g_assert (nm_connection_compare (connection, reread, NM_SETTING_COMPARE_FLAG_EXACT));
+
+	if (route6file)
+		unlink (route6file);
+
+	g_free (testfile);
+	g_free (unmanaged);
+	g_free (keyfile);
+	g_free (routefile);
+	g_free (route6file);
+	g_object_unref (connection);
+	g_object_unref (reread);
+}
+
 #define TEST_IFCFG_INFINIBAND TEST_IFCFG_DIR"/network-scripts/ifcfg-test-infiniband"
 
 static void
@@ -10847,13 +11098,16 @@ int main (int argc, char **argv)
 	test_write_bond_main ();
 	test_write_bond_slave ();
 
+	test_read_bridge_main ();
+	test_write_bridge_main ();
+	test_read_bridge_component ();
+	test_write_bridge_component ();
+
 	/* Stuff we expect to fail for now */
 	test_write_wired_pppoe ();
 	test_write_vpn ();
 	test_write_mobile_broadband (TRUE);
 	test_write_mobile_broadband (FALSE);
-	test_read_bridge_main ();
-	test_read_bridge_component ();
 
 	base = g_path_get_basename (argv[0]);
 	fprintf (stdout, "%s: SUCCESS\n", base);
diff --git a/system-settings/plugins/ifcfg-rh/utils.c b/system-settings/plugins/ifcfg-rh/utils.c
index d29cc5c..4b515ba 100644
--- a/system-settings/plugins/ifcfg-rh/utils.c
+++ b/system-settings/plugins/ifcfg-rh/utils.c
@@ -349,7 +349,8 @@ utils_ignore_ip_config (NMConnection *connection)
 	/* bonding slaves have no IP configuration, and the system
 	 * scripts just ignore it if it's there.
 	 */
-	if (nm_setting_connection_is_slave_type (s_con, NM_SETTING_BOND_SETTING_NAME))
+	if (   nm_setting_connection_is_slave_type (s_con, NM_SETTING_BOND_SETTING_NAME)
+	    || nm_setting_connection_is_slave_type (s_con, NM_SETTING_BRIDGE_SETTING_NAME))
 		return TRUE;
 
 	return FALSE;
diff --git a/system-settings/plugins/ifcfg-rh/writer.c b/system-settings/plugins/ifcfg-rh/writer.c
index 4fdb332..6ab3325 100644
--- a/system-settings/plugins/ifcfg-rh/writer.c
+++ b/system-settings/plugins/ifcfg-rh/writer.c
@@ -1175,6 +1175,136 @@ write_bonding_setting (NMConnection *connection, shvarFile *ifcfg, GError **erro
 	return TRUE;
 }
 
+static guint32
+get_setting_default (NMSetting *setting, const char *prop)
+{
+	GParamSpec *pspec;
+	GValue val = { 0 };
+	guint32 ret = 0;
+
+	pspec = g_object_class_find_property (G_OBJECT_GET_CLASS (setting), prop);
+	g_assert (pspec);
+	g_value_init (&val, pspec->value_type);
+	g_param_value_set_default (pspec, &val);
+	g_assert (G_VALUE_HOLDS_UINT (&val));
+	ret = g_value_get_uint (&val);
+	g_value_unset (&val);
+	return ret;
+}
+
+static gboolean
+write_bridge_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+{
+	NMSettingBridge *s_bridge;
+	const char *iface;
+	guint32 i;
+	GString *opts;
+	char *s;
+
+	s_bridge = nm_connection_get_setting_bridge (connection);
+	if (!s_bridge) {
+		g_set_error (error, IFCFG_PLUGIN_ERROR, 0,
+		             "Missing '%s' setting", NM_SETTING_BRIDGE_SETTING_NAME);
+		return FALSE;
+	}
+
+	iface = nm_setting_bridge_get_interface_name (s_bridge);
+	if (!iface) {
+		g_set_error (error, IFCFG_PLUGIN_ERROR, 0, "Missing interface name");
+		return FALSE;
+	}
+
+	svSetValue (ifcfg, "DEVICE", iface, FALSE);
+	svSetValue (ifcfg, "BRIDGING_OPTS", NULL, FALSE);
+	svSetValue (ifcfg, "STP", NULL, FALSE);
+	svSetValue (ifcfg, "DELAY", NULL, FALSE);
+
+	/* Bridge options */
+	opts = g_string_sized_new (32);
+
+	if (nm_setting_bridge_get_stp (s_bridge)) {
+		svSetValue (ifcfg, "STP", "yes", FALSE);
+
+		i = nm_setting_bridge_get_forward_delay (s_bridge);
+		if (i && i != get_setting_default (NM_SETTING (s_bridge), NM_SETTING_BRIDGE_FORWARD_DELAY)) {
+			s = g_strdup_printf ("%u", i);
+			svSetValue (ifcfg, "DELAY", s, FALSE);
+			g_free (s);
+		}
+
+		g_string_append_printf (opts, "priority=%u", nm_setting_bridge_get_priority (s_bridge));
+
+		i = nm_setting_bridge_get_hello_time (s_bridge);
+		if (i && i != get_setting_default (NM_SETTING (s_bridge), NM_SETTING_BRIDGE_HELLO_TIME)) {
+			if (opts->len)
+				g_string_append_c (opts, ' ');
+			g_string_append_printf (opts, "hello_time=%u", i);
+		}
+
+		i = nm_setting_bridge_get_max_age (s_bridge);
+		if (i && i != get_setting_default (NM_SETTING (s_bridge), NM_SETTING_BRIDGE_MAX_AGE)) {
+			if (opts->len)
+				g_string_append_c (opts, ' ');
+			g_string_append_printf (opts, "max_age=%u", i);
+		}
+	}
+
+	i = nm_setting_bridge_get_ageing_time (s_bridge);
+	if (i != get_setting_default (NM_SETTING (s_bridge), NM_SETTING_BRIDGE_AGEING_TIME)) {
+		if (opts->len)
+			g_string_append_c (opts, ' ');
+		g_string_append_printf (opts, "ageing_time=%u", i);
+	}
+
+	if (opts->len)
+		svSetValue (ifcfg, "BRIDGING_OPTS", opts->str, FALSE);
+	g_string_free (opts, TRUE);
+
+	svSetValue (ifcfg, "TYPE", TYPE_BRIDGE, FALSE);
+
+	return TRUE;
+}
+
+static gboolean
+write_bridge_port_setting (NMConnection *connection, shvarFile *ifcfg, GError **error)
+{
+	NMSettingBridgePort *s_port;
+	guint32 i;
+	GString *opts;
+
+	s_port = nm_connection_get_setting_bridge_port (connection);
+	if (!s_port)
+		return TRUE;
+
+	svSetValue (ifcfg, "BRIDGING_OPTS", NULL, FALSE);
+
+	/* Bridge options */
+	opts = g_string_sized_new (32);
+
+	i = nm_setting_bridge_port_get_priority (s_port);
+	if (i && i != get_setting_default (NM_SETTING (s_port), NM_SETTING_BRIDGE_PORT_PRIORITY))
+		g_string_append_printf (opts, "priority=%u", i);
+
+	i = nm_setting_bridge_port_get_path_cost (s_port);
+	if (i && i != get_setting_default (NM_SETTING (s_port), NM_SETTING_BRIDGE_PORT_PATH_COST)) {
+		if (opts->len)
+			g_string_append_c (opts, ' ');
+		g_string_append_printf (opts, "path_cost=%u", i);
+	}
+
+	if (nm_setting_bridge_port_get_hairpin_mode (s_port)) {
+		if (opts->len)
+			g_string_append_c (opts, ' ');
+		g_string_append_printf (opts, "hairpin_mode=1");
+	}
+
+	if (opts->len)
+		svSetValue (ifcfg, "BRIDGING_OPTS", opts->str, FALSE);
+	g_string_free (opts, TRUE);
+
+	return TRUE;
+}
+
 static void
 write_connection_setting (NMSettingConnection *s_con, shvarFile *ifcfg)
 {
@@ -1198,6 +1328,8 @@ write_connection_setting (NMSettingConnection *s_con, shvarFile *ifcfg)
 	if (master) {
 		if (nm_setting_connection_is_slave_type (s_con, NM_SETTING_BOND_SETTING_NAME))
 			svSetValue (ifcfg, "MASTER", master, FALSE);
+		else if (nm_setting_connection_is_slave_type (s_con, NM_SETTING_BRIDGE_SETTING_NAME))
+			svSetValue (ifcfg, "BRIDGE", master, FALSE);
 	}
 }
 
@@ -1837,6 +1969,9 @@ write_connection (NMConnection *connection,
 	} else if (!strcmp (type, NM_SETTING_BOND_SETTING_NAME)) {
 		if (!write_bonding_setting (connection, ifcfg, error))
 			goto out;
+	} else if (!strcmp (type, NM_SETTING_BRIDGE_SETTING_NAME)) {
+		if (!write_bridge_setting (connection, ifcfg, error))
+			goto out;
 	} else {
 		g_set_error (error, IFCFG_PLUGIN_ERROR, 0,
 		             "Can't write connection type '%s'", type);
@@ -1848,6 +1983,9 @@ write_connection (NMConnection *connection,
 			goto out;
 	}
 
+	if (!write_bridge_port_setting (connection, ifcfg, error))
+		goto out;
+
 	if (!utils_ignore_ip_config (connection)) {
 		if (!write_ip4_setting (connection, ifcfg, error))
 			goto out;
diff --git a/system-settings/plugins/keyfile/tests/keyfiles/Makefile.am b/system-settings/plugins/keyfile/tests/keyfiles/Makefile.am
index 7f74b8b..19cd6f9 100644
--- a/system-settings/plugins/keyfile/tests/keyfiles/Makefile.am
+++ b/system-settings/plugins/keyfile/tests/keyfiles/Makefile.am
@@ -5,6 +5,8 @@ EXTRA_DIST = \
 	Test_Wired_Connection_MAC_Case \
 	Test_Wired_Connection_IP6 \
 	Test_InfiniBand_Connection \
+	Test_Bridge_Main \
+	Test_Bridge_Component \
 	ATT_Data_Connect_BT \
 	ATT_Data_Connect_Plain
 
diff --git a/system-settings/plugins/keyfile/tests/keyfiles/Test_Bridge_Component b/system-settings/plugins/keyfile/tests/keyfiles/Test_Bridge_Component
new file mode 100644
index 0000000..f5463ed
--- /dev/null
+++ b/system-settings/plugins/keyfile/tests/keyfiles/Test_Bridge_Component
@@ -0,0 +1,15 @@
+[connection]
+id=Test Bridge Component
+uuid=d7b4f96c-c45e-4298-bef8-f48574f8c1c0
+type=802-3-ethernet
+master=br0
+slave-type=bridge
+
+[802-3-ethernet]
+mac-address=00:22:15:59:62:97
+
+[bridge-port]
+priority=28
+hairpin-mode=true
+path-cost=100
+
diff --git a/system-settings/plugins/keyfile/tests/keyfiles/Test_Bridge_Main b/system-settings/plugins/keyfile/tests/keyfiles/Test_Bridge_Main
new file mode 100644
index 0000000..7fbbfe2
--- /dev/null
+++ b/system-settings/plugins/keyfile/tests/keyfiles/Test_Bridge_Main
@@ -0,0 +1,17 @@
+[connection]
+id=Test Bridge Main
+uuid=8f061643-fe41-4d4c-a8d9-097d26e2ad3a
+type=bridge
+
+[bridge]
+interface-name=br0
+stp=true
+forward-delay=0
+priority=32744
+hello-time=7
+max-age=39
+ageing-time=235352
+
+[ipv4]
+method=auto
+
diff --git a/system-settings/plugins/keyfile/tests/test-keyfile.c b/system-settings/plugins/keyfile/tests/test-keyfile.c
index f165101..8d8208b 100644
--- a/system-settings/plugins/keyfile/tests/test-keyfile.c
+++ b/system-settings/plugins/keyfile/tests/test-keyfile.c
@@ -1970,6 +1970,261 @@ test_write_infiniband_connection (void)
 	g_object_unref (connection);
 }
 
+#define TEST_BRIDGE_MAIN_FILE TEST_KEYFILES_DIR"/Test_Bridge_Main"
+
+static void
+test_read_bridge_main (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingIP4Config *s_ip4;
+	NMSettingBridge *s_bridge;
+	GError *error = NULL;
+	const char *expected_id = "Test Bridge Main";
+	const char *expected_uuid = "8f061643-fe41-4d4c-a8d9-097d26e2ad3a";
+	gboolean success;
+
+	connection = connection_from_file (TEST_BRIDGE_MAIN_FILE);
+	g_assert (connection);
+	success = nm_connection_verify (connection, &error);
+	g_assert_no_error (error);
+	g_assert (success);
+
+	/* Connection setting */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, expected_id);
+	g_assert_cmpstr (nm_setting_connection_get_uuid (s_con), ==, expected_uuid);
+
+	/* IPv4 setting */
+	s_ip4 = nm_connection_get_setting_ip4_config (connection);
+	g_assert (s_ip4);
+	g_assert_cmpstr (nm_setting_ip4_config_get_method (s_ip4), ==, NM_SETTING_IP4_CONFIG_METHOD_AUTO);
+
+	/* Bridge setting */
+	s_bridge = nm_connection_get_setting_bridge (connection);
+	g_assert (s_bridge);
+	g_assert_cmpstr (nm_setting_bridge_get_interface_name (s_bridge), ==, "br0");
+	g_assert_cmpuint (nm_setting_bridge_get_forward_delay (s_bridge), ==, 0);
+	g_assert_cmpuint (nm_setting_bridge_get_stp (s_bridge), ==, TRUE);
+	g_assert_cmpuint (nm_setting_bridge_get_priority (s_bridge), ==, 32744);
+	g_assert_cmpuint (nm_setting_bridge_get_hello_time (s_bridge), ==, 7);
+	g_assert_cmpuint (nm_setting_bridge_get_max_age (s_bridge), ==, 39);
+	g_assert_cmpuint (nm_setting_bridge_get_ageing_time (s_bridge), ==, 235352);
+
+	g_object_unref (connection);
+}
+
+static void
+test_write_bridge_main (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingBridge *s_bridge;
+	NMSettingIP4Config *s_ip4;
+	NMSettingIP6Config *s_ip6;
+	char *uuid;
+	gboolean success;
+	NMConnection *reread;
+	char *testfile = NULL;
+	GError *error = NULL;
+	pid_t owner_grp;
+	uid_t owner_uid;
+
+	connection = nm_connection_new ();
+	g_assert (connection);
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	g_assert (s_con);
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	uuid = nm_utils_uuid_generate ();
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Bridge Main",
+	              NM_SETTING_CONNECTION_UUID, uuid,
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_BRIDGE_SETTING_NAME,
+	              NULL);
+	g_free (uuid);
+
+	/* Bridge setting */
+	s_bridge = (NMSettingBridge *) nm_setting_bridge_new ();
+	g_assert (s_bridge);
+	nm_connection_add_setting (connection, NM_SETTING (s_bridge));
+
+	g_object_set (s_bridge,
+	              NM_SETTING_BRIDGE_INTERFACE_NAME, "br0",
+	              NULL);
+
+	/* IP4 setting */
+	s_ip4 = (NMSettingIP4Config *) nm_setting_ip4_config_new ();
+	g_assert (s_ip4);
+	nm_connection_add_setting (connection, NM_SETTING (s_ip4));
+	g_object_set (s_ip4,
+	              NM_SETTING_IP4_CONFIG_METHOD, NM_SETTING_IP4_CONFIG_METHOD_MANUAL,
+	              NM_SETTING_IP4_CONFIG_MAY_FAIL, TRUE,
+	              NULL);
+
+	add_one_ip4_address (s_ip4, "1.2.3.4", "1.1.1.1", 24);
+
+	/* IP6 setting */
+	s_ip6 = (NMSettingIP6Config *) nm_setting_ip6_config_new ();
+	g_assert (s_ip6);
+	nm_connection_add_setting (connection, NM_SETTING (s_ip6));
+	g_object_set (s_ip6, NM_SETTING_IP6_CONFIG_METHOD, NM_SETTING_IP6_CONFIG_METHOD_AUTO, NULL);
+
+	/* Write out the connection */
+	owner_uid = geteuid ();
+	owner_grp = getegid ();
+	success = write_connection (connection, TEST_SCRATCH_DIR, owner_uid, owner_grp, &testfile, &error);
+	g_assert_no_error (error);
+	g_assert (success);
+	g_assert (testfile);
+
+	/* Read the connection back in and compare it to the one we just wrote out */
+	reread = connection_from_file (testfile);
+	g_assert (reread);
+
+	g_assert (nm_connection_compare (connection, reread, NM_SETTING_COMPARE_FLAG_EXACT));
+
+	unlink (testfile);
+	g_free (testfile);
+
+	g_object_unref (reread);
+	g_object_unref (connection);
+}
+
+#define TEST_BRIDGE_COMPONENT_FILE TEST_KEYFILES_DIR"/Test_Bridge_Component"
+
+static void
+test_read_bridge_component (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingBridgePort *s_port;
+	NMSettingWired *s_wired;
+	const GByteArray *array;
+	guint8 expected_mac[ETH_ALEN] = { 0x00, 0x22, 0x15, 0x59, 0x62, 0x97 };
+	GError *error = NULL;
+	const char *expected_id = "Test Bridge Component";
+	const char *expected_uuid = "d7b4f96c-c45e-4298-bef8-f48574f8c1c0";
+	gboolean success;
+
+	connection = connection_from_file (TEST_BRIDGE_COMPONENT_FILE);
+	g_assert (connection);
+	success = nm_connection_verify (connection, &error);
+	g_assert_no_error (error);
+	g_assert (success);
+
+	/* Connection setting */
+	s_con = nm_connection_get_setting_connection (connection);
+	g_assert (s_con);
+	g_assert_cmpstr (nm_setting_connection_get_id (s_con), ==, expected_id);
+	g_assert_cmpstr (nm_setting_connection_get_uuid (s_con), ==, expected_uuid);
+	g_assert_cmpstr (nm_setting_connection_get_master (s_con), ==, "br0");
+	g_assert (nm_setting_connection_is_slave_type (s_con, NM_SETTING_BRIDGE_SETTING_NAME));
+
+	/* Wired setting */
+	s_wired = nm_connection_get_setting_wired (connection);
+	g_assert (s_wired);
+	array = nm_setting_wired_get_mac_address (s_wired);
+	g_assert (array);
+	g_assert_cmpint (array->len, ==, ETH_ALEN);
+	g_assert_cmpint (memcmp (array->data, expected_mac, sizeof (expected_mac)), ==, 0);
+
+	/* BridgePort setting */
+	s_port = nm_connection_get_setting_bridge_port (connection);
+	g_assert (s_port);
+	g_assert (nm_setting_bridge_port_get_hairpin_mode (s_port));
+	g_assert_cmpuint (nm_setting_bridge_port_get_priority (s_port), ==, 28);
+	g_assert_cmpuint (nm_setting_bridge_port_get_path_cost (s_port), ==, 100);
+
+	g_object_unref (connection);
+}
+
+static void
+test_write_bridge_component (void)
+{
+	NMConnection *connection;
+	NMSettingConnection *s_con;
+	NMSettingBridgePort *s_port;
+	NMSettingWired *s_wired;
+	char *uuid;
+	GByteArray *mac;
+	guint8 tmpmac[] = { 0x99, 0x88, 0x77, 0x66, 0x55, 0x44 };
+	gboolean success;
+	NMConnection *reread;
+	char *testfile = NULL;
+	GError *error = NULL;
+	pid_t owner_grp;
+	uid_t owner_uid;
+
+	connection = nm_connection_new ();
+	g_assert (connection);
+
+	/* Connection setting */
+	s_con = (NMSettingConnection *) nm_setting_connection_new ();
+	g_assert (s_con);
+	nm_connection_add_setting (connection, NM_SETTING (s_con));
+
+	uuid = nm_utils_uuid_generate ();
+	g_object_set (s_con,
+	              NM_SETTING_CONNECTION_ID, "Test Write Bridge Component",
+	              NM_SETTING_CONNECTION_UUID, uuid,
+	              NM_SETTING_CONNECTION_AUTOCONNECT, TRUE,
+	              NM_SETTING_CONNECTION_TYPE, NM_SETTING_WIRED_SETTING_NAME,
+	              NM_SETTING_CONNECTION_MASTER, "br0",
+	              NM_SETTING_CONNECTION_SLAVE_TYPE, NM_SETTING_BRIDGE_SETTING_NAME,
+	              NULL);
+	g_free (uuid);
+
+	/* Wired setting */
+	s_wired = NM_SETTING_WIRED (nm_setting_wired_new ());
+	g_assert (s_wired);
+	nm_connection_add_setting (connection, NM_SETTING (s_wired));
+
+	mac = g_byte_array_sized_new (ETH_ALEN);
+	g_byte_array_append (mac, &tmpmac[0], sizeof (tmpmac));
+	g_object_set (s_wired,
+	              NM_SETTING_WIRED_MAC_ADDRESS, mac,
+	              NM_SETTING_WIRED_MTU, 1300,
+	              NULL);
+	g_byte_array_free (mac, TRUE);
+
+	/* BridgePort setting */
+	s_port = (NMSettingBridgePort *) nm_setting_bridge_port_new ();
+	g_assert (s_port);
+	nm_connection_add_setting (connection, NM_SETTING (s_port));
+
+	g_object_set (s_port,
+	              NM_SETTING_BRIDGE_PORT_PRIORITY, 3,
+	              NM_SETTING_BRIDGE_PORT_PATH_COST, 99,
+	              NULL);
+
+	/* Write out the connection */
+	owner_uid = geteuid ();
+	owner_grp = getegid ();
+	success = write_connection (connection, TEST_SCRATCH_DIR, owner_uid, owner_grp, &testfile, &error);
+	g_assert_no_error (error);
+	g_assert (success);
+	g_assert (testfile);
+
+	/* Read the connection back in and compare it to the one we just wrote out */
+	reread = connection_from_file (testfile);
+	g_assert_no_error (error);
+	g_assert (reread);
+
+	g_assert (nm_connection_compare (connection, reread, NM_SETTING_COMPARE_FLAG_EXACT));
+
+	unlink (testfile);
+	g_free (testfile);
+
+	g_object_unref (reread);
+	g_object_unref (connection);
+}
+
+
 int main (int argc, char **argv)
 {
 	GError *error = NULL;
@@ -2003,6 +2258,11 @@ int main (int argc, char **argv)
 	test_read_infiniband_connection ();
 	test_write_infiniband_connection ();
 
+	test_read_bridge_main ();
+	test_write_bridge_main ();
+	test_read_bridge_component ();
+	test_write_bridge_component ();
+
 	base = g_path_get_basename (argv[0]);
 	fprintf (stdout, "%s: SUCCESS\n", base);
 	g_free (base);
-- 
1.7.1

